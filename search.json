[
  {
    "objectID": "quizzes/Q01_IntroPOO.html",
    "href": "quizzes/Q01_IntroPOO.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "¬øCu√°l es la principal diferencia entre la Programaci√≥n Estructurada y la Programaci√≥n Orientada a Objetos?\n\nLa Programaci√≥n Estructurada usa funciones, mientras que la POO no.\n\nLa POO modela datos en objetos con atributos y m√©todos, mientras que la Programaci√≥n Estructurada organiza c√≥digo en bloques l√≥gicos. ‚úÖ\n\nLa Programaci√≥n Estructurada usa clases y objetos, mientras que la POO usa funciones.\n\nEn la Programaci√≥n Estructurada no existen bucles ni condicionales.\n\n¬øCu√°les son los cuatro pilares de la Programaci√≥n Orientada a Objetos?\n\nAbstracci√≥n, Encapsulamiento, Modularidad, Estructuraci√≥n\n\nClases, Objetos, M√©todos, Herencia\n\nAbstracci√≥n, Encapsulamiento, Polimorfismo, Herencia ‚úÖ\n\nM√©todos, Funciones, Herencia, Atributos\n\n¬øQu√© es una clase en Python?\n\nUn objeto que almacena datos en forma de diccionario.\n\nUna plantilla para crear objetos que contienen atributos y m√©todos. ‚úÖ\n\nUna funci√≥n especial que inicializa variables en Python.\n\nUna estructura de control para agrupar funciones.\n\n¬øQu√© es un objeto en Python?\n\nUna instancia de una clase ‚úÖ\n\nUna variable dentro de una funci√≥n\n\nUn tipo de dato exclusivo de POO\n\nUn m√©todo dentro de una clase\n\n¬øCu√°l es la sintaxis correcta para definir una clase en Python?\n\ndef MiClase:\n\nclass MiClase: ‚úÖ\n\nnew MiClase:\n\nMiClase = class\n\n¬øCu√°l de las siguientes afirmaciones sobre los atributos de una clase es correcta?\n\nLos atributos de instancia son compartidos por todos los objetos.\n\nLos atributos de clase son √∫nicos para cada instancia.\n\nLos atributos de instancia son espec√≠ficos de cada objeto. ‚úÖ\n\nNo se pueden modificar los atributos de una clase despu√©s de su creaci√≥n.\n\n¬øQu√© hace el m√©todo __init__ en una clase?\n\nInicializa una instancia de la clase ‚úÖ\n\nBorra un objeto de la memoria\n\nEjecuta una funci√≥n al final del programa\n\nPermite llamar a la clase sin necesidad de instanciarla\n\n¬øPor qu√© se usa self en los m√©todos de una clase?\n\nPara llamar a m√©todos externos\n\nPara acceder a los atributos y m√©todos de la propia instancia ‚úÖ\n\nPara crear un objeto dentro de la clase\n\nNo es necesario, es solo una convenci√≥n\n\n¬øCu√°l es la diferencia entre un m√©todo de clase y un m√©todo de instancia?\n\nUn m√©todo de clase no puede modificar atributos de instancia. ‚úÖ\n\nUn m√©todo de clase solo se usa en clases abstractas.\n\nUn m√©todo de instancia no puede acceder a atributos de la clase.\n\nNo hay diferencia entre ambos.\n\n¬øCu√°l es la caracter√≠stica principal de un m√©todo est√°tico?\n\n\n\nPuede acceder a atributos de instancia.\n\nNo necesita self ni cls y se puede llamar sin instanciar la clase. ‚úÖ\n\nSolo puede usarse dentro del __init__.\n\nRequiere siempre un par√°metro cls.\n\n\n\n\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\npersona1 = Persona(\"Ana\")\nprint(persona1.nombre)\n\nAna\n\n\n\nPersona\n\nAna ‚úÖ\n\nNone\n\nError de sintaxis\n\n\n¬øCu√°l es el error en este c√≥digo?\n\n\nclass Estudiante:\n    def __init__(nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n\nNo se debe usar self en __init__\n\nFalta definir los atributos en el constructor\n\nEl primer par√°metro de __init__ debe ser self ‚úÖ\n\nself no puede almacenar atributos\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return 3.14 * self.radio ** 2\n\ncirculo1 = Circulo(5)\nprint(circulo1.area())\n\n3.14\n\n25\n\n78.5 ‚úÖ\n\nError de ejecuci√≥n\n\n\n¬øCu√°l ser√° la salida del siguiente c√≥digo?\n\n\nclass Vehiculo:\n    cantidad_vehiculos = 0\n\n    def __init__(self, marca):\n        self.marca = marca\n        Vehiculo.cantidad_vehiculos += 1\n\nauto1 = Vehiculo(\"Toyota\")\nprint(Vehiculo.cantidad_vehiculos)\nauto2 = Vehiculo(\"Ford\")\n\n1\n\n\n\n\n1\n\n2 ‚úÖ\n\n0\n\nError de ejecuci√≥n\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Animal:\n    def hacer_sonido(self):\n        return \"Haciendo un sonido\"\n\nclass Perro(Animal):\n    def hacer_sonido(self):\n        return \"Ladrando\"\n\nmascota = Perro()\nprint(mascota.hacer_sonido())\n\nHaciendo un sonido\n\nLadrando ‚úÖ\n\nError de ejecuci√≥n\n\nNone\n\n\n¬øC√≥mo modificar√≠as la siguiente clase para contar el n√∫mero de estudiantes creados?\n\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nAgregar un atributo de clase y aumentarlo en el constructor ‚úÖ\n\nUsar @staticmethod\n\nCrear una funci√≥n fuera de la clase\n\nNo se puede hacer\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Calculadora:\n    @staticmethod\n    def sumar(a, b):\n        return a + b\n\nresultado = Calculadora.sumar(10, 5)\nprint(resultado)\n\n10\n\n15 ‚úÖ\n\nError de ejecuci√≥n\n\nNone\n\n\n¬øC√≥mo mejorar√≠as el siguiente c√≥digo con herencia?\n\n\nclass Estudiante:\n    def __init__(self, nombre, edad, carrera):\n        self.nombre = nombre\n        self.edad = edad\n        self.carrera = carrera\n\nCrear una clase Persona y heredar desde Estudiante ‚úÖ\n\nEliminar edad\n\nHacer carrera un atributo de clase\n\nNo se puede mejorar\n\n\n\n¬øCu√°l ser√° la salida del siguiente c√≥digo?\n\na) `Windows` ‚úÖ  \nb) `Linux`  \nc) `Error de ejecuci√≥n`  \nd) `None`  \n\n::: {#8144e828 .cell execution_count=9}\n``` {.python .cell-code}\nclass Computadora:\n sistema_operativo = \"Windows\"\n\ncomp1 = Computadora()\ncomp2 = Computadora()\n\ncomp1.sistema_operativo = \"Linux\"\nprint(comp2.sistema_operativo)\n\nWindows\n\n:::\n\n¬øEl siguiente c√≥digo tiene errores?\n\n\n\n\nS√≠, porque falta __init__ en la clase ‚úÖ\n\nS√≠, porque split() no funciona en Python\n\nNo, funciona correctamente\n\nS√≠, porque cls no es v√°lido\n\n\nclass Estudiante:\n    @classmethod\n    def desde_cadena(cls, datos):\n        nombre, edad = datos.split(\",\")\n        return cls(nombre, int(edad))"
  },
  {
    "objectID": "quizzes/Q01_IntroPOO.html#clases-objetos-y-constructores-en-python",
    "href": "quizzes/Q01_IntroPOO.html#clases-objetos-y-constructores-en-python",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "¬øCu√°l es la principal diferencia entre la Programaci√≥n Estructurada y la Programaci√≥n Orientada a Objetos?\n\nLa Programaci√≥n Estructurada usa funciones, mientras que la POO no.\n\nLa POO modela datos en objetos con atributos y m√©todos, mientras que la Programaci√≥n Estructurada organiza c√≥digo en bloques l√≥gicos. ‚úÖ\n\nLa Programaci√≥n Estructurada usa clases y objetos, mientras que la POO usa funciones.\n\nEn la Programaci√≥n Estructurada no existen bucles ni condicionales.\n\n¬øCu√°les son los cuatro pilares de la Programaci√≥n Orientada a Objetos?\n\nAbstracci√≥n, Encapsulamiento, Modularidad, Estructuraci√≥n\n\nClases, Objetos, M√©todos, Herencia\n\nAbstracci√≥n, Encapsulamiento, Polimorfismo, Herencia ‚úÖ\n\nM√©todos, Funciones, Herencia, Atributos\n\n¬øQu√© es una clase en Python?\n\nUn objeto que almacena datos en forma de diccionario.\n\nUna plantilla para crear objetos que contienen atributos y m√©todos. ‚úÖ\n\nUna funci√≥n especial que inicializa variables en Python.\n\nUna estructura de control para agrupar funciones.\n\n¬øQu√© es un objeto en Python?\n\nUna instancia de una clase ‚úÖ\n\nUna variable dentro de una funci√≥n\n\nUn tipo de dato exclusivo de POO\n\nUn m√©todo dentro de una clase\n\n¬øCu√°l es la sintaxis correcta para definir una clase en Python?\n\ndef MiClase:\n\nclass MiClase: ‚úÖ\n\nnew MiClase:\n\nMiClase = class\n\n¬øCu√°l de las siguientes afirmaciones sobre los atributos de una clase es correcta?\n\nLos atributos de instancia son compartidos por todos los objetos.\n\nLos atributos de clase son √∫nicos para cada instancia.\n\nLos atributos de instancia son espec√≠ficos de cada objeto. ‚úÖ\n\nNo se pueden modificar los atributos de una clase despu√©s de su creaci√≥n.\n\n¬øQu√© hace el m√©todo __init__ en una clase?\n\nInicializa una instancia de la clase ‚úÖ\n\nBorra un objeto de la memoria\n\nEjecuta una funci√≥n al final del programa\n\nPermite llamar a la clase sin necesidad de instanciarla\n\n¬øPor qu√© se usa self en los m√©todos de una clase?\n\nPara llamar a m√©todos externos\n\nPara acceder a los atributos y m√©todos de la propia instancia ‚úÖ\n\nPara crear un objeto dentro de la clase\n\nNo es necesario, es solo una convenci√≥n\n\n¬øCu√°l es la diferencia entre un m√©todo de clase y un m√©todo de instancia?\n\nUn m√©todo de clase no puede modificar atributos de instancia. ‚úÖ\n\nUn m√©todo de clase solo se usa en clases abstractas.\n\nUn m√©todo de instancia no puede acceder a atributos de la clase.\n\nNo hay diferencia entre ambos.\n\n¬øCu√°l es la caracter√≠stica principal de un m√©todo est√°tico?\n\n\n\nPuede acceder a atributos de instancia.\n\nNo necesita self ni cls y se puede llamar sin instanciar la clase. ‚úÖ\n\nSolo puede usarse dentro del __init__.\n\nRequiere siempre un par√°metro cls.\n\n\n\n\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\npersona1 = Persona(\"Ana\")\nprint(persona1.nombre)\n\nAna\n\n\n\nPersona\n\nAna ‚úÖ\n\nNone\n\nError de sintaxis\n\n\n¬øCu√°l es el error en este c√≥digo?\n\n\nclass Estudiante:\n    def __init__(nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n\nNo se debe usar self en __init__\n\nFalta definir los atributos en el constructor\n\nEl primer par√°metro de __init__ debe ser self ‚úÖ\n\nself no puede almacenar atributos\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return 3.14 * self.radio ** 2\n\ncirculo1 = Circulo(5)\nprint(circulo1.area())\n\n3.14\n\n25\n\n78.5 ‚úÖ\n\nError de ejecuci√≥n\n\n\n¬øCu√°l ser√° la salida del siguiente c√≥digo?\n\n\nclass Vehiculo:\n    cantidad_vehiculos = 0\n\n    def __init__(self, marca):\n        self.marca = marca\n        Vehiculo.cantidad_vehiculos += 1\n\nauto1 = Vehiculo(\"Toyota\")\nprint(Vehiculo.cantidad_vehiculos)\nauto2 = Vehiculo(\"Ford\")\n\n1\n\n\n\n\n1\n\n2 ‚úÖ\n\n0\n\nError de ejecuci√≥n\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Animal:\n    def hacer_sonido(self):\n        return \"Haciendo un sonido\"\n\nclass Perro(Animal):\n    def hacer_sonido(self):\n        return \"Ladrando\"\n\nmascota = Perro()\nprint(mascota.hacer_sonido())\n\nHaciendo un sonido\n\nLadrando ‚úÖ\n\nError de ejecuci√≥n\n\nNone\n\n\n¬øC√≥mo modificar√≠as la siguiente clase para contar el n√∫mero de estudiantes creados?\n\n\nclass Estudiante:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nAgregar un atributo de clase y aumentarlo en el constructor ‚úÖ\n\nUsar @staticmethod\n\nCrear una funci√≥n fuera de la clase\n\nNo se puede hacer\n\n\n¬øCu√°l es la salida del siguiente c√≥digo?\n\n\nclass Calculadora:\n    @staticmethod\n    def sumar(a, b):\n        return a + b\n\nresultado = Calculadora.sumar(10, 5)\nprint(resultado)\n\n10\n\n15 ‚úÖ\n\nError de ejecuci√≥n\n\nNone\n\n\n¬øC√≥mo mejorar√≠as el siguiente c√≥digo con herencia?\n\n\nclass Estudiante:\n    def __init__(self, nombre, edad, carrera):\n        self.nombre = nombre\n        self.edad = edad\n        self.carrera = carrera\n\nCrear una clase Persona y heredar desde Estudiante ‚úÖ\n\nEliminar edad\n\nHacer carrera un atributo de clase\n\nNo se puede mejorar\n\n\n\n¬øCu√°l ser√° la salida del siguiente c√≥digo?\n\na) `Windows` ‚úÖ  \nb) `Linux`  \nc) `Error de ejecuci√≥n`  \nd) `None`  \n\n::: {#8144e828 .cell execution_count=9}\n``` {.python .cell-code}\nclass Computadora:\n sistema_operativo = \"Windows\"\n\ncomp1 = Computadora()\ncomp2 = Computadora()\n\ncomp1.sistema_operativo = \"Linux\"\nprint(comp2.sistema_operativo)\n\nWindows\n\n:::\n\n¬øEl siguiente c√≥digo tiene errores?\n\n\n\n\nS√≠, porque falta __init__ en la clase ‚úÖ\n\nS√≠, porque split() no funciona en Python\n\nNo, funciona correctamente\n\nS√≠, porque cls no es v√°lido\n\n\nclass Estudiante:\n    @classmethod\n    def desde_cadena(cls, datos):\n        nombre, edad = datos.split(\",\")\n        return cls(nombre, int(edad))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "Este curso se enfoca en el desarrollo de soluciones computacionales mediante programaci√≥n aplicada, reforzando el pensamiento algor√≠tmico, el dise√±o de soluciones y la implementaci√≥n estructurada de programas."
  },
  {
    "objectID": "index.html#descripci√≥n-del-curso",
    "href": "index.html#descripci√≥n-del-curso",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "Este curso se enfoca en el desarrollo de soluciones computacionales mediante programaci√≥n aplicada, reforzando el pensamiento algor√≠tmico, el dise√±o de soluciones y la implementaci√≥n estructurada de programas."
  },
  {
    "objectID": "index.html#objetivos-generales",
    "href": "index.html#objetivos-generales",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 Objetivos generales",
    "text": "2 Objetivos generales\n\nAplicar principios de programaci√≥n para resolver problemas computacionales de complejidad media.\nDise√±ar algoritmos claros y estructurados a partir de la especificaci√≥n de un problema.\nImplementar y documentar soluciones en un lenguaje de programaci√≥n, siguiendo buenas pr√°cticas."
  },
  {
    "objectID": "index.html#organizaci√≥n-del-sitio",
    "href": "index.html#organizaci√≥n-del-sitio",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Organizaci√≥n del sitio",
    "text": "3 Organizaci√≥n del sitio\n\nClases: material por sesi√≥n (diapositivas y notas).\nPr√°cticas: Ejericicios pr√°cticos para aplicar los conceptos vistos en clase."
  },
  {
    "objectID": "clases2025/Untitled-Copy1.html",
    "href": "clases2025/Untitled-Copy1.html",
    "title": "Tarea 02: Repaso Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Instrucciones: Para las siguientes preguntas y ejercicios de c√≥digo, utilizaremos como material de apoyo el video del siguiente enlace:\nProgramaci√≥n Orientada a Objetos (POO): Abstracci√≥n, Encapsulamiento, Herencia, Polimorfismo\n\nDe acuerdo con lo explicado en el video y usando tus propias palabras, responde las siguientes preguntas.\n\n¬øQu√© es la Programaci√≥n Orientada a Objetos?\n¬øQu√© es una clase?\n¬øQu√© es un objeto?\n¬øQu√© son los atributos?\n¬øQu√© son los m√©todos?\nExplica el prop√≥sito de un constructor en una clase.\n¬øCuales son los pilares de la Programaci√≥n Orientada a Objetos?\nDefine el encapsulamiento y por qu√© es importante.\nExplica la diferencia entre atributos/m√©todos p√∫blicos y privados en una clase.\n¬øCu√°l es la funci√≥n de los m√©todos Getter y Setter en la encapsulaci√≥n?\n¬øCu√°l es el prop√≥sito de una clase base en el contexto de la herencia?\n\nCodifica en Python algunas de las clases que aparecen en el video, con los atributos y m√©todos mencionados.\n\nTaza\n\nCrear las instancias de la clase que aparecen en el video.\nHacer las operaciones de cambio de valores en los atributos.\n\nCanci√≥n\n\nSi tu n√∫mero de cuenta es impar: implementa la clase para una biblioteca de m√∫sica.\nSi tu n√∫mero de cuenta es par: implementa la clase para una p√°gina de ventas.\nIncluye un atributo de clase que sea privado y que cuente la cantidad de instancias de la clase que han sido creadas. Adem√°s, implementa un m√©todo de clase tipo getter para consultar este valor.\nConvierte alguno de los atributos en atributo privado e implementa sus m√©todos getter y setter.\nCrea dos instancias de la clase y demuestra el funcionamiento de los m√©todos.\n\nPersonaje\n\nCrea la clase base y sus clases derivadas\nCrea una instancia para cada clase.\nEncuentra un ejemplo en el c√≥digo donde se utiliza la funci√≥n super(), ¬øcon qu√© prop√≥sito se emplea?"
  },
  {
    "objectID": "clases2025/Untitled-Copy1.html#parte-1",
    "href": "clases2025/Untitled-Copy1.html#parte-1",
    "title": "Tarea 02: Repaso Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Instrucciones: Para las siguientes preguntas y ejercicios de c√≥digo, utilizaremos como material de apoyo el video del siguiente enlace:\nProgramaci√≥n Orientada a Objetos (POO): Abstracci√≥n, Encapsulamiento, Herencia, Polimorfismo\n\nDe acuerdo con lo explicado en el video y usando tus propias palabras, responde las siguientes preguntas.\n\n¬øQu√© es la Programaci√≥n Orientada a Objetos?\n¬øQu√© es una clase?\n¬øQu√© es un objeto?\n¬øQu√© son los atributos?\n¬øQu√© son los m√©todos?\nExplica el prop√≥sito de un constructor en una clase.\n¬øCuales son los pilares de la Programaci√≥n Orientada a Objetos?\nDefine el encapsulamiento y por qu√© es importante.\nExplica la diferencia entre atributos/m√©todos p√∫blicos y privados en una clase.\n¬øCu√°l es la funci√≥n de los m√©todos Getter y Setter en la encapsulaci√≥n?\n¬øCu√°l es el prop√≥sito de una clase base en el contexto de la herencia?\n\nCodifica en Python algunas de las clases que aparecen en el video, con los atributos y m√©todos mencionados.\n\nTaza\n\nCrear las instancias de la clase que aparecen en el video.\nHacer las operaciones de cambio de valores en los atributos.\n\nCanci√≥n\n\nSi tu n√∫mero de cuenta es impar: implementa la clase para una biblioteca de m√∫sica.\nSi tu n√∫mero de cuenta es par: implementa la clase para una p√°gina de ventas.\nIncluye un atributo de clase que sea privado y que cuente la cantidad de instancias de la clase que han sido creadas. Adem√°s, implementa un m√©todo de clase tipo getter para consultar este valor.\nConvierte alguno de los atributos en atributo privado e implementa sus m√©todos getter y setter.\nCrea dos instancias de la clase y demuestra el funcionamiento de los m√©todos.\n\nPersonaje\n\nCrea la clase base y sus clases derivadas\nCrea una instancia para cada clase.\nEncuentra un ejemplo en el c√≥digo donde se utiliza la funci√≥n super(), ¬øcon qu√© prop√≥sito se emplea?"
  },
  {
    "objectID": "clases2025/Untitled-Copy1.html#parte-2",
    "href": "clases2025/Untitled-Copy1.html#parte-2",
    "title": "Tarea 02: Repaso Programaci√≥n Orientada a Objetos",
    "section": "2 Parte 2",
    "text": "2 Parte 2\nInstrucciones: Para esta segunda parte, por favor selecciona solamente una secci√≥n (Parte 2A o Parte 2B). Considera que la parte 2B puede ser realizada en equipos de hasta 3 personas.\n\n2.1 Parte 2A\nInstrucciones:\nEl comit√© organizador del Mundial de Nataci√≥n est√° buscando implementar un sistema de registro para llevar un seguimiento de los nadadores participantes y sus respectivas competiciones. El sistema debe permitir el registro de nadadores, asignaci√≥n de eventos, y seguimiento de los resultados obtenidos en cada competici√≥n.\n\nImplementa las siguientes clases.\n\n\n\nNombre de la Clase\n\n\nAtributos\n\n\nM√©todos\n\n\n\n\nNadador\n\n\n\n\nNombre\n\n\nEdad\n\n\nPa√≠s de origen\n\n\nMejor tiempo personal\n\n\n\n\n\n\ninit(‚Ä¶)\n\n\n\n\n\n\nEvento\n\n\n\n\nNombre del evento\n\n\nDistancia\n\n\nCategor√≠a (masculino/femenino/mixto)\n\n\nEstilo (crol, dorso, pecho, mariposa)\n\n\n\n\n\n\ninit(‚Ä¶)\n\n\n\n\n\n\nCompetencia (Abstracta)\n\n\n-\n\n\n\n\nregistrar_resultado()\n\n\nver_resultados()\n\n\n\n\n\n\nCompetenciaNatacion (Hereda de Competencia)\n\n\n\n\nLista de nadadores participantes\n\n\nLista de eventos en la competici√≥n\n\n\n\n\n\n\ninit(‚Ä¶)\n\n\nregistrar_resultado(‚Ä¶) -&gt; str\n\n\n\n\n\nCrea los atributos necesarios para contabilizar el n√∫mero total de nadadores y de eventos.\nCambia a modo privado los atributos en la clase nadador e incluye m√©todos setter y getter para cada atributo. Deber√°s incluir validaciones en los m√©todos setter, asegurando que la informaci√≥n ingresada sea coherente (por ejemplo, edades v√°lidas, tiempos no negativos).\nAgrega un m√©todo a la clase Nadador para comparar los mejores tiempos de dos nadadores(opcionalmente y por un punto extra en el examen, implementa sobrecarga de los operadores &gt;, &lt;, &gt;=, &lt;=, ==, y !=).\nCrea al menos dos objetos de cada clase, exceptuando CompetenciaNatacion. Para √©sta √∫ltima, crea solamente una instancia.\nRegistra nadadores y eventos en la competencia de nataci√≥n.\nRegistra resultados en la competencia para cada evento y nadador.\nImprime los resultados usando el m√©todo ver_resultados.\nCompara los mejores tiempos entre los nadadores.\nMuestra un ejemplo de name mangling en el c√≥digo. ¬øCu√°l es el prop√≥sito de esta t√©cnica?\n¬øPor qu√© se utiliza una clase abstracta en el c√≥digo? ¬øCu√°l es el prop√≥sito de tener m√©todos abstractos?\nExplica la diferencia entre atributos de instancia y de clase. Proporciona ejemplos espec√≠ficos de ambos en el c√≥digo.\n\n\n\n2.2 Parte 2B (Actividad colaborativa)\nInstrucciones:\nDise√±ar un ejercicio de programaci√≥n que destaque la aplicaci√≥n de conceptos como herencia, encapsulamiento, polimorfismo y abstracci√≥n. Este ejercicio debe inspirarse en temas relacionados con otras asignaturas y mostrar la capacidad de las/los estudiantes para integrar conocimientos de manera interdisciplinaria.\nRequisitos:\n\nContexto Interdisciplinario: Insp√≠rate en temas que est√°s viendo en otras asignaturas. Puede ser un problema matem√°tico, un concepto de ciencia, un escenario de ingenier√≠a, o cualquier √°rea de inter√©s.\nConceptos de Programaci√≥n: El ejercicio debe abordar al menos dos de los siguientes conceptos de programaci√≥n:\n\nHerencia\nEncapsulamiento\nPolimorfismo\nAbstracci√≥n\n\nEstructura del Ejercicio: El ejercicio debe contener las siguientes partes\n\nDescripci√≥n del Problema: Presentar el contexto o el problema que se debe resolver utilizando programaci√≥n orientada a objetos.\nClases e Interacciones: Especificar las clases que deben ser creadas (atributos y m√©todos).\nAplicaci√≥n de Conceptos: Destacar c√≥mo se aplicar√°n los conceptos de programaci√≥n seleccionados en el ejercicio. ¬øD√≥nde se usa la herencia?, ¬øD√≥nde se aplica el polimorfismo?, etc.\nImplementaci√≥n: Presentar la soluci√≥n/implementaci√≥n del ejercicio propuesto.\nEl dise√±o de ejercicio m√°s destacado, seleccionado por un jurado de docentes de la universidad, recibir√° un punto adicional en el examen."
  },
  {
    "objectID": "clases2025/Untitled-Copy1.html#otros-conceptospreguntas-relevantes-para-estudiar",
    "href": "clases2025/Untitled-Copy1.html#otros-conceptospreguntas-relevantes-para-estudiar",
    "title": "Tarea 02: Repaso Programaci√≥n Orientada a Objetos",
    "section": "3 Otros conceptos/preguntas relevantes para estudiar",
    "text": "3 Otros conceptos/preguntas relevantes para estudiar\n\nProgramaci√≥n Orientada a Objetos (POO):\n\nPrincipios fundamentales de POO.\nConceptos de clase, objeto y constructor.\nEncapsulamiento, herencia, polimorfismo y abstracci√≥n.\nAtributos y m√©todos.\n\nEncapsulamiento:\n\nDefinici√≥n y prop√≥sito.\nAtributos y m√©todos p√∫blicos y privados.\nM√©todos getter y setter.\n\nPolimorfismo:\n\nDefinici√≥n y tipos.\nPolimorfismo con funciones y m√©todos.\nSobrecarga de operadores.\n\nHerencia:\n\nDefinici√≥n y prop√≥sito.\nClases base y derivadas.\nHerencia simple, jer√°rquica y m√∫ltiple.\n\nAbstracci√≥n:\n\nDefinici√≥n y prop√≥sito.\nConcepto de clase abstracta.\nUso del m√≥dulo abc para implementar clases abstractas en Python.\n\nM√©todos y Atributos Especiales:\n\nM√©todo super() en la herencia.\nName Mangling."
  },
  {
    "objectID": "clases2025/tarea_excepciones.html",
    "href": "clases2025/tarea_excepciones.html",
    "title": "Tarea. Manejo de excepciones",
    "section": "",
    "text": "Programaci√≥n Aplicada II, Primavera 2025, Dra. Dora Alvarado\nResponde las siguientes preguntas y realiza los ejercicios de c√≥digo utilizando el siguiente video:\nüîó Exceptions in Python || Python Tutorial\n\nEn el primer minuto del video se mencionan dos situaciones inusuales que pueden generar excepciones en un programa.\n\n¬øQu√© tipo de excepciones son, seg√∫n la lista oficial de excepciones en Python?\n\nEscribe un c√≥digo en Python que muestre estos dos ejemplos.\n\n\nInvestiga y muestra un ejemplo de otras tres excepciones que no aparezcan explicadas en el video. Revisa la lista de excepciones y su jerarqu√≠a aqu√≠.\nExplica qu√© es una excepci√≥n en programaci√≥n y en qu√© situaciones se genera.\n\n¬øQu√© es un Traceback y qu√© informaci√≥n proporciona?\n\nExplica brevemente la jerarqu√≠a de excepciones en Python y por qu√© es √∫til. Da un ejemplo de c√≥mo una excepci√≥n espec√≠fica (por ejemplo, IndexError) se relaciona con una clase base (por ejemplo, LookupError).\n¬øC√≥mo se pueden crear excepciones personalizadas en Python?\n\nEn el minuto 4:30 del video se menciona un bloque de instrucciones para manejar excepciones. ¬øCu√°l es este bloque y c√≥mo funciona cada una de sus partes? Explica con un ejemplo.\nSocratica menciona a algunos personajes y sus frases c√©lebres en el video. ¬øQui√©nes son y qu√© frases aparecen?\n\nImplementa y explica el c√≥digo en el minuto 5:15. Se hace uso de dos bibliotecas, identif√≠calas e investiga para qu√© sirven y cu√°l es su prop√≥sito dentro del c√≥digo.\nModifica la funci√≥n para que lance una excepci√≥n personalizada llamada InvalidPathTypeError si el par√°metro path no es de tipo str.\n\nNota: Las respuestas deben estar fundamentadas en la informaci√≥n proporcionada en el video. No se aceptar√°n respuestas que no correspondan con el contenido del video. El c√≥digo debe seguir la l√≥gica explicada en clases y en el video, de lo contrario no se tomar√° en cuenta."
  },
  {
    "objectID": "clases2025/Tarea04_repaso.html",
    "href": "clases2025/Tarea04_repaso.html",
    "title": "Tarea 04: Repaso Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Programaci√≥n Aplicada II, Primavera 2025, Dra. Dora Alvarado"
  },
  {
    "objectID": "clases2025/Tarea04_repaso.html#parte-1",
    "href": "clases2025/Tarea04_repaso.html#parte-1",
    "title": "Tarea 04: Repaso Programaci√≥n Orientada a Objetos",
    "section": "1 Parte 1",
    "text": "1 Parte 1\nInstrucciones: Para las siguientes actividades, utilizaremos como material de apoyo el video del siguiente enlace:\nProgramaci√≥n Orientada a Objetos (POO): Abstracci√≥n, Encapsulamiento, Herencia, Polimorfismo\n\nCon base en el contenido del video, realiza un mapa mental (guardarlo como imagen o archivo pdf bajo el formato T03_mapa_NombreApellido) que resuma los conceptos clave de la Programaci√≥n Orientada a Objetos. Tu mapa debe incluir al menos los siguientes conceptos:\n\nDefinici√≥n de Programaci√≥n Orientada a Objetos.\nClases y objetos.\nAtributos y m√©todos.\nConstructores y su prop√≥sito.\nEncapsulamiento, atributos/m√©todos privados y p√∫blicos, getters y setters.\nHerencia y clases base.\nPolimorfismo y su aplicaci√≥n.\nAbstracci√≥n y clases abstractas.\n\nCodifica en Python algunas de las clases que aparecen en el video, con los atributos y m√©todos mencionados. Guarda el archivo como T03_ejemplosvideo_NombreApellido.py o (o .ipynb si trabajaron en un notebook).\n\nTaza\n\nCrear las instancias de la clase que aparecen en el video.\nHacer las operaciones de cambio de valores en los atributos.\n\nCanci√≥n\n\nSi tu n√∫mero de cuenta es impar: implementa la clase para una biblioteca de m√∫sica.\nSi tu n√∫mero de cuenta es par: implementa la clase para una p√°gina de ventas.\nIncluye un atributo de clase que sea privado y que cuente la cantidad de instancias de la clase que han sido creadas. Adem√°s, implementa un m√©todo de clase tipo getter para consultar este valor.\nConvierte alguno de los atributos en atributo privado e implementa sus m√©todos getter y setter.\nCrea dos instancias de la clase y demuestra el funcionamiento de los m√©todos."
  },
  {
    "objectID": "clases2025/Tarea04_repaso.html#parte-2",
    "href": "clases2025/Tarea04_repaso.html#parte-2",
    "title": "Tarea 04: Repaso Programaci√≥n Orientada a Objetos",
    "section": "2 Parte 2",
    "text": "2 Parte 2\nPara esta parte, implementar√°s un modelo de juego inspirado en Plantas vs.¬†Zombies utilizando los principios de la Programaci√≥n Orientada a Objetos.\n\nClases principales:\n\nClase Planta:\n\nAtributos:\n\nvida: cantidad de vida de la planta.\np_ataque: poder de ataque de la planta.\n\nM√©todos:\n\nConstructor.\natacar(): simula un ataque a distancia. El da√±o debe ser p_ataque + random.randrange(-10, 11).\nImplementa un m√©todo dunder (__str__) para representar el estado de la planta como una cadena de texto.\n\n\nClase Zombie:\n\nAtributos:\n\nvida: cantidad de vida del zombie.\nz_ataque: poder de ataque del zombie.\ndistancia: metros que lo separan de la planta.\n\nM√©todos:\n\nConstructor.\natacar(): simula un ataque hacia la planta. El da√±o debe ser z_ataque + 2*random.randrange(-10, 11).\nacercarse(): reduce la distancia entre el zombie y la planta en 1 metro.\nImplementa un m√©todo dunder (__str__) para representar el estado del zombie como una cadena de texto.\n\n\n\nSimulaci√≥n del juego:\n\nCrea una instancia de Planta y otra de Zombie, estableciendo valores iniciales para sus atributos.\nSimula turnos, en cada turno:\n\nLa planta ataca al zombie.\nEl zombie se acerca a la planta.\nSi el zombie est√° a 1 metro o menos, ataca dos veces.\nSe imprime la vida restante de cada personaje y la distancia entre ellos.\n\nEl juego termina cuando la vida de la planta o del zombie llega a cero.\n\nPreguntas de reflexi√≥n: (Agrega tus respuestas como comentarios en el c√≥digo)\n\n¬øQu√© tipo de atributos y m√©todos hay en cada clase?\n¬øCu√°l es la condici√≥n para que termine el juego?\n¬øQu√© caracter√≠sticas adicionales podr√≠an incorporarse en las clases para hacer el juego m√°s complejo?\n\n\nGuarda el archivo como T03_plantasvszombies_NombreApellido.py (o .ipynb si usaste un notebook).\nConsideraciones:\n\nNo se revisar√° c√≥digo en formatos que no sean .py o .ipynb.\nSi el c√≥digo presenta errores de ejecuci√≥n, se penalizar√° hasta con un 50% de la calificaci√≥n.\nSi usas c√≥digo o funciones no vistas en clase, debes poder explicarlo satisfactoriamente, de lo contrario no se tomar√° en cuenta tu tarea."
  },
  {
    "objectID": "clases2025/Resumen 2do Parcial.html",
    "href": "clases2025/Resumen 2do Parcial.html",
    "title": "Resumen y Gu√≠a de Estudio sobre Manejo de Errores en Python",
    "section": "",
    "text": "Los programas y aplicaciones pueden enfrentar situaciones inesperadas o no v√°lidas.\nEn tales casos, se generan excepciones que se clasifican en tipos como Value Error, Index Error, Name Error, Attribute Error, Syntax Error, IOError, ZeroDivisionError, entre otros.\n\n\n\n\n\nSituaciones de error o eventos inesperados durante la ejecuci√≥n que interrumpen el flujo normal del programa.\nEn Python, son mecanismos para declarar y responder a condiciones excepcionales.\n\n\n\n\n\nProporcionan informaci√≥n valiosa sobre posibles errores en el c√≥digo.\nMejoran la confiabilidad del programa, la experiencia del usuario, facilitan la depuraci√≥n y garantizan la seguridad.\n\n\n\n\n\nPermite que el programa contin√∫e ejecut√°ndose sin interrupciones, incluso si ocurre un error.\nBloque try para el c√≥digo que podr√≠a generar una excepci√≥n.\nBloque except para manejar la excepci√≥n espec√≠fica.\nIdentificadores opcionales (as nombre) vinculan la excepci√≥n para su an√°lisis.\n\n\n\n\n\nelse se ejecuta cuando no hay excepciones en el bloque try.\n√ötil para c√≥digo que debe ejecutarse solo si no hay excepciones.\nfinally se ejecuta siempre, independientemente de si hay excepciones o no.\n√ötil para acciones de limpieza o liberaci√≥n de recursos.\n\n\n\n\n\nSe pueden crear al definir una nueva clase que herede de Exception o sus subclases.\nLanzar una excepci√≥n personalizada con raise."
  },
  {
    "objectID": "clases2025/Resumen 2do Parcial.html#resumen",
    "href": "clases2025/Resumen 2do Parcial.html#resumen",
    "title": "Resumen y Gu√≠a de Estudio sobre Manejo de Errores en Python",
    "section": "",
    "text": "Los programas y aplicaciones pueden enfrentar situaciones inesperadas o no v√°lidas.\nEn tales casos, se generan excepciones que se clasifican en tipos como Value Error, Index Error, Name Error, Attribute Error, Syntax Error, IOError, ZeroDivisionError, entre otros.\n\n\n\n\n\nSituaciones de error o eventos inesperados durante la ejecuci√≥n que interrumpen el flujo normal del programa.\nEn Python, son mecanismos para declarar y responder a condiciones excepcionales.\n\n\n\n\n\nProporcionan informaci√≥n valiosa sobre posibles errores en el c√≥digo.\nMejoran la confiabilidad del programa, la experiencia del usuario, facilitan la depuraci√≥n y garantizan la seguridad.\n\n\n\n\n\nPermite que el programa contin√∫e ejecut√°ndose sin interrupciones, incluso si ocurre un error.\nBloque try para el c√≥digo que podr√≠a generar una excepci√≥n.\nBloque except para manejar la excepci√≥n espec√≠fica.\nIdentificadores opcionales (as nombre) vinculan la excepci√≥n para su an√°lisis.\n\n\n\n\n\nelse se ejecuta cuando no hay excepciones en el bloque try.\n√ötil para c√≥digo que debe ejecutarse solo si no hay excepciones.\nfinally se ejecuta siempre, independientemente de si hay excepciones o no.\n√ötil para acciones de limpieza o liberaci√≥n de recursos.\n\n\n\n\n\nSe pueden crear al definir una nueva clase que herede de Exception o sus subclases.\nLanzar una excepci√≥n personalizada con raise."
  },
  {
    "objectID": "clases2025/Resumen 2do Parcial.html#pruebas-de-software-y-debugging",
    "href": "clases2025/Resumen 2do Parcial.html#pruebas-de-software-y-debugging",
    "title": "Resumen y Gu√≠a de Estudio sobre Manejo de Errores en Python",
    "section": "2 2. Pruebas de software y debugging",
    "text": "2 2. Pruebas de software y debugging\n\n2.1 2.1 Programaci√≥n de calidad\n\nLa programaci√≥n de calidad se refiere a escribir c√≥digo fiable, eficiente, mantenible y legible.\nEs crucial desarrollar c√≥digo robusto, f√°cil de entender y modificar, y que cumpla con los requisitos de los usuarios.\nTomarse el tiempo para escribir buen c√≥digo tiene beneficios como reducir errores, aumentar la eficiencia del desarrollo y mantenimiento, mejorar la satisfacci√≥n del usuario y reducir costos.\n\n\n\n2.2 2.2 Buenas pr√°cticas de programaci√≥n\n\nBuenas pr√°cticas de programaci√≥n incluyen la programaci√≥n defensiva, documentaci√≥n clara, seguimiento de gu√≠as de estilo, validaci√≥n de datos, pruebas exhaustivas y depuraci√≥n de errores.\n\n\n\n2.3 2.3 Aserciones\n\nLas aserciones son √∫tiles para verificar condiciones espec√≠ficas durante la ejecuci√≥n de un programa.\nSe utilizan para validar la entrada del usuario, realizar pruebas de software y documentar el comportamiento esperado del c√≥digo.\n\n\n\n2.4 2.4 Pruebas de software\n\nLa validaci√≥n y las pruebas exhaustivas son cruciales para garantizar la calidad del software.\nEsto incluye pruebas unitarias, pruebas de regresi√≥n y pruebas de integraci√≥n.\nLos enfoques de dise√±o de pruebas incluyen el enfoque de caja negra y el enfoque de caja de cristal.\n\n\n\n2.5 2.5 Depuraci√≥n\n\nEl debugging se origin√≥ con Grace Hopper y un ‚Äúbug‚Äù en la computadora Mark II.\nSe puede realizar mediante impresiones de mensajes, la biblioteca de registro y depuradores de IDE.\nEl uso de puntos de interrupci√≥n, inspecci√≥n de variables y ejecuci√≥n paso a paso son t√©cnicas valiosas para depurar."
  },
  {
    "objectID": "clases2025/Resumen 2do Parcial.html#bibliotecas-externas-en-el-√°rea-de-ingenier√≠a",
    "href": "clases2025/Resumen 2do Parcial.html#bibliotecas-externas-en-el-√°rea-de-ingenier√≠a",
    "title": "Resumen y Gu√≠a de Estudio sobre Manejo de Errores en Python",
    "section": "3 3. Bibliotecas externas en el √°rea de Ingenier√≠a",
    "text": "3 3. Bibliotecas externas en el √°rea de Ingenier√≠a\n\n3.1 3.1 Bibliotecas externas\n\nEn programaci√≥n, una biblioteca externa es un conjunto de c√≥digo predefinido y desarrollado por terceros que proporciona funcionalidades espec√≠ficas para ser utilizadas por programas.\nEstas bibliotecas est√°n dise√±adas para extender y mejorar la funcionalidad.\nPython carece de ciertas operaciones b√°sicas en ingenier√≠a, como arreglos, matrices, integraci√≥n, soluci√≥n de sistemas de ecuaciones, etc.\nSe utilizan bibliotecas externas especializadas en ingenier√≠a, como NumPy, Matplotlib, SymPy y Pandas.\n\n\n\n3.2 3.2 Ejemplos de Bibliotecas Externas:\n\nNumPy:\n\nEspecializado en procesamiento num√©rico.\nOfrece eficientes operaciones con arreglos multidimensionales.\n\nMatplotlib:\n\nBiblioteca de visualizaci√≥n en 2D y 3D.\nEsencial para crear gr√°ficos est√°ticos, interactivos y diagramas de dispersi√≥n.\n\nSymPy:\n\nPermite c√°lculos simb√≥licos y manipulaci√≥n de expresiones algebraicas.\n√ötil para derivadas, integrales, l√≠mites y manipulaci√≥n algebraica avanzada.\n\nPandas:\n\nProporciona estructuras de datos flexibles para trabajar con datos estructurados o tabulares.\nEficiente para el an√°lisis y manipulaci√≥n de conjuntos de datos.\n\n\n\n\n3.3 3.3 NumPy\n\nFuncionalidad:\n\nNumPy se especializa en el procesamiento num√©rico a trav√©s de arreglos multidimensionales (matrices, vectores, tensores).\nOfrece operaciones eficientes para sumas, promedios, multiplicaciones y manipulaciones de matrices.\n\nVentajas:\n\nIntroduce el objeto de almacenamiento de datos llamado ndarray, m√°s eficiente que las listas de Python.\nFacilita operaciones num√©ricas avanzadas y √°lgebra lineal.\nMejora significativamente la velocidad de c√°lculos en comparaci√≥n con las listas de Python.\n\nUso:\n\nLa convenci√≥n recomendada para importar NumPy es import numpy as np.\nHay diversas formas de crear arreglos, ya sea a partir de listas, con valores predeterminados o utilizando funciones espec√≠ficas.\nSe pueden acceder y manipular elementos de los arreglos mediante indexaci√≥n y slicing.\nFacilita la lectura y escritura de datos desde y hacia archivos, con funciones como np.loadtxt y np.savetxt.\nPermite realizar operaciones entre arreglos de diferentes tama√±os, transformando autom√°ticamente los arreglos para que tengan dimensiones compatibles.\n\n\n\n3.3.1 3.3.1 √Ålgebra Lineal con NumPy\nNumPy tambi√©n ofrece herramientas poderosas para realizar operaciones de √°lgebra lineal:\n\nMultiplicaci√≥n de Matrices:\n\nSe puede realizar usando np.dot() o el operador @.\n\nDeterminante de una Matriz:\n\nSe puede calcular usando `np.linalg\n\n\n.det()`.\n\nMatriz Inversa:\n\nSe obtiene con np.linalg.inv(). No todas las matrices tienen una inversa.\n\nResolver Sistemas de Ecuaciones:\n\nNumPy proporciona np.linalg.solve() para resolver sistemas de ecuaciones lineales."
  },
  {
    "objectID": "clases2025/notas.html",
    "href": "clases2025/notas.html",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Introducci√≥n\n\nDefinici√≥n OOP\nObjetivos\nPrincipios\n\n¬øQu√© es una clase?\n¬øQu√© es un objeto?\nEjemplos y analog√≠as de clase y objeto\n¬øC√≥mo crear una clase y un objeto en Python?\n¬øQu√© es un constructor?\n\n\n\n\nExisten 6 paradigmas de desarrollo de software:\n\nProgramaci√≥n Estructurada\nProgramaci√≥n Orientada a Objetos\nProgramaci√≥n L√≥gica\nProgramaci√≥n Declarativa\nProgramaci√≥n Imperativa\n\nEn el curso anterior, usamos programaci√≥n estructurada y funcional: los programas se ejecutan de forma secuencial (una instrucci√≥n tras otra) y lo √∫nico que puede desviar el flujo son las estructuras condicionales, las estructuras de repetici√≥n o las funciones.\n\n\n\nLa Programaci√≥n Orientada a Objetos (OOP, por sus siglas en ingl√©s) es un paradigma de desarrollo de sofware que consiste en modelar sistemas a trav√©s de la creaci√≥n de objetos que contienen atributos y m√©todos.\n\n\n\n\nEscalabilidad: Facilitar la creaci√≥n de software de calidad\nOrganizaci√≥n: Mejorar el mantenimiento de sofware\nAgilidad: Extender las caracter√≠sticas del sofware\nReutilizaci√≥n:\nUsabilidad:\n\n\n\n\nHasta ahora, hemos visto que Python ofrece distintos tipos de datos para crear variables (int, float, String, etc)\nPero tambi√©n ofrece la posibilidad de crear nuestros propios tipos de datos para modelar conceptos m√°s complejos.\n\n\n\nEs una plantilla para definir un tipo de dato compuesto por atributos y m√©todos.\n\n\n\n\n\nEn programaci√≥n, un objeto es un valor o variable cuyo tipo de dato es compuesto, es decir es elemento que tiene atributos y m√©todos.\nM√°s t√©cnicamente, un objeto es una instancia de una clase en la memoria del programa.\n\n\n\n\n\nPiensa en una clase como un cortador de galletas y en un objeto como una galleta en particular\nOtra manera de asociar los conceptos es pensar en una clase como un plano, y en un objeto como el elemento que ya se ha construido a partir de dicho plano.\nUn ejemplo de clase puede ser un perfil de Twitter. Los atributos que deben tener los perfiles son nombre, fotograf√≠a, biograf√≠a, n√∫mero de seguidores, etc. Los m√©todos (o comportamientos) son postear, responder, reaccionar a una publicaci√≥n, etc.\n\n\n\n\n\nEn Python, la creaci√≥n de objetos se realiza mediante el uso de clases. Aqu√≠ hay un ejemplo b√°sico de c√≥mo crear una clase y un objeto en Python:\nclass Estudiante:\n    def __init__(self, nombre, edad, carrera):\n        self.nombre = nombre\n        self.edad = edad\n        self.carrera = carrera\n\n    def mostrar_informacion(self):\n        print(f\"Nombre: {self.nombre}, Edad: {self.edad}, Carrera: {self.carrera}\")\n\n# Crear un objeto de la clase Estudiante\nestudiante1 = Estudiante(\"Juan\", 20, \"Ingenier√≠a Inform√°tica\")\n\n# Llamar a un m√©todo del objeto\nestudiante1.mostrar_informacion()\nEn este ejemplo, la clase Estudiante tiene tres atributos (nombre, edad, carrera) y un m√©todo (mostrar_informacion). El m√©todo __init__ se utiliza como el constructor de la clase para inicializar los atributos cuando se crea un nuevo objeto.\n\n\n\nUn constructor es un m√©todo especial en una clase que se llama autom√°ticamente cuando se crea un objeto de esa clase. En Python, el constructor se llama __init__ y se utiliza para inicializar los atributos del objeto. Aqu√≠ hay un ejemplo:\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n# Crear un objeto de la clase Persona\npersona1 = Persona(\"Ana\", 25)\nEn este caso, el constructor __init__ toma dos par√°metros (nombre y edad) y los asigna a los atributos correspondientes (self.nombre y self.edad). Cuando se crea el objeto persona1, el constructor se ejecuta autom√°ticamente.\nCon esta informaci√≥n, los estudiantes de ingenier√≠a podr√°n comprender los conceptos b√°sicos de la Programaci√≥n Orientada a Objetos y c√≥mo aplicarlos en Python.\nPara cumplir los objetivos anteriores, se utilizan los siguientes conceptos, que explicaremos durante este primer parcial.\nHerencia Polimorfismo Encapsulaci√≥n Abstracci√≥n Modularidad\nLaurentine K.Masson. 30 ejercicios de programaci√≥n orientada a objetos en Python para practicar: Un conjunto de ejercicios con diferentes niveles de complejidad | Principiante - Intermedio - Avanzado | Correcci√≥n (p.¬†57). Edici√≥n de Kindle.\n¬°Entendido! Aqu√≠ tienes un enunciado para un ejercicio similar al proporcionado, que involucra una versi√≥n simplificada de Plants vs.¬†Zombies en Python:\n\n\n\n\nCrea un mini Plantas vs.¬†Zombies mediante la implementaci√≥n de las clases Planta y Zombie.\nClase Planta: - Deber√° tener los siguientes atributos: vida (vida) y poder de ataque (p_ataque). - Deber√° tener los siguientes m√©todos: - constructor - atacar: que simule un ataque a distancia. El da√±o de cada ataque debe ser p_ataque + random.randrange(-10, 11). Ojo: se debe hacer uso de la biblioteca est√°ndar random (import random).\nClase Zombie: - Deber√° tener los siguientes atributos: vida (vida), poder de ataque (z_ataque) y la distancia a la planta (distancia). - Deber√° tener los siguientes m√©todos: - constructor - atacar: que simule un ataque hacia la planta. El da√±o de cada ataque debe ser z_ataque + 2*random.randrange(-10, 11). - acercarse: que reduce la distancia entre el zombie y la planta en 1 metro.\nPrograma principal: - Crea una instancia de la clase Planta y otra de la clase Zombie. Establezca una distancia inicial entre ellos. - En cada turno: - la planta ataca al zombie - el zombie se acerque a la planta. - si el zombie est√° a 1 metro de la planta o menos, ataca dos veces. - imprime informaci√≥n sobre el turno, incluyendo la vida restante de la planta y del zombie. - El juego termina cuando la vida de la planta llega a cero (zombie gana) o la vida del zombie llega a cero (planta gana).\nPreguntas: - ¬øQu√© tipo de atributos y m√©todos hay en cada clase? - ¬øCu√°l es la condici√≥n para que termine el juego? - ¬øQu√© caracter√≠sticas adicionales podr√≠an incorporarse en las clases para hacer el juego m√°s complejo?\n\n\nLa planta ataca al zombie y le causa 17 de da√±o. Vida del zombie: 63 El zombie se acerca a la planta. Distancia actual: 4 La planta ataca al zombie y le causa 22 de da√±o. Vida del zombie: 41 El zombie se acerca a la planta. Distancia actual: 3 La planta ataca al zombie y le causa 13 de da√±o. Vida del zombie: 28 El zombie se acerca a la planta. Distancia actual: 2 La planta ataca al zombie y le causa 24 de da√±o. Vida del zombie: 4 El zombie est√° a 1 metro y ataca dos veces a la planta. Vida de la planta: 51 La planta ataca al zombie y le causa 25 de da√±o. Vida del zombie: 0 ¬°El zombie ha ganado!"
  },
  {
    "objectID": "clases2025/notas.html#contenido",
    "href": "clases2025/notas.html#contenido",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Introducci√≥n\n\nDefinici√≥n OOP\nObjetivos\nPrincipios\n\n¬øQu√© es una clase?\n¬øQu√© es un objeto?\nEjemplos y analog√≠as de clase y objeto\n¬øC√≥mo crear una clase y un objeto en Python?\n¬øQu√© es un constructor?"
  },
  {
    "objectID": "clases2025/notas.html#introducci√≥n",
    "href": "clases2025/notas.html#introducci√≥n",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Existen 6 paradigmas de desarrollo de software:\n\nProgramaci√≥n Estructurada\nProgramaci√≥n Orientada a Objetos\nProgramaci√≥n L√≥gica\nProgramaci√≥n Declarativa\nProgramaci√≥n Imperativa\n\nEn el curso anterior, usamos programaci√≥n estructurada y funcional: los programas se ejecutan de forma secuencial (una instrucci√≥n tras otra) y lo √∫nico que puede desviar el flujo son las estructuras condicionales, las estructuras de repetici√≥n o las funciones."
  },
  {
    "objectID": "clases2025/notas.html#programaci√≥n-orientada-a-objetos-1",
    "href": "clases2025/notas.html#programaci√≥n-orientada-a-objetos-1",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "La Programaci√≥n Orientada a Objetos (OOP, por sus siglas en ingl√©s) es un paradigma de desarrollo de sofware que consiste en modelar sistemas a trav√©s de la creaci√≥n de objetos que contienen atributos y m√©todos."
  },
  {
    "objectID": "clases2025/notas.html#objetivos-de-la-oop",
    "href": "clases2025/notas.html#objetivos-de-la-oop",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Escalabilidad: Facilitar la creaci√≥n de software de calidad\nOrganizaci√≥n: Mejorar el mantenimiento de sofware\nAgilidad: Extender las caracter√≠sticas del sofware\nReutilizaci√≥n:\nUsabilidad:"
  },
  {
    "objectID": "clases2025/notas.html#clase-y-objeto",
    "href": "clases2025/notas.html#clase-y-objeto",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Hasta ahora, hemos visto que Python ofrece distintos tipos de datos para crear variables (int, float, String, etc)\nPero tambi√©n ofrece la posibilidad de crear nuestros propios tipos de datos para modelar conceptos m√°s complejos.\n\n\n\nEs una plantilla para definir un tipo de dato compuesto por atributos y m√©todos.\n\n\n\n\n\nEn programaci√≥n, un objeto es un valor o variable cuyo tipo de dato es compuesto, es decir es elemento que tiene atributos y m√©todos.\nM√°s t√©cnicamente, un objeto es una instancia de una clase en la memoria del programa.\n\n\n\n\n\nPiensa en una clase como un cortador de galletas y en un objeto como una galleta en particular\nOtra manera de asociar los conceptos es pensar en una clase como un plano, y en un objeto como el elemento que ya se ha construido a partir de dicho plano.\nUn ejemplo de clase puede ser un perfil de Twitter. Los atributos que deben tener los perfiles son nombre, fotograf√≠a, biograf√≠a, n√∫mero de seguidores, etc. Los m√©todos (o comportamientos) son postear, responder, reaccionar a una publicaci√≥n, etc."
  },
  {
    "objectID": "clases2025/notas.html#c√≥mo-crear-un-objeto-en-python",
    "href": "clases2025/notas.html#c√≥mo-crear-un-objeto-en-python",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "En Python, la creaci√≥n de objetos se realiza mediante el uso de clases. Aqu√≠ hay un ejemplo b√°sico de c√≥mo crear una clase y un objeto en Python:\nclass Estudiante:\n    def __init__(self, nombre, edad, carrera):\n        self.nombre = nombre\n        self.edad = edad\n        self.carrera = carrera\n\n    def mostrar_informacion(self):\n        print(f\"Nombre: {self.nombre}, Edad: {self.edad}, Carrera: {self.carrera}\")\n\n# Crear un objeto de la clase Estudiante\nestudiante1 = Estudiante(\"Juan\", 20, \"Ingenier√≠a Inform√°tica\")\n\n# Llamar a un m√©todo del objeto\nestudiante1.mostrar_informacion()\nEn este ejemplo, la clase Estudiante tiene tres atributos (nombre, edad, carrera) y un m√©todo (mostrar_informacion). El m√©todo __init__ se utiliza como el constructor de la clase para inicializar los atributos cuando se crea un nuevo objeto."
  },
  {
    "objectID": "clases2025/notas.html#qu√©-es-un-constructor",
    "href": "clases2025/notas.html#qu√©-es-un-constructor",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Un constructor es un m√©todo especial en una clase que se llama autom√°ticamente cuando se crea un objeto de esa clase. En Python, el constructor se llama __init__ y se utiliza para inicializar los atributos del objeto. Aqu√≠ hay un ejemplo:\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n# Crear un objeto de la clase Persona\npersona1 = Persona(\"Ana\", 25)\nEn este caso, el constructor __init__ toma dos par√°metros (nombre y edad) y los asigna a los atributos correspondientes (self.nombre y self.edad). Cuando se crea el objeto persona1, el constructor se ejecuta autom√°ticamente.\nCon esta informaci√≥n, los estudiantes de ingenier√≠a podr√°n comprender los conceptos b√°sicos de la Programaci√≥n Orientada a Objetos y c√≥mo aplicarlos en Python.\nPara cumplir los objetivos anteriores, se utilizan los siguientes conceptos, que explicaremos durante este primer parcial.\nHerencia Polimorfismo Encapsulaci√≥n Abstracci√≥n Modularidad\nLaurentine K.Masson. 30 ejercicios de programaci√≥n orientada a objetos en Python para practicar: Un conjunto de ejercicios con diferentes niveles de complejidad | Principiante - Intermedio - Avanzado | Correcci√≥n (p.¬†57). Edici√≥n de Kindle.\n¬°Entendido! Aqu√≠ tienes un enunciado para un ejercicio similar al proporcionado, que involucra una versi√≥n simplificada de Plants vs.¬†Zombies en Python:"
  },
  {
    "objectID": "clases2025/notas.html#ejercicio-mini-plantas-vs-zombies",
    "href": "clases2025/notas.html#ejercicio-mini-plantas-vs-zombies",
    "title": "1 Programaci√≥n Orientada a Objetos",
    "section": "",
    "text": "Crea un mini Plantas vs.¬†Zombies mediante la implementaci√≥n de las clases Planta y Zombie.\nClase Planta: - Deber√° tener los siguientes atributos: vida (vida) y poder de ataque (p_ataque). - Deber√° tener los siguientes m√©todos: - constructor - atacar: que simule un ataque a distancia. El da√±o de cada ataque debe ser p_ataque + random.randrange(-10, 11). Ojo: se debe hacer uso de la biblioteca est√°ndar random (import random).\nClase Zombie: - Deber√° tener los siguientes atributos: vida (vida), poder de ataque (z_ataque) y la distancia a la planta (distancia). - Deber√° tener los siguientes m√©todos: - constructor - atacar: que simule un ataque hacia la planta. El da√±o de cada ataque debe ser z_ataque + 2*random.randrange(-10, 11). - acercarse: que reduce la distancia entre el zombie y la planta en 1 metro.\nPrograma principal: - Crea una instancia de la clase Planta y otra de la clase Zombie. Establezca una distancia inicial entre ellos. - En cada turno: - la planta ataca al zombie - el zombie se acerque a la planta. - si el zombie est√° a 1 metro de la planta o menos, ataca dos veces. - imprime informaci√≥n sobre el turno, incluyendo la vida restante de la planta y del zombie. - El juego termina cuando la vida de la planta llega a cero (zombie gana) o la vida del zombie llega a cero (planta gana).\nPreguntas: - ¬øQu√© tipo de atributos y m√©todos hay en cada clase? - ¬øCu√°l es la condici√≥n para que termine el juego? - ¬øQu√© caracter√≠sticas adicionales podr√≠an incorporarse en las clases para hacer el juego m√°s complejo?\n\n\nLa planta ataca al zombie y le causa 17 de da√±o. Vida del zombie: 63 El zombie se acerca a la planta. Distancia actual: 4 La planta ataca al zombie y le causa 22 de da√±o. Vida del zombie: 41 El zombie se acerca a la planta. Distancia actual: 3 La planta ataca al zombie y le causa 13 de da√±o. Vida del zombie: 28 El zombie se acerca a la planta. Distancia actual: 2 La planta ataca al zombie y le causa 24 de da√±o. Vida del zombie: 4 El zombie est√° a 1 metro y ataca dos veces a la planta. Vida de la planta: 51 La planta ataca al zombie y le causa 25 de da√±o. Vida del zombie: 0 ¬°El zombie ha ganado!"
  },
  {
    "objectID": "clases2025/guia-de-estudio_2doParcial.html",
    "href": "clases2025/guia-de-estudio_2doParcial.html",
    "title": "Gu√≠a de Estudio",
    "section": "",
    "text": "Programaci√≥n Aplicada II, Primavera 2025, Dra. Dora Alvarado\n\n0.1 Parte 1: Teor√≠a\n\n¬øQu√© es herencia? ¬øC√≥mo favorece la reutilizaci√≥n de c√≥digo?\nExplica con tus palabras qu√© es una clase abstracta y cu√°ndo conviene usarla.\n¬øQu√© ventajas ofrece el polimorfismo en sistemas grandes con muchas clases?\n¬øQu√© son las excepciones en Python y por qu√© es importante su manejo?\nDescribe brevemente tres tipos comunes de excepciones en Python.\n¬øQu√© diferencia hay entre try-except y try-except-else-finally?\n¬øPor qu√© es √∫til crear excepciones personalizadas? Da un ejemplo.\n¬øQu√© es una aserci√≥n (assert) y c√≥mo se relaciona con la validaci√≥n?\n¬øQu√© diferencia hay entre pruebas de caja negra y caja de cristal?\n¬øQu√© es unittest y c√≥mo se organiza una clase para crear pruebas unitarias?\nExplica qu√© es el ‚Äútraceback‚Äù y c√≥mo se interpreta.\n¬øQu√© herramientas de debugging existen en Python?\n¬øQu√© ventajas tiene logging frente a print?\n¬øCu√°l es la diferencia entre herencia m√∫ltiple y jer√°rquica?\n¬øC√≥mo afecta la programaci√≥n defensiva a la calidad del software?\n\n\n\n\n0.2 Parte 2: Ejercicios\n\nUn robot de laboratorio realiza an√°lisis qu√≠micos y necesita calcular la suma de los logaritmos de las concentraciones de dos compuestos.\n\n\nCrea una excepci√≥n personalizada ValorNegativoError.\nImplementa una funci√≥n suma_logaritmos(a, b) que:\n\nUse np.log10().\nLance ValorNegativoError si alguno de los valores es negativo.\n\nImplementa suma_logaritmos_segura(a, b) que:\n\nUse assert para validar que ambos valores sean positivos.\n\nEn el flujo principal (usa if __name__ == '__main__':‚Ä¶), solicita al usuario dos valores de entrada.\n\nUsa bloques try-except para manejar ValorNegativoError, ValueError, y AssertionError.\n\nCrea un m√≥dulo de pruebas test_logaritmos.py con unittest, que:\n\nPruebe casos v√°lidos.\nVerifique que se lancen las excepciones esperadas para valores negativos.\n\n\n\nIdentifica y corrige los errores en las funciones de los archivos adjuntos, usando los m√©todos de depuraci√≥n que vimos en clase.\n\nfactorial(n) ‚Äì Debe calcular el factorial de n (int positivo).\nes_primo(n) ‚Äì Determina si n es primo.\nfibonacci(n) ‚Äì Devuelve los primeros n t√©rminos de la serie de Fibonacci.\n\nDocumenta c√≥mo los encontraste y a√±ade validaciones de entrada para verificar que funcionan correctamente una vez corregidos.\nCrea la siguiente matriz en la menor cantidad de l√≠neas posibles. A partir de esta matriz principal, genera las submatrices:\n\nAzul\nRoja\nAmarilla\n\n\n\nAdem√°s, investiga c√≥mo realizar las siguientes operaciones:\n\nLa multiplicaci√≥n de dos matrices 2x2.\nLa transpuesta de una matriz.\nEl determinante de una matriz 3√ó3.\nResolver un sistema de ecuaciones lineales del tipo:\n\n2x + y = 5  \n4x ‚Äì 6y = ‚Äì2\n\nTip para estas √∫ltimas actividades: Usa np.linalg.solve(), np.dot(), np.linalg.det() y np.transpose()."
  },
  {
    "objectID": "clases2025/ExamenPractico3E.html",
    "href": "clases2025/ExamenPractico3E.html",
    "title": "Examen Pr√°ctico 3",
    "section": "",
    "text": "Instrucciones Generales:\n\nEste examen consta de tres partes, cada una con varios ejercicios relacionados con el an√°lisis y la visualizaci√≥n de funciones matem√°ticas y datos.\nLee detenidamente y resuelve los ejercicios. Si es necesario, incluye explicaciones adicionales para demostrar tu comprensi√≥n del problema.\nPresta atenci√≥n a los detalles de formato y presentaci√≥n al graficar.\nSe asignar√°n los puntos dependiendo de la precisi√≥n de tus respuestas y calidad de tu trabajo.\n\n\n0.1 Parte I: Funciones y C√°lculo Diferencial e Integral (3pts)\n\nGrafica la funci√≥n $ f(x) = x^3 $ en el intervalo $ [0, 5] $ (+0.5pts).\nEncuentra la primera derivada de la funci√≥n con respecto a $ x $ (de manera simb√≥lica) (+0.5pts).\nEncuentra la integral de la funci√≥n:\n\nde manera simb√≥lica (+0.5pts), y\nde manera aproximada en el intervalo [0, 3] usando el m√©todo Monte Carlo que vimos en clase (+0.5pts).\n\nAgrega las funciones integral y derivada en la misma gr√°fica, con etiquetas para cada una. Personaliza la gr√°fica seg√∫n la figura ejemplo (+0.5pts).\n¬øCu√°l es la complejidad del algoritmo que usaste para aproximar el valor de la integral? Justifica tu respuesta analizando cada instrucci√≥n y el n√∫mero de veces que se ejecuta (+0.5pts).\n\n\n\n\nexamen3e.png\n\n\n\n\n0.2 Parte II: Teorema del L√≠mite Central (3pts)\nEl teorema del l√≠mite central dice que:\n\"Bajo las condiciones adecuadas, la distribuci√≥n de la media muestral (la media de muchas muestras aleatorias tomadas de una poblaci√≥n) se aproxima a una distribuci√≥n Gaussiana a medida que el tama√±o de la muestra aumenta, independientemente de la forma de la distribuci√≥n original de la poblaci√≥n.\"\nDemuestra emp√≠ricamente que el teorema es cierto, creando una funci√≥n que haga lo siguiente:\n\nGenera una poblaci√≥n, un conjunto de $ N $ datos aleatorios en el intervalo [-1, 1) (+0.5pt).\nInicializa una lista vac√≠a lst_mean.\nRepite 500 veces:\n\nExtrae una muestra (un subconjunto) aleatoria de esta poblaci√≥n de tama√±o $ M $ (+0.5pts).\nCalcula la media de la muestra y agregala a la lista lst_mean (+0.5pts).\n\nRetorna la lista lst_mean.\nLlama a tu funci√≥n con $ N=100,000 $ y $ M=100$, y grafica el histograma de las medias muestrales guardadas en lst_mean. Deber√≠as observar que la distribuci√≥n de las medias muestrales se aproxima a una distribuci√≥n Gaussiana (+1pt).\n¬øCual es el comportamiento de la distribuci√≥n de medias muestrales cuando \\(M\\) tiende a \\(1\\)?, ¬øy cuando \\(M\\) tiende a \\(10,000\\)? (+0.5pts).\n\n\n\n0.3 Parte III: Planificaci√≥n Urbana (3pts)\nEn una ciudad en crecimiento, un equipo de urbanistas y planificadores de transporte est√° trabajando en mejorar la red vial para facilitar el desplazamiento de los ciudadanos. Se han identificado cinco barrios importantes que necesitan mejorar sus calles principales.\n\n\n\nBarrio\nConexiones\n\n\n\n\nA\nB (4 km), C (5 km), D (6 km)\n\n\nB\nA (4 km), C (3.5 km), E (5.5 km)\n\n\nC\nA (5 km), B (3.5 km), D (4.5 km), E (6.5 km), F (7 km)\n\n\nD\nA (6 km), C (4.5 km), E (3.5 km)\n\n\nE\nB (5.5 km), C (6.5 km), D (3.5 km), F (4.5 km)\n\n\nF\nC (7 km), E (4.5 km)\n\n\n\n\nConstruye el grafo que representa a los barrios y las calles que los conectan (+1pt)\nCalcula el √°rbol de expansi√≥n m√≠nima para optimizar la conectividad entre los barrios (+0.5pt).\nImprime la distancia total de las calles principales que se deben mejorar (+0.5pts).\nVisualiza (ya sea con matplotlib o con un dibujo a mano) el √°rbol de calles a mejorar (+1pt)."
  },
  {
    "objectID": "clases2025/Examen3G.html",
    "href": "clases2025/Examen3G.html",
    "title": "Examen Te√≥rico",
    "section": "",
    "text": "Instrucciones Generales:\nRESPONDE:\n1. Si un algoritmo tiene complejidad O(n^2) y otro tiene complejidad O(n log n), ¬øcu√°l algoritmo es m√°s r√°pido?\n2. Verdadero o Falso: Un grafo no dirigido es aquel en el que todas las aristas tienen una direcci√≥n definida. ______\n3. ¬øCu√°l es la diferencia entre una variable simb√≥lica y una variable num√©rica en Python?\n4. Verdadero o Falso: Un algoritmo Montecarlo siempre produce el mismo resultado. ______\n5. ¬øQu√© hace la funci√≥n expand() en SymPy?\n6. Verdadero o Falso: La funci√≥n random.shuffle() de la biblioteca random se utiliza para seleccionar aleatoriamente un elemento de una lista. ______\n7. ¬øQu√© tipo de gr√°fico se puede crear con la funci√≥n plt.plot() en matplotlib?\n8. Verdadero o Falso: En matplotlib, plt.scatter() se utiliza para graficar un histograma. ______\n9. ¬øQu√© es un grafo ponderado?\n10. Verdadero o Falso: Si un algoritmo tiene complejidad O(n^2) y otro tiene complejidad O(n log n), el algoritmo con complejidad O(n log n) es m√°s r√°pido. ________________\n11. ¬øCu√°l es la diferencia entre un algoritmo probabil√≠stico y un algoritmo determinista?\n12. Verdadero o Falso: random.randint(a, b) genera un n√∫mero aleatorio en el rango [a, b], es decir incluyendo a b. ________________"
  },
  {
    "objectID": "clases2025/Examen3G.html#examen-pr√°ctico-3",
    "href": "clases2025/Examen3G.html#examen-pr√°ctico-3",
    "title": "Examen Te√≥rico",
    "section": "1 Examen Pr√°ctico 3",
    "text": "1 Examen Pr√°ctico 3\nInstrucciones Generales:\n\nEste examen consta de tres partes, cada una con varios ejercicios relacionados con la programaci√≥n aplicada.\nLee detenidamente y resuelve los ejercicios. Si es necesario, incluye explicaciones adicionales para demostrar tu comprensi√≥n del problema.\nPresta atenci√≥n a los detalles de formato y presentaci√≥n al graficar.\nSe asignar√°n los puntos dependiendo de la precisi√≥n de tus respuestas y calidad de tu trabajo.\n\n\n1.1 Parte I: Expresiones simb√≥licas y gr√°ficas (2pts)\n\n\n\nUtiliza SymPy para definir dos expresiones simb√≥licas en funci√≥n de un par√°metro $ t $ (0.5pts).\n\n$(4t) (6t + 1) $\n$ (4t) (6t + 1) $.\n\nConvierte estas expresiones en funciones f_1 y f_2 para evaluar num√©ricamente (0.5pts).\nCrea un conjunto de 100 valores para $ t $ en el rango de $ 0 $ a $ 2$ y eval√∫a las funciones f_1 y f_2 en ese rango (0.5pts).\nGrafica las funciones f_1 y f_2 en el mismo sistema de coordenadas utilizando matplotlib (las valores de f_1 en el eje de las x, y los valores de f_2 en el eje de las y) (0.5pts).\n\n(Aseg√∫rate de etiquetar adecuadamente los ejes y las funciones en tu gr√°fica, como se muestra en el ejemplo.)\n\n&lt;div style=\"width: 5%;\"&gt;\n&lt;/div&gt;\n\n&lt;img src=\"imgs/examen3_2.png\" alt=\"Grafica\" style=\"width:100%; margin-left:auto; margin-right:auto;\"&gt;\n  \n\n\n\n\n1.2 Parte II: Estimaci√≥n de \\(\\pi\\) (2pts)\nSupongamos que deseamos estimar el valor de \\(\\pi\\) utilizando el m√©todo de Monte Carlo.\nSupongamos que deseamos estimar el valor de \\(\\pi\\) utilizando el m√©todo de Monte Carlo. Escribe una funci√≥n monte_carlo_pi(n) que:\n\nGenere n puntos aleatorios en el cuadrado de lado 1 con v√©rtices en \\((0,0)\\), \\((1,0)\\), \\((1,1)\\) y \\((0,1)\\) (+0.5pts).\nDetermine cu√°ntos de estos puntos caen dentro del c√≠rculo unitario centrado en \\((0,0)\\). Es decir, calculamos \\(x^2 + y^2\\) para cada punto \\((x, y)\\) generado y contamos cu√°ntos de estos valores son menores o iguales a 1 (+0.5pts).\nEstime el valor de \\(\\pi\\) usando la f√≥rmula \\(\\pi \\approx \\frac{4 \\cdot P}{n}\\), donde \\(P\\) es el n√∫mero de puntos dentro del c√≠rculo y \\(n\\) es el n√∫mero total de puntos (+0.5pts).\nEjecuta tu funci√≥n con un valor de n suficientemente grande (por ejemplo, \\(10^6\\)) y muestra la estimaci√≥n de \\(\\pi\\) (+0.5pts).\n\n\n\n1.3 Parte III: Gesti√≥n de Redes Sociales (2pts)\nSupongamos que est√°s dise√±ando un sistema de recomendaci√≥n de amigos para una red social. Para ello, deseas utilizar un grafo donde los nodos representan a los usuarios y las aristas representan la amistad entre ellos. Usa el c√≥digo de grafos desarrollado en clases para lo siguiente.\n\nConstruye un grafo que represente la red social de un grupo de 5 usuarios (1pt):\n\nA -- B\n|  / | \\\nC -- D -- E\n|       \nF ----- G\n\nUsa el algoritmo bfs para imprimir el n√∫mero m√≠nimo de pasos necesarios para ir de un usuario a otro, para cada par de usuarios en la red social. (+1pt)."
  },
  {
    "objectID": "clases2025/Examen2doParcial_E.html",
    "href": "clases2025/Examen2doParcial_E.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\n\n\n\n\n\n\nEste examen tiene una duraci√≥n de 60 minutos.\nCompleta los siguientes ejercicios utilizando los conceptos de Programaci√≥n Orientada a Objetos, vistos en clase.\nDeber√°s usar un entorno de desarrollo como Spyder, VSCode o PyCharm para escribir tu c√≥digo.\nNo se permite el uso de librer√≠as externas distintas a las abordadas en clase.\nEl uso de herramientas externas en Internet est√° estrictamente prohibido.\nLee cuidadosamente las instrucciones de cada tarea antes de comenzar a escribir c√≥digo. Si tienes alguna duda, no dudes en preguntar a la profesora.\nRevisa tu c√≥digo cuidadosamente antes de entregarlo.En caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° dependiendo de la gravedad del error.\nGuarda tu c√≥digo en un archivo con el nombre PA2_D_Examen1_NombreApellido.py. No se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc."
  },
  {
    "objectID": "clases2025/Examen2doParcial_E.html#segundo-examen-parcial",
    "href": "clases2025/Examen2doParcial_E.html#segundo-examen-parcial",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\n\n\n\n\n\n\nEste examen tiene una duraci√≥n de 60 minutos.\nCompleta los siguientes ejercicios utilizando los conceptos de Programaci√≥n Orientada a Objetos, vistos en clase.\nDeber√°s usar un entorno de desarrollo como Spyder, VSCode o PyCharm para escribir tu c√≥digo.\nNo se permite el uso de librer√≠as externas distintas a las abordadas en clase.\nEl uso de herramientas externas en Internet est√° estrictamente prohibido.\nLee cuidadosamente las instrucciones de cada tarea antes de comenzar a escribir c√≥digo. Si tienes alguna duda, no dudes en preguntar a la profesora.\nRevisa tu c√≥digo cuidadosamente antes de entregarlo.En caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° dependiendo de la gravedad del error.\nGuarda tu c√≥digo en un archivo con el nombre PA2_D_Examen1_NombreApellido.py. No se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc."
  },
  {
    "objectID": "clases2025/Examen2doParcial_E.html#mediciones",
    "href": "clases2025/Examen2doParcial_E.html#mediciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 1. Mediciones",
    "text": "2 1. Mediciones\nEn una estaci√≥n meteorol√≥gica, se registran mediciones de 6 diferentes sensores a lo largo del tiempo. Los datos se almacenan en un archivo llamado mediciones_sensores.txt, siempre en el mismo orden. El archivo tiene un total de 240 mediciones. Programa una funci√≥n llamada procesar_mediciones que reciba como par√°metro el nombre del archivo de mediciones y realice lo siguiente:\n\nLeer los datos desde el archivo y almacenarlos en un arreglo (1pt).\nRedimensionar el arreglo para que tenga la forma de una matriz con 6 columnas (1pt).\nConservar solamente las mediciones de los sensores 2 a 5 (columnas 1 a 4 en la matriz) (1pt).\nAplicar un muestreo de la se√±al para quedarte con cada 5 mediciones (cada 5 filas de la matriz) (1pt).\nGuardar el resultado en un archivo de texto con el nombre mediciones_filtro.txt (1pt).\n\nPrueba tu funci√≥n leyendo los datos del archivo mediciones_sensores.txt desde tu programa, el resultado esperado es:\n[[18.44 18.14 16.97 27.45]\n [22.44 19.14 32.97 23.45]\n [33.44 26.14 24.97 33.45]\n [22.44 24.14 32.97 24.45]\n [29.44 14.14 17.97 27.45]\n [31.44 28.14 29.97 31.45]\n [18.44 33.14 12.97 24.45]\n [16.44 26.14 29.97 27.45]]"
  },
  {
    "objectID": "clases2025/Examen2doParcial_E.html#ecuaciones-cuadr√°ticas",
    "href": "clases2025/Examen2doParcial_E.html#ecuaciones-cuadr√°ticas",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 2. Ecuaciones Cuadr√°ticas",
    "text": "3 2. Ecuaciones Cuadr√°ticas\nEn la empresa en la que trabajas saben que tienes excelentes habilidades de desarrollo de software. Acaban de entrevistar a alguien para el puesto de programador y te han pedido que revises el c√≥digo que el candidato al puesto escribi√≥ para resolver una ecuaci√≥n cuadr√°tica.\nLas ra√≠ces de una ecuaci√≥n cuadr√°tica se pueden encontrar utilizando la f√≥rmula cuadr√°tica:\n\\[ x = \\frac{{-b \\pm \\sqrt{{b^2 - 4ac}}}}{{2a}} \\]\nEl c√≥digo se encuentra en el archivo encontrar_raices.py.\nEn el mismo archivo, verifica el funcionamiento del c√≥digo para las siguientes ecuaciones:\n\n\\(2x^2 - 5x + 2 = 0\\)\n\\(x^2 - 4x + 4 = 0\\)\n\\(3x^2 + 4x + 6 = 0\\)\n\n\n¬øEn cual de los casos el c√≥digo falla y por qu√©? Justifica tu respuesta en un documento donde pongas el paso a paso de la t√©cnica de depuraci√≥n que hayas decidido seguir (1pt).\nCrea una excepci√≥n personalizada para el caso en que no se puede resolver la ecuaci√≥n cuadr√°tica (1pt).\nCorrige el c√≥digo de tal modo que el c√°lculo de raices se encuentre dentro de una funci√≥n y lance la excepci√≥n personalizada en el caso de que la ecuaci√≥n cuadr√°tica no se pueda resolver (1pt).\nVuelve a probar el c√≥digo con el caso en el falla pero agrega un bloque try-except seg√∫n sea necesario para que no se interrumpa la ejecuci√≥n del programa de forma abrupta (1pt).\nDado que se espera que la empresa entreviste a m√°s candidatos y no deseas estar revisando el c√≥digo de manera manual, crea un archivo de pruebas unitarias para verificar el c√≥digo para los casos siguientes (1pt):\n\nCuando las ra√≠ces de la ecuaci√≥n son reales y distintas.\nCuando las ra√≠ces de la ecuaci√≥n son reales e id√©nticas.\nCuando las ra√≠ces de la ecuaci√≥n son imaginarias."
  },
  {
    "objectID": "clases2025/ejercicio_caras.html",
    "href": "clases2025/ejercicio_caras.html",
    "title": "Ejercicio: Clases y objetos",
    "section": "",
    "text": "Este ejercicio tiene como objetivo practicar el uso de clases para crear objetos.\nVamos a dibujar ‚Äúcaras‚Äù b√°sicas empleando figuras geom√©tricas en un lienzo compartido."
  },
  {
    "objectID": "clases2025/ejercicio_caras.html#paso-1-uso-de-objetos",
    "href": "clases2025/ejercicio_caras.html#paso-1-uso-de-objetos",
    "title": "Ejercicio: Clases y objetos",
    "section": "1 Paso 1: Uso de objetos",
    "text": "1 Paso 1: Uso de objetos\n\nEn el archivo graficar.py, hay una clase Lienzo que ser√° responsable de crear y manejar el gr√°fico compartido.\nPor ahora no nos preocuparemos como funciona, simplemente la utilizaremos para crear un espacio de dibujo.\nNecesitamos pasarle los atributos de ancho y alto, o dejar que tome los valores predeterminados."
  },
  {
    "objectID": "clases2025/ejercicio_caras.html#paso-2-crear-la-clase-cara",
    "href": "clases2025/ejercicio_caras.html#paso-2-crear-la-clase-cara",
    "title": "Ejercicio: Clases y objetos",
    "section": "2 Paso 2: Crear la clase Cara",
    "text": "2 Paso 2: Crear la clase Cara\nLa clase Cara ser√° el modelo para dibujar caras. Tendr√° atributos como:\n\nposici√≥n: las coordenadas (x, y) del centro de la cara.\ntama√±o: el di√°metro del c√≠rculo que representa la cabeza.\ncolor: el color de la cara.\ntama√±o de los ojos: el tama√±o relativo de los ojos.\n\nY un m√©todo para: - Dibujar la cara en el lienzo proporcionado.\n\nclass Cara:\n    def __init__(self, x, y, tama√±o=100, color='yellow', tama√±o_ojos=0.05):\n        self.x = x\n        self.y = y\n        self.tama√±o = tama√±o\n        self.color = color\n        self.tama√±o_ojos = tama√±o_ojos\n\n    def dibujar(self, ax):\n        # Dibujar la cabeza\n        cabeza = plt.Circle((self.x, self.y), self.tama√±o / 2, color=self.color, ec='black')\n        ax.add_patch(cabeza)\n\n        # Dibujar los ojos\n        ojo_izquierdo = plt.Circle(\n            (self.x - self.tama√±o * 0.2, self.y + self.tama√±o * 0.1),\n            self.tama√±o * self.tama√±o_ojos,\n            color='black'\n        )\n        ojo_derecho = plt.Circle(\n            (self.x + self.tama√±o * 0.2, self.y + self.tama√±o * 0.1),\n            self.tama√±o * self.tama√±o_ojos,\n            color='black'\n        )\n        ax.add_patch(ojo_izquierdo)\n        ax.add_patch(ojo_derecho)"
  },
  {
    "objectID": "clases2025/ejercicio_caras.html#paso-3-dibujar-varias-caras",
    "href": "clases2025/ejercicio_caras.html#paso-3-dibujar-varias-caras",
    "title": "Ejercicio: Clases y objetos",
    "section": "3 Paso 3: Dibujar varias caras",
    "text": "3 Paso 3: Dibujar varias caras\n\nAhora usaremos instancias de la clase Cara para dibujar m√∫ltiples caras en el mismo gr√°fico.\n\n\nfrom graficar import Lienzo\nimport matplotlib.pyplot as plt\n\n# Crear el lienzo\nespacio = Lienzo(ancho=800, alto=600)\n\n# Crear y dibujar varias caras\ncara1 = Cara(0, 0, tama√±o=120, color='blue', tama√±o_ojos=0.07)\ncara1.dibujar(espacio.ax)\n\ncara2 = Cara(-300, -100, tama√±o=100, color='yellow', tama√±o_ojos=0.08)\ncara2.dibujar(espacio.ax)\n\ncara3 = Cara(150, 100, tama√±o=80, color='red', tama√±o_ojos=0.06)\ncara3.dibujar(espacio.ax)\n\n# Mostrar el lienzo\nespacio.mostrar()\n\n\n\n\n\n\n\n\n\n3.1 Actividad\n\nEjecuta el c√≥digo anterior: Observa c√≥mo se crean y dibujan las caras en un solo gr√°fico.\nModifica los par√°metros al crear nuevas caras: Cambia el color, el tama√±o y el tama√±o de los ojos.\nA√±ade m√°s atributos: color de ojos y la forma de la boca (feliz, triste).\nFinalmente, divide las partes de la cara en clases separadas. Crea clases para Ojos y Boca, y √∫salas en la clase Cara."
  },
  {
    "objectID": "clases2025/ejercicio_caras.html#anexo-funciones-de-matplotlib-para-dibujar",
    "href": "clases2025/ejercicio_caras.html#anexo-funciones-de-matplotlib-para-dibujar",
    "title": "Ejercicio: Clases y objetos",
    "section": "4 Anexo: Funciones de matplotlib para dibujar",
    "text": "4 Anexo: Funciones de matplotlib para dibujar\n\n4.1 1. plt.Circle(): Para dibujar c√≠rculos\nLa funci√≥n plt.Circle() se usa para crear c√≠rculos. Se puede personalizar el color, el borde, el tama√±o y la posici√≥n del c√≠rculo.\n\n4.1.1 Sintaxis:\ncircle = plt.Circle((x, y), radio, color='color', ec='color_borde', lw=anchoborde)\n\n(x, y): Coordenadas del centro del c√≠rculo.\nradio: Radio del c√≠rculo.\ncolor: Color de relleno del c√≠rculo (por ejemplo, 'yellow').\nec: Color del borde del c√≠rculo (por ejemplo, 'black').\nlw: Grosor del borde del c√≠rculo.\n\n\n\n4.1.2 Ejemplo:\n# Dibujar un c√≠rculo con centro en (0, 0) y radio 100\ncircle = plt.Circle((0, 0), 100, color='yellow', ec='black', lw=3)\nax.add_patch(circle)  # A√±adirlo al gr√°fico\n\n\n\n4.2 2. plt.Arc(): Para dibujar arcos\nLa funci√≥n plt.Arc() permite dibujar un arco, lo que es muy √∫til para crear bocas con forma de semic√≠rculo (hacia arriba o hacia abajo). Puedes definir el √°ngulo de inicio y final del arco.\n\n4.2.1 Sintaxis:\narc = plt.Arc((x, y), width, height, angle=0, theta1=0, theta2=180, color='color', lw=anchoborde)\n\n(x, y): Coordenadas del centro del arco.\nwidth y height: Ancho y alto del arco. El alto controla la curvatura.\nangle: √Ångulo de rotaci√≥n del arco.\ntheta1 y theta2: √Ångulos de inicio y final del arco (en grados).\ncolor: Color del arco.\nlw: Grosor del borde del arco.\n\n\n\n4.2.2 Ejemplo:\narco = plt.Arc((0, 0), 200, 100, angle=0, theta1=0, theta2=90, color='black', lw=3)\nax.add_patch(arco)\n\n\n\n4.3 3. plt.plot(): Para dibujar l√≠neas y curvas\nLa funci√≥n plt.plot() es fundamental para dibujar l√≠neas o curvas. Si tienes varias coordenadas (x, y), puedes usarlas para crear cualquier tipo de gr√°fico, desde l√≠neas rectas hasta curvas.\n\n4.3.1 Sintaxis:\nplt.plot(x, y, color='color', lw=grosor)\n\nx: Coordenadas en el eje x.\ny: Coordenadas en el eje y.\ncolor: Color de la l√≠nea.\nlw: Grosor de la l√≠nea.\n\n\n\n4.3.2 Ejemplo para dibujar una curva:\nimport numpy as np\n\n# Crear una curva hacia arriba (boca feliz)\nt = np.linspace(0, np.pi, 100)  # Intervalo de t para crear la curva\ny = 50 * np.sin(t)  # Ecuaci√≥n de la curva\nx = np.linspace(-50, 50, 100)  # Coordenadas x\nplt.plot(x, y, color='black', lw=3)  # Dibujar la curva"
  },
  {
    "objectID": "clases2025/ejercicio04.html",
    "href": "clases2025/ejercicio04.html",
    "title": "Ejercicio 04",
    "section": "",
    "text": "Crea un mapa mental que represente de manera visual los conceptos revisados en la Clase 03: Clases, objetos, constructores, incluyendo los t√©rminos: clase, objeto, atributo, m√©todo, tipos de atributos y tipos de m√©todos. (2pts)\nA√±ade breves descripciones o ejemplos en cada rama del mapa mental para explicar cada concepto. Incluye al menos tres ejemplos espec√≠ficos de atributos y tres ejemplos de m√©todos que podr√≠an estar presentes en una clase. Elige ejemplos que NO se hayan sido discutidos anteriormente. (2pts)\nPuedes utilizar papel y l√°piz o herramientas digitales para crear tu mapa mental."
  },
  {
    "objectID": "clases2025/ejercicio04.html#parte-1-mapa-mental",
    "href": "clases2025/ejercicio04.html#parte-1-mapa-mental",
    "title": "Ejercicio 04",
    "section": "",
    "text": "Crea un mapa mental que represente de manera visual los conceptos revisados en la Clase 03: Clases, objetos, constructores, incluyendo los t√©rminos: clase, objeto, atributo, m√©todo, tipos de atributos y tipos de m√©todos. (2pts)\nA√±ade breves descripciones o ejemplos en cada rama del mapa mental para explicar cada concepto. Incluye al menos tres ejemplos espec√≠ficos de atributos y tres ejemplos de m√©todos que podr√≠an estar presentes en una clase. Elige ejemplos que NO se hayan sido discutidos anteriormente. (2pts)\nPuedes utilizar papel y l√°piz o herramientas digitales para crear tu mapa mental."
  },
  {
    "objectID": "clases2025/ejercicio04.html#parte-2-c√≥digo",
    "href": "clases2025/ejercicio04.html#parte-2-c√≥digo",
    "title": "Ejercicio 04",
    "section": "2 Parte 2: C√≥digo",
    "text": "2 Parte 2: C√≥digo\nEl prestigioso laboratorio de investigaci√≥n espacial iSTAR ha solicitado tu colaboraci√≥n para mejorar sus bibliotecas de an√°lisis num√©rico. El c√≥digo actual utilizado para gestionar vectores y matrices se ha revelado insuficiente para satisfacer las necesidades espec√≠ficas de los experimentos que iSTAR realiza para comprender magnitudes y fen√≥menos f√≠sicos en el universo.\nEn este contexto, surge la oportunidad de dise√±ar y mejorar las clases Vector y Matriz. La clase Vector se encargar√° de representar magnitudes multidimensionales de manera m√°s flexible, mientras que la clase Matriz ser√° esencial para manejar datos tabulares y realizar transformaciones matriciales.\nCaracter√≠sticas de las clases (3pts):\n\n\n\n\nClase\n\n\nAtributos\n\n\nM√©todos\n\n\n\n\n\n\nVector\n\n\n\n\nelementos: lista\n\n\ndimension: entero\n\n\ntotal_vectores: entero\n\n\n\n\n\n\ninit: Constructor de la clase\n\n\nobtener_dimensiones: Obtener dimensi√≥n del vector\n\n\ncalcular_magnitud: Calcular la magnitud del vector\n\n\nobtener_total_vectores: Obtener el total de vectores\n\n\nvector_cero: Generar un vector nulo\n\n\nsuma: Calcular la suma del vector con otro vector\n\n\nproducto_escalar: Calcular el producto escalar del vector con otro vector [BONUS]\n\n\n\n\n\n\nMatriz\n\n\n\n\nelementos: lista de listas\n\n\nfilas: entero\n\n\ncolumnas: entero\n\n\n\n\n\n\ninit: Constructor de la clase\n\n\nobtener_dimensiones: Obtener dimensiones de la matriz\n\n\nobtener_total_matrices: Obtener el total de matrices\n\n\nmatriz_identidad: Generar una matriz identidad, dada una dimensi√≥n\n\n\nsuma: Calcular la suma de la matriz con otra matriz\n\n\nmultiplicaci√≥n: Calcular la multiplicaci√≥n de una matriz con otra matriz [BONUS]\n\n\n\n\n\n\nCaracter√≠sticas adicionales (3pts):\n\nEn cada atributo, indica a trav√©s de un comentario en tu c√≥digo si se trata de un atributo de instancia o de clase.\nEn cada m√©todo, indica a trav√©s de un comentario en tu c√≥digo si se trata de un m√©todo de instancia, de clase o est√°tico.\nCrea al menos dos instancias de cada clase con diferentes valores. Realiza operaciones utilizando todos los m√©todos implementados y muestra los resultados.\nResponde:\n\n¬øC√≥mo podr√≠as mejorar la clase Vector? Explica qu√© m√©todos y atributos podr√≠as agregar/cambiar.\n¬øC√≥mo podr√≠as mejorar la clase Matriz? Explica qu√© m√©todos y atributos podr√≠as agregar/cambiar."
  },
  {
    "objectID": "clases2025/ejercicio04.html#entregables",
    "href": "clases2025/ejercicio04.html#entregables",
    "title": "Ejercicio 04",
    "section": "3 Entregables",
    "text": "3 Entregables\nSube los archivos generados en este ejercicio con el prefijo PA2_Grupo_E04NombreApellido. La parte de c√≥digo debe entregarse en un archivo con extensi√≥n .py.\nConsideraciones:\n\nNo se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc.\nEn caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° la tarea con una deducci√≥n de hasta 50pts, dependiendo de la gravedad del error.\nEn caso de que la/el estudiante utilice c√≥digo o funciones no vistas en clase, deber√° ser capaz de respaldar su c√≥digo mediante una explicaci√≥n verbal y/o escrita, en caso de que le sea requerida por la docente de la asignatura. De no cumplir con la explicaci√≥n de forma satisfactoria, se anular√° su trabajo y se pasar√° el reporte a la coordinaci√≥n de la carrera."
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#clase-13-algoritmos-probabil√≠sticos",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#clase-13-algoritmos-probabil√≠sticos",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#temario",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 Temario",
    "text": "2 Temario"
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#contenido",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Contenido",
    "text": "3 Contenido\n\n¬øQu√© es un algoritmo probabil√≠stico o aleatorio?\nBeneficios de la aleatorizaci√≥n\nTipos de algoritmos probabil√≠sticos\n\nMonte Carlo\nLas Vegas\n\nGeneraci√≥n de n√∫meros aleatorios\n\nEl m√≥dulo random\n\nEjemplo:\n\nEstimaci√≥n de una integral"
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#qu√©-son-los-algoritmos-probabil√≠sticos",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#qu√©-son-los-algoritmos-probabil√≠sticos",
    "title": "Programaci√≥n Aplicada II",
    "section": "4 ¬øQu√© son los algoritmos probabil√≠sticos?",
    "text": "4 ¬øQu√© son los algoritmos probabil√≠sticos?\n\nLos algoritmos tradicionales (llamados determin√≠sticas) se basan en reglas que garantizan un resultado espec√≠fico para cada entrada.\nLos algoritmos probabil√≠sticos son algoritmos que utilizan la aleatoriedad para realizar c√°lculos o tomar decisiones.\nEn lugar de seguir una secuencia fija de pasos, estos algoritmos incorporan elementos aleatorios (generaci√≥n de n√∫meros aleatorios) que influyen en el flujo de ejecuci√≥n del algoritmo."
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#beneficios-de-la-aleatorizaci√≥n",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#beneficios-de-la-aleatorizaci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "5 Beneficios de la aleatorizaci√≥n",
    "text": "5 Beneficios de la aleatorizaci√≥n\n\nEficiencia: Los algoritmos probabil√≠sticos pueden ser m√°s eficientes que los algoritmos determin√≠sticos para resolver problemas complejos, especialmente cuando el espacio de b√∫squeda es muy grande o el problema es NP-completo.\nRobustez: Los algoritmos probabil√≠sticos suelen ser m√°s robustos a entradas err√≥neas o incompletas, ya que la aleatoriedad puede ayudar a encontrar soluciones incluso en presencia de informaci√≥n incompleta o ruidosa.\nSimplicidad: Los algoritmos probabil√≠sticos pueden ser m√°s simples de implementar que los algoritmos determin√≠sticos para algunos problemas, ya que la aleatoriedad puede simplificar la l√≥gica del algoritmo."
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#tipos-de-algoritmos-probabil√≠sticos",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#tipos-de-algoritmos-probabil√≠sticos",
    "title": "Programaci√≥n Aplicada II",
    "section": "6 Tipos de algoritmos probabil√≠sticos",
    "text": "6 Tipos de algoritmos probabil√≠sticos\nExisten dos categor√≠as principales de algoritmos probabil√≠sticos:\nAlgoritmos de Monte Carlo:\n\nUtilizan la aleatoriedad para aproximar soluciones a problemas complejos mediante la realizaci√≥n de m√∫ltiples simulaciones aleatorias.\nLa idea es generar un conjunto de soluciones aleatorias y luego estimar la soluci√≥n real a partir de estas muestras.\n\nAlgoritmos de Las Vegas:\n\nLos algoritmos de Las Vegas siempre producen una soluci√≥n correcta, pero la probabilidad de obtener la soluci√≥n en un tiempo determinado puede ser menor del 100%.\nEstos algoritmos suelen combinar la aleatoriedad con estrategias de b√∫squeda determin√≠sticas para garantizar la exactitud de la soluci√≥n."
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#generaci√≥n-de-n√∫meros-aleatorios",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#generaci√≥n-de-n√∫meros-aleatorios",
    "title": "Programaci√≥n Aplicada II",
    "section": "7 Generaci√≥n de n√∫meros aleatorios",
    "text": "7 Generaci√≥n de n√∫meros aleatorios\n\nLa generaci√≥n de n√∫meros aleatorios es un componente fundamental de los algoritmos probabil√≠sticos.\nExisten diferentes m√©todos para generar n√∫meros aleatorios, incluyendo:\n\nGeneradores de n√∫meros aleatorios pseudoaleatorios (PRNG): Estos generadores producen una secuencia de n√∫meros que parecen aleatorios, pero en realidad se basan en un algoritmo determinista.\nGeneradores de n√∫meros aleatorios basados en hardware: Estos generadores aprovechan fen√≥menos f√≠sicos como el ruido t√©rmico o la fluctuaci√≥n cu√°ntica para generar n√∫meros aleatorios verdaderos.\n\nPython utiliza un generador PRNG para generar n√∫meros aleatorios.\nEl generador de n√∫meros pseudoaleatorios predeterminado en Python es el algoritmo Mersenne Twister, implementado en la biblioteca est√°ndar random.\nEste algoritmo es ampliamente utilizado y conocido por su buena calidad en la generaci√≥n de secuencias pseudoaleatorias.\n\nFunciones comunes de la biblioteca random:\n\nrandom(): Esta funci√≥n devuelve un n√∫mero aleatorio en el rango [0.0, 1.0). Es decir, incluye 0.0 pero excluye 1.0.\n\nNota adicional: El m√≥dulo random tambi√©n proporciona la capacidad de establecer una semilla para el generador de n√∫meros pseudoaleatorios usando la funci√≥n seed(). Establecer una semilla garantiza que la secuencia de n√∫meros generada sea la misma en ejecuciones posteriores del programa, lo que puede ser √∫til para la reproducibilidad.\n\nimport random\n# Coloca esta instrucci√≥n inmediatamente despues de importar random\nrandom.seed(0) # aqui la semilla que escogimos es cero\nprint(random.random())\n\n0.8444218515250481\n\n\n\nrandrange(): Esta funci√≥n devuelve un elemento seleccionado aleatoriamente de la secuencia generada por el rango especificado.\n\n\nprint(random.randrange(1, 10))  # Devuelve un n√∫mero aleatorio entre 1 y 9.\n\n7\n\n\n\nrandint(): Esta funci√≥n devuelve un n√∫mero entero aleatorio dentro de un rango especificado, incluyendo los l√≠mites.\n\n\nimport random\nprint(random.randint(1, 10))  # Devuelve un n√∫mero aleatorio entre 1 y 10 (inclusivo).\n\n1\n\n\n\nchoice(): Esta funci√≥n devuelve un elemento aleatorio de una secuencia no vac√≠a.\n\n\nfrutas = ['manzana', 'naranja', 'fresa']\nprint(random.choice(frutas))  # Devuelve un elemento aleatorio de la lista.\n\nnaranja\n\n\n\nshuffle(): Esta funci√≥n mezcla una secuencia en su lugar, de forma aleatoria.\n\n\nalumnos = ['Alejandro', 'Braulio', 'Christopher', 'Sofia', 'Ana']\nrandom.shuffle(alumnos)\nprint(alumnos)  # La lista se mezcla de forma aleatoria.\n\n['Alejandro', 'Christopher', 'Braulio', 'Sofia', 'Ana']\n\n\n\nsample(): Esta funci√≥n devuelve una muestra aleatoria de elementos √∫nicos de una secuencia.\n\n\nalumnos = ['Alejandro', 'Braulio', 'Christopher', 'Sofia', 'Ana']\nprint(random.sample(alumnos, 3))  # Devuelve una lista de 3 elementos √∫nicos seleccionados aleatoriamente.\n\n['Sofia', 'Christopher', 'Ana']\n\n\n\n7.1 Ejercicio (Parte 1)\n\nResponde: ¬øEn que ejercicios y/o tareas anteriores hemos utilizado funciones de generaci√≥n de n√∫meros aleatorios y para qu√© las utilizamos?\nUsando las funciones anteriores, simula el lanzamiento de una moneda (cara o cruz) un n√∫mero determinado de veces y cuenta la cantidad de veces que aparece cara y cruz.\nConstruye una funci√≥n que genere una contrase√±a aleatoria de longitud n, donde cada car√°cter de la contrase√±a sea una letra min√∫scula o un d√≠gito."
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#ejemplos",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#ejemplos",
    "title": "Programaci√≥n Aplicada II",
    "section": "8 Ejemplos",
    "text": "8 Ejemplos\n\n8.1 Estimaci√≥n de una integral\n\nConsideremos la integral definida de una funci√≥n \\(f(x)\\) entre \\(a\\) y \\(b\\).\nUn algoritmo de Monte Carlo puede aproximar la integral mediante la siguiente estrategia:\n\nCalcular el √°rea total del rect√°ngulo \\([a, b] \\times [\\text{f_min}, \\text{f_max}]\\).\nGenerar N puntos aleatorios \\((x_1, y_1), (x_2, y_2), ..., (x_N, y_N)\\) dentro del rect√°ngulo \\([a, b] \\times [\\text{f_min}, \\text{f_max})]\\).\nCalcular el n√∫mero de puntos que caen debajo de la curva $ f(x)$ para los \\(N\\) puntos aleatorios generados.\nLuego, la estimaci√≥n de la integral es \\((\\text{puntos debajo de la curva} / N) \\times (\\text{√°rea total del rect√°ngulo})\\), donde el √°rea total del rect√°ngulo es $ (b - a) f((a, b)) $.\n\n\n\n\n8.2 Ejercicio (Parte 2)\n\nImplementa el algoritmo Montecarlo\nUsa tu implementaci√≥n para resolver las siguientes integrales:\n\n$ _{-1}^2 x^2 dx$\n$ _0^1 e{-x2} dx$"
  },
  {
    "objectID": "clases2025/clase13_algoritmos-probabilisticos.html#soluciones",
    "href": "clases2025/clase13_algoritmos-probabilisticos.html#soluciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "9 Soluciones",
    "text": "9 Soluciones\n\n9.1 Parte 1\n\ndef lanzamiento_moneda(numero_lanzamientos):\n    caras = 0\n    cruz = 0\n    for _ in range(numero_lanzamientos):\n        resultado = random.randint(0, 1)\n        if resultado == 1: # cara\n            caras += 1\n        else: # cruz\n            cruz += 1\n    return caras, cruz\n\nnumero_lanzamientos = 1000\ncaras, cruz = lanzamiento_moneda(numero_lanzamientos)\nprint(f\"Despu√©s de {numero_lanzamientos} lanzamientos:\")\nprint(f\"N√∫mero de caras: {caras}\")\nprint(f\"N√∫mero de cruces: {cruz}\")\n\nDespu√©s de 1000 lanzamientos:\nN√∫mero de caras: 493\nN√∫mero de cruces: 507\n\n\n\nimport random\nimport string\n\ndef generar_contrase√±a(n):\n    caracteres = 'abcdefghijklmn√±opqrstuvwxyz0123456789'\n    contrase√±a = ''\n    for i in range(n):\n        contrase√±a +=random.choice(caracteres)\n    return contrase√±a\n\nn = 10\ncontrase√±a = generar_contrase√±a(n)\nprint(f\"Contrase√±a generada: {contrase√±a}\")\n\nContrase√±a generada: rrt4y0kaj9\n\n\n\n\n9.2 Parte 2\n\nimport numpy as np\nf1 = lambda x:x**2\nf2 = lambda x:np.exp(-x**2)\n\ndef integral_montecarlo(funcion, xmin, xmax, fmin, fmax, N):\n    area_rectangulo = (xmax-xmin)*(fmax-fmin)\n    puntos_bajo_f = 0\n    for i in range(N):\n        x_rand = random.random()*(xmax-xmin)+xmin\n        y_rand = random.random()*(fmax-fmin)+fmin\n        if y_rand&lt;funcion(x_rand):\n            puntos_bajo_f+=1\n    return puntos_bajo_f/N*area_rectangulo\n\narea1 = integral_montecarlo(f1, -1, 2, 0, 4, 1000000)\narea2 = integral_montecarlo(f2, 0, 1, 0, 1, 1000000)\nprint(area1)\nprint(area2)\n\n3.0015840000000003\n0.746455"
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html",
    "href": "clases2025/clase11_complejidad-computacional.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#clase-11-complejidad-computacional",
    "href": "clases2025/clase11_complejidad-computacional.html#clase-11-complejidad-computacional",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#temario",
    "href": "clases2025/clase11_complejidad-computacional.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.2 Temario",
    "text": "0.2 Temario"
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#para-qu√©-queremos-programasalgoritmos-eficientes",
    "href": "clases2025/clase11_complejidad-computacional.html#para-qu√©-queremos-programasalgoritmos-eficientes",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.1 ¬øPara qu√© queremos programas/algoritmos eficientes?",
    "text": "1.1 ¬øPara qu√© queremos programas/algoritmos eficientes?\n\nImplementar algoritmos ineficientes puede hacer que sea imposible resolver ciertas tareas, incluso con las computadoras m√°s poderosas.\nMejorar la eficiencia puede hacer que tareas que eran imposibles de realizar anteriormente se vuelvan posibles, incluso con recursos limitados.\nSi podemos cuantificar la eficiencia de un algoritmo, podemos entender y predecir su comportamiento ante situaciones nuevas."
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#c√≥mo-podemos-determinar-si-programaalgoritmo-es-eficiente",
    "href": "clases2025/clase11_complejidad-computacional.html#c√≥mo-podemos-determinar-si-programaalgoritmo-es-eficiente",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.2 ¬øC√≥mo podemos determinar si programa/algoritmo es eficiente?",
    "text": "1.2 ¬øC√≥mo podemos determinar si programa/algoritmo es eficiente?\nüí° Podr√≠amos medir el tiempo que tarda un algoritmo en ejecutarse en una computadora.\n‚ùå Pero esto depende de la velocidad y la arquitectura de la computadora\nüí° Podr√≠amos contar la cantidad de pasos que un algoritmo realiza en total.\n‚ùå Pero esto depende de la implementaci√≥n espec√≠fica del algoritmo\nLo que queremos es una forma de medir la eficiencia de un algoritmo que no dependa de la velocidad de la computadora üíª o de los detalles de implementaci√≥n\n\nPara superar esta limitaci√≥n, deber√≠amos utilizar un modelo abstracto de computadora.\nUn modelo popular es la m√°quina de Turing:\n\nel tiempo se mide en t√©rminos del n√∫mero de pasos tomados por la m√°quina de Turing.\nel espacio se mide en t√©rminos del n√∫mero de celdas (o bits) utilizadas.\n\nEn realidad, es tedioso construir la m√°quina de Turing equivalente para un algoritmo dado. En vez de eso, realizamos un an√°lisis aproximado para el propio algoritmo, bajo la suposici√≥n de que los c√°lculos que involucran tama√±os de entrada fijos toman tiempo y espacio constantes.\nNuestro objetivo es tener un an√°lisis que sea independiente de la tecnolog√≠a."
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#definici√≥n-complejidad-computacional",
    "href": "clases2025/clase11_complejidad-computacional.html#definici√≥n-complejidad-computacional",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.3 Definici√≥n: Complejidad Computacional",
    "text": "1.3 Definici√≥n: Complejidad Computacional\n\nLa complejidad computacional se refiere a la cantidad de recursos (por ejemplo, pasos de programa o bits de memoria) necesarios para resolver alg√∫n problema.\nNos interesa la complejidad computacional de un algoritmo para:\n\nsaber si un problema es o no solucionable\nsi es pr√°ctico o no resolver instancias del problema de tama√±o cada vez m√°s grande."
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#notaci√≥n-big-o-notaci√≥n-de-l√≠mite-superior",
    "href": "clases2025/clase11_complejidad-computacional.html#notaci√≥n-big-o-notaci√≥n-de-l√≠mite-superior",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.4 Notaci√≥n ‚ÄúBig-O‚Äù (Notaci√≥n de L√≠mite Superior)",
    "text": "1.4 Notaci√≥n ‚ÄúBig-O‚Äù (Notaci√≥n de L√≠mite Superior)\nFormalmente:\n\nSean \\(f, g: \\mathbb{N}^+ \\leftarrow \\mathbb{R}^{+}\\), y supongamos que \\(g(n)\\) es el tiempo de ejecuci√≥n de un algoritmo en una entrada de tama√±o \\(n\\). Denotamos el tiempo de ejecuci√≥n asint√≥tico de un algoritmo por \\(O(f(n))\\). Esto se llama notaci√≥n Big-O, lo que significa que existe alg√∫n \\(c \\in \\mathbb{R}^{+}\\) tal que para todo \\(n \\in \\mathbb{N}^{+}\\), \\(g(n) \\leq c \\dot f(n)\\), es decir, \\(c \\cdot f(n)\\) acota \\(g(n)\\) por arriba.\nEn la pr√°ctica, nos importa saber c√≥mo crece el tiempo de ejecuci√≥n de un algoritmo a medida que crece el tama√±o de su entrada.\nLa notaci√≥n Big-O, denotada como \\(O(\\cdot)\\), es una forma de describir el comportamiento asint√≥tico de una funci√≥n.\nEs decir es una forma de describir el el l√≠mite superior del crecimiento de una funci√≥n en relaci√≥n con otra funci√≥n.\n\nIgnora constantes multiplicativas y t√©rminos de menor orden.\nNos da una cota superior asint√≥tica del tiempo de ejecuci√≥n del algoritmo.\n\n\n¬øQu√© significa ‚Äúasint√≥ticamente‚Äù?\n\nEl t√©rmino ‚Äúasint√≥ticamente‚Äù se refiere al comportamiento de una funci√≥n a medida que se aproxima a un l√≠mite, generalmente hacia el infinito o hacia cero.\nEn el contexto de an√°lisis de complejidad computacional, nos interesa el comportamiento del algoritmo para tama√±os de entrada grandes.\n\nRecordatorio: La notaci√≥n Big-O es una manera de medir la tasa de crecimiento de una cantidad.\nEjemplos:\n\n\n\n\nUn cuadrado de lado \\(r\\) tiene un √°rea \\(O(r^2)\\):\n\n\n\nduplicar \\(r\\) incrementar√° el √°rea por un factor de 4\n\n\ntriplicar \\(r\\) incrementar√° el √°rea por un factor de 9\n\n\n\n\n\n\nUn c√≠rculo de radio \\(r\\) tiene un √°rea \\(O(r^2)\\):\n\n\n\nduplicar \\(r\\) incrementar√° el √°rea por un factor de 4\n\n\ntriplicar \\(r\\) incrementar√° el √°rea por un factor de 9\n\n\n\n\n\n\n\n\nEsto s√≥lo significa que ambas cantidades (A y A‚Äô) crecen al mismo ritmo, no que sean iguales\n\nIm√°genes de web.stanford.edu\nM√°s ejemplos:\n\n$ n = O(n) $\n$ n^2 = O(n^2) $\n$ n^2 = O(n^3) $\n$ n^2 = O(2^n) $\n$ 2^n O(n^2) $\n\n\n1.4.1 Usando la Notaci√≥n Big-O para calcular el tiempo computacional de un algoritmo\n¬øCu√°nto tiempo toma cantar la canci√≥n de los elefantes?\n\nImagen de www.cimat.mx\n\nPara medir el tiempo de ejecuci√≥n contaremos el n√∫mero de veces que se ejecuta cada instrucci√≥n. Enfoqu√©monos en las instrucciones SING √∫nicamente.\n\nLas instrucciones 3 y 4 se ejecutan UNA √öNICA VEZ cada una.\nLas instrucciones 6 y 7 se ejecutan (n-1) VECES cada una.\n\nEs decir, el tiempo de ejecuci√≥n de la funci√≥n ElephantSong es:\n\n\\[\n\\begin{eqnarray}\n& & 2(n-1)+2\\\\\n&=& 2(n-1+1)\\\\\n&=& 2n\n\\end{eqnarray}\n\\]\n\nEs decir, la complejidad computacional de esta funci√≥n es \\(O(n)\\).\n\nM√°s Ejemplos\n\n$ n + n^2 = O(n^2) $\n(Podemos elegir $ c = 2$ y se cumple que $n + n^2 2n^2 $ para todo $ n $)\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Datos\nn = np.linspace(1, 10, 100)\nparte_izq = n + n**2\nparte_der = 2 * n**2\n\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(1, 1, 1)\nax.plot(n, parte_izq, color=\"blue\", label=r'$n + n^2$')\nax.plot(n, parte_der, color=\"red\", label=r'$2n^2$')\n\nax.set_xlabel('n')\nax.set_ylabel('Funci√≥n')\nax.set_title(r'$n + n^2$ vs. $2n^2$')\nax.legend()\nax.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\nM√°s Ejemplos\n\n$ 1000n^2 + 5n + 1000 = O(n^2) $\n(Podemos elegir $ c = 2000 $ y se cumple que \\(1000n^2 + 5n + 1000 \\leq 2000n^2\\) para todo $ n $)\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Datos\nn = np.linspace(1, 10, 100)\nparte_izq = 1000*n**2 + 5*n + 1000\nparte_der = 2000*n**2\n\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(1, 1, 1)\nax.plot(n, parte_izq, color=\"blue\", label=r'$1000n^2 + 5n + 1000$')\nax.plot(n, parte_der, color=\"red\", label=r'$2000n^2$')\n\nax.set_xlabel('n')\nax.set_ylabel('Funci√≥n')\nax.set_title(r'$1000n^2 + 5n + 1000$ vs. $2000n^2$')\nax.legend()\nax.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\nNota sobre Simplificaciones de Notaci√≥n Big-O: - La notaci√≥n Big-O es una simplificaci√≥n. - No nos dice nada sobre el comportamiento exacto de una funci√≥n. - Por ejemplo, la funci√≥n $ f(n) = 2n^2 + n + 1 $ es $ O(n^2) $, pero tambi√©n es $O(n^3) $, $ O(2^n) $, $ O(n^n) $, etc. - Pero la notaci√≥n Big-O es √∫til porque captura las diferencias importantes entre los algoritmos a un alto nivel."
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#tabla-de-complejidad-computacional",
    "href": "clases2025/clase11_complejidad-computacional.html#tabla-de-complejidad-computacional",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.5 Tabla de complejidad computacional",
    "text": "1.5 Tabla de complejidad computacional\nLa siguiente tabla muestra algunas complejidades computacionales comunes:\n\n\n\n\n\n\n\n\nNotaci√≥n Big O\nNombre\nDescripci√≥n\n\n\n\n\nO(1)\nConstante\nEl tiempo de ejecuci√≥n no depende del tama√±o del input.\n\n\nO(log n)\nLogar√≠tmica\nEl tiempo de ejecuci√≥n aumenta logar√≠tmicamente con el tama√±o del input.\n\n\nO(n)\nLineal\nEl tiempo de ejecuci√≥n aumenta linealmente con el tama√±o del input.\n\n\nO(n log n)\nLineal√≠tmica\nEl tiempo de ejecuci√≥n aumenta en proporci√≥n al producto del tama√±o del input y su logaritmo.\n\n\nO(n^2)\nCuadr√°tica\nEl tiempo de ejecuci√≥n aumenta cuadr√°ticamente con el tama√±o del input.\n\n\nO(2^n)\nExponencial\nEl tiempo de ejecuci√≥n aumenta exponencialmente con el tama√±o del input.\n\n\nO(n!)\nFactorial\nEl tiempo de ejecuci√≥n aumenta factorialmente con el tama√±o del input.\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\n\n# Definir el rango de valores de entrada\nx = np.linspace(2, 11, 10)\n\n# Definir las funciones para cada complejidad\ny1 = np.ones_like(x)                   # O(1)\ny2 = np.log(x)                         # O(log n)\ny3 = x                                # O(n)\ny4 = x * np.log(x)                     # O(n log n)\ny5 = x**2                              # O(n^2)\ny6 = 2**x                              # O(2^n)\ny7 = [math.factorial(int(i)) for i in x]  # O(n!)\n\n# Crear la gr√°fica\nfig = plt.figure(figsize=(10, 6))\nax = fig.add_subplot(1, 1, 1)\nax.plot(x, y1, label='O(1)')\nax.plot(x, y2, label='O(log n)')\nax.plot(x, y3, label='O(n)')\nax.plot(x, y4, label='O(n log n)')\nax.plot(x, y5, label='O(n^2)')\nax.plot(x, y6, label='O(2^n)')\nax.plot(x, y7, label='O(n!)')\n\n# Configurar la gr√°fica\nax.set_title('Comparaci√≥n de Complejidades Computacionales')\nax.set_xlabel('N√∫mero de operaciones (n)')\nax.set_ylabel('Tiempo de Ejecuci√≥n')\nax.set_yscale('log')  # Escala logar√≠tmica en el eje y para visualizaci√≥n m√°s clara\nax.legend()\nax.grid(True)\n\n# Mostrar la gr√°fica\nplt.show()"
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#problemas-computacionales",
    "href": "clases2025/clase11_complejidad-computacional.html#problemas-computacionales",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.6 Problemas computacionales",
    "text": "1.6 Problemas computacionales\n\n1.6.1 Clasificaci√≥n seg√∫n su prop√≥sito\nLos problemas computacionales se pueden dividir dependiendo de su prop√≥sito. 1. Problemas de decisi√≥n: - Estos problemas implican tomar una decisi√≥n binaria, generalmente s√≠ o no, en respuesta a una pregunta espec√≠fica sobre los datos de entrada. - La respuesta a la pregunta es verdadera o falsa. Los problemas de decisi√≥n se pueden resolver mediante algoritmos que determinan si la respuesta es s√≠ o no. - Ejemplo: ¬øExiste un camino desde el lugar A al lugar B?\n\nProblemas de b√∫squeda:\n\nEn estos problemas, se busca encontrar uno o m√°s elementos dentro de un conjunto de datos o una estructura de datos.\nLa tarea es encontrar la ubicaci√≥n o las ubicaciones del elemento deseado.\nEjemplo: ¬øCu√°l es la ubicaci√≥n de un elemento espec√≠fico en una lista no ordenada?\n\nProblemas de optimizaci√≥n:\n\nEstos problemas implican encontrar la mejor soluci√≥n posible de entre todas las soluciones v√°lidas, de acuerdo con alg√∫n criterio de optimizaci√≥n definido.\nLa tarea es maximizar o minimizar una funci√≥n objetivo.\nEjemplo: ¬øCu√°l es la ruta m√°s corta para llegar de un punto A a un punto B?\n\nProblemas de conteo:\n\nEstos problemas implican contar el n√∫mero de objetos que satisfacen ciertas condiciones.\nLa tarea es determinar cu√°ntas soluciones existen para un problema dado.\nEjemplo: ¬øCu√°ntas permutaciones distintas se pueden hacer con un conjunto de elementos dados?\n\n\n\n\n1.6.2 Clasificaci√≥n seg√∫n su complejidad computacional\nLos problemas o tareas computacionales pueden clasificarse seg√∫n su complejidad computacional en diferentes categor√≠as:\n\nImagen de www.vice.com\n\nProblemas de complejidad P: El tiempo requerido para resolver el problema crece como una funci√≥n polin√≥mica del tama√±o de la entrada. Por ejemplo:\n\nMultiplicaci√≥n de matrices\nOrdenamiento de una lista de elementos (por ejemplo, algoritmo de ordenamiento de burbuja)\nB√∫squeda binaria en una lista ordenada\n\nProblemas de complejidad NP: Estos son problemas cuyas soluciones se pueden verificar en tiempo polin√≥mico. Sin embargo, no se conoce un algoritmo eficiente para resolver estos problemas en tiempo polin√≥mico. En otras palabras, aunque la soluci√≥n se pueda verificar en tiempo polin√≥mico, encontrar la soluci√≥n misma podr√≠a requerir un tiempo exponencial.\n\nProblema del agente viajero (TSP): Encontrar la ruta m√°s corta que visite todas las ciudades exactamente una vez y regrese al punto de partida.\nProblema de la mochila: Determinar la combinaci√≥n √≥ptima de elementos para maximizar el valor total sin exceder una capacidad dada."
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#ejercicio",
    "href": "clases2025/clase11_complejidad-computacional.html#ejercicio",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.7 Ejercicio:",
    "text": "1.7 Ejercicio:\n\nDados los siguientes fragmentos de c√≥digos, determina su complejidad computacional usando notaci√≥n Big-O:\n def ejemplo_algo(n):\n     for i in range(n):\n         print(i)\n     for j in range(n * n):\n         print(j)\ndef busqueda_lineal(lista, valor):\n    for elemento in lista:\n        if elemento == valor:\n            return True\n    return False\ndef suma_elementos(lista):\n    suma = 0\n    for elemento in lista:\n        suma += elemento\n    return suma\nConsidera las siguientes funciones y ord√©nalas de forma ascendente en t√©rminos de su complejidad computacional usando notaci√≥n Big-O:\n\n$ f(n) = 3n^2 + 2n + 1 $\n$ g(n) = n^3 + 5n^2 + 10n $\n$ h(n) = 2^n + n^4 $\n\nVerifica tu respuesta mediante una gr√°fica comparativa de las funciones anteriores en el rango \\(n=1\\) a \\(n=10\\).\nPara la funci√≥n $ f(n) = n^2 + 5n + 10 $, demuestra que $ f(n) = O(n^2) $ encontrando un valor constante $ c $ que satisfaga la definici√≥n de Big-O."
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#soluci√≥n-ejercicio-14",
    "href": "clases2025/clase11_complejidad-computacional.html#soluci√≥n-ejercicio-14",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.8 Soluci√≥n Ejercicio 14",
    "text": "1.8 Soluci√≥n Ejercicio 14\nEjercicio 1:\n\nLa funci√≥n ejemplo_algo contiene dos ciclos for. El primero itera n veces y el segundo itera n^2 veces. Por lo tanto, la complejidad total es \\(O(n + n^2) = O(n^2)\\).\nLa funci√≥n busqueda_lineal itera sobre cada elemento de la lista, por lo que su complejidad es \\(O(n)\\), donde \\(n\\) es la longitud de la lista.\nLa funci√≥n suma_elementos itera sobre cada elemento de la lista una vez, por lo que su complejidad es \\(O(n)\\), donde \\(n\\) es la longitud de la lista.\n\nEjercicio 2:\n\nLas funciones ya estaban ordenadas de manera ascendente:\n\n$ f(n) = 3n^2 + 2n + 1 $: \\(\\mathbf{O(n^2)}\\)\n$ g(n) = n^3 + 5n^2 + 10n $: \\(\\mathbf{O(n^3)}\\)\n$ h(n) = 2^n + n^4 $: \\(\\mathbf{O(2^n)}\\)\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definici√≥n de las funciones\nf = lambda n: 3 * n**2 + 2 * n + 1\ng = lambda n: n**3 + 5 * n**2 + 10 * n\nh = lambda n: 2**n + n**4\n\n# Creamos los valores en x y y\nvalores_n = np.arange(1, 11)\nvalores_f = [f(n) for n in valores_n]\nvalores_g = [g(n) for n in valores_n]\nvalores_h = [h(n) for n in valores_n]\n\n# Creamos la gr√°fica para comprobar\nfig = plt.figure(figsize=(10, 6))\nax = plt.subplot(1, 1, 1)\nax.plot(valores_n, valores_f, label=r'$f(n) = 3n^2 + 2n + 1$')\nax.plot(valores_n, valores_g, label=r'$g(n) = n^3 + 5n^2 + 10n$')\nax.plot(valores_n, valores_h, label=r'$h(n) = 2^n + n^4$')\n\nax.set_xlabel('n')\nax.set_ylabel('Valor de la funci√≥n')\nax.set_title('Comparaci√≥n de funciones')\nax.grid(True)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\nEjercicio 3:\n\nPara demostrar que \\(f(n) = O(n^2)\\), necesitamos encontrar una constante \\(c\\) tal que \\(f(n) \\leq c \\cdot n^2\\) para valores suficientemente grandes de \\(n\\).\nDado \\(f(n) = n^2 + 5n + 10\\), podemos ver que \\(f(n) \\leq n^2 + 5n^2 + 10n^2\\) para \\(n &gt; 1\\).\nPor lo tanto, \\(f(n) \\leq 16n^2\\) para \\(n &gt; 1\\), donde \\(c = 16\\).\n\n\n# Definici√≥n de las funciones\nf = lambda n: n**2 + 5 * n + 10\ng = lambda n: 16 * n**2\n\n# Creamos los valores en x y y\nvalores_n = np.arange(1, 11)\nvalores_f = [f(n) for n in valores_n]\nvalores_g = [g(n) for n in valores_n]\n\n# Creamos la gr√°fica para comprobar\nfig = plt.figure(figsize=(10, 6))\nax = plt.subplot(1, 1, 1)\nax.plot(valores_n, valores_f, label=r'$f(n) = n^2 + 5n + 10$')\nax.plot(valores_n, valores_g, label=r'$g(n) = 16n^2$')\n\nax.set_xlabel('n')\nax.set_ylabel('Valor de la funci√≥n')\nax.set_title('Comparaci√≥n de funciones')\nax.grid(True)\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "clases2025/clase11_complejidad-computacional.html#referencias-bibliogr√°ficas",
    "href": "clases2025/clase11_complejidad-computacional.html#referencias-bibliogr√°ficas",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.9 Referencias bibliogr√°ficas",
    "text": "1.9 Referencias bibliogr√°ficas\n\nEsteves, C. (2023). Introducci√≥n al An√°lisis Probabil√≠stico. Centro de Investigaci√≥n en Matem√°ticas, A.C. [PDF]. Recuperado de https://www.cimat.mx/~cesteves/cursos/pa/pdf/1_Introduccion.pdf\nTrevisan, L. (2023). Complexity Notes 02. GitHub. [PDF]. Recuperado de https://lucatrevisan.github.io/notes/complexitynotes02.pdf\nStanford University. (2018). Lecture 7 Slides: Big O Notation. Stanford University - Department of Computer Science. [PDF]. Recuperado de https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1218/lectures/07-bigo/Lecture7Slides.pdf"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#sympy-matplotlib-pandas",
    "href": "clases2025/clase10_matplotlib-pandas.html#sympy-matplotlib-pandas",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 Sympy | Matplotlib | Pandas",
    "text": "2 Sympy | Matplotlib | Pandas\n\n2.1 Primavera 2024\n\n2.1.1 Dra. Dora Alvarado\n\n27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#temario",
    "href": "clases2025/clase10_matplotlib-pandas.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Temario",
    "text": "3 Temario"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#matplotlib",
    "href": "clases2025/clase10_matplotlib-pandas.html#matplotlib",
    "title": "Programaci√≥n Aplicada II",
    "section": "4 Matplotlib",
    "text": "4 Matplotlib"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#para-que-sirve-matplotlib",
    "href": "clases2025/clase10_matplotlib-pandas.html#para-que-sirve-matplotlib",
    "title": "Programaci√≥n Aplicada II",
    "section": "5 ¬øPara que sirve Matplotlib?",
    "text": "5 ¬øPara que sirve Matplotlib?\n\nMatplotlib es una biblioteca de Python para la visualizaci√≥n de datos.\nEs una herramienta poderosa y vers√°til que permite crear una amplia variedad de gr√°ficos, desde simples diagramas de dispersi√≥n hasta complejos gr√°ficos 3D."
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#pasos-para-crear-una-figura-con-matplotlib",
    "href": "clases2025/clase10_matplotlib-pandas.html#pasos-para-crear-una-figura-con-matplotlib",
    "title": "Programaci√≥n Aplicada II",
    "section": "6 Pasos para crear una figura con Matplotlib",
    "text": "6 Pasos para crear una figura con Matplotlib\n\nImportar la biblioteca Matplotlib y el subm√≥dulo pyplot.\nCrear figura: La figura es el lienzo donde se dibujar√°n las gr√°ficas. Se puede especificar el tama√±o de la figura y otros par√°metros.\nObtener ejes: Los ejes son las √°reas donde realmente se dibujan las gr√°ficas. Una figura puede tener uno o m√°s ejes.\nDibujar sobre los ejes: Se utilizan diferentes funciones para dibujar diferentes tipos de gr√°ficas, como plt.plot() para l√≠neas, plt.scatter() para puntos, plt.bar() para barras, etc.\nA√±adir elementos extra (anotaciones, t√≠tulo): Se pueden a√±adir anotaciones, t√≠tulos, leyendas, etc. a la gr√°fica.\nRenderizar gr√°fica: Se utiliza la funci√≥n plt.show() para mostrar la gr√°fica en pantalla. Se pueden guardar las gr√°ficas en diferentes formatos como PNG, JPEG, PDF, etc.\n\n\n# Paso 0: Importar la biblioteca\nimport matplotlib.pyplot as plt\n\n# Paso 1: Crear figura\nfig = plt.figure(figsize=(8, 6))\n\n# Paso 2: Obtener ejes\nax = fig.add_subplot(1, 1, 1)  # Esto crea un solo eje en la figura\n\n# Paso 3: Dibujar sobre los ejes\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6, 8, 10]\nax.plot(x, y)\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('Eje X')\nax.set_ylabel('Eje Y')\nax.set_title('Gr√°fico de Ejemplo')\nax.grid(True)\n\n# Paso 5: Renderizar gr√°fica\nplt.show()\nplt.savefig(\"Figura_Ejemplo.png\")\n\n\n\n\n\n\n\n\n&lt;Figure size 640x480 with 0 Axes&gt;"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#tipos-de-gr√°ficos",
    "href": "clases2025/clase10_matplotlib-pandas.html#tipos-de-gr√°ficos",
    "title": "Programaci√≥n Aplicada II",
    "section": "7 Tipos de gr√°ficos",
    "text": "7 Tipos de gr√°ficos\nMatplotlib soporta una amplia variedad de tipos de gr√°ficos, incluyendo:\n\nDiagramas de dispersi√≥n: para mostrar la relaci√≥n entre dos variables.\nGr√°fica de l√≠neas: para mostrar la evoluci√≥n de una variable a lo largo del tiempo.\nGr√°fica de barras: para comparar valores entre diferentes categor√≠as.\nHistogramas: para mostrar la distribuci√≥n de una variable.\nGr√°ficos 3D: para visualizar datos en tres dimensiones.\n\nPor ejemplo:\n\n7.1 Diagrama de dispersi√≥n\n\nUn diagrama de dispersi√≥n, o scatter plot, es una visualizaci√≥n que muestra puntos en un plano cartesiano, donde cada punto representa un valor para dos variables diferentes.\nEs √∫til para identificar patrones y relaciones entre variables.\n\n\n# Datos ficticios\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\n\n# Paso 1: Crear figura\nfig = plt.figure(figsize=(8, 6))\n\n# Paso 2: Obtener ejes\nax = fig.add_subplot(1, 1, 1)\n\n# Paso 3: Dibujar sobre los ejes\nax.scatter(x, y)\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('Eje X')\nax.set_ylabel('Eje Y')\nax.set_title('Scatter Plot de Ejemplo')\nax.grid(True)\n\n# Paso 5: Renderizar gr√°fica\nplt.show()\n\n\n\n\n\n\n\n\n\n\n7.2 Gr√°fica de l√≠neas\n\nUna gr√°fica de l√≠neas, o line plot, es una visualizaci√≥n que muestra puntos conectados por l√≠neas rectas.\nEs √∫til para visualizar tendencias a lo largo del tiempo o secuencias de datos.\n\n\n# Paso 1: Crear figura\nfig = plt.figure(figsize=(8, 6))\n\n# Paso 2: Obtener ejes\nax = fig.add_subplot(1, 1, 1)\n\n# Paso 3: Dibujar sobre los ejes\nax.plot(x, y)\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('Eje X')\nax.set_ylabel('Eje Y')\nax.set_title('Line Plot de Ejemplo')\nax.grid(True)\n\n# Paso 5: Renderizar gr√°fica\nplt.show()\n\n\n\n\n\n\n\n\n\n\n7.3 Gr√°fica de barras\n\nUna gr√°fica de barras, o bar plot, es una visualizaci√≥n que muestra barras rectangulares, donde la longitud de cada barra es proporcional al valor que representa.\nEs √∫til para comparar diferentes categor√≠as de datos.\n\n\n# Datos ficticios\ncategorias = ['A', 'B', 'C', 'D']\nvalores = [10, 20, 15, 25]\n\n# Paso 1: Crear figura\nfig = plt.figure(figsize=(8, 6))\n\n# Paso 2: Obtener ejes\nax = fig.add_subplot(1, 1, 1)\n\n# Paso 3: Dibujar sobre los ejes\nax.bar(categorias, valores)\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('Categor√≠as')\nax.set_ylabel('Valores')\nax.set_title('Bar Plot de Ejemplo')\n\n# Paso 5: Renderizar gr√°fica\nplt.show()"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#histograma",
    "href": "clases2025/clase10_matplotlib-pandas.html#histograma",
    "title": "Programaci√≥n Aplicada II",
    "section": "8 Histograma",
    "text": "8 Histograma\n\nUn histograma es una visualizaci√≥n que muestra la distribuci√≥n de datos num√©ricos dividiendo el rango en intervalos y mostrando la frecuencia de cada intervalo.\nEs √∫til para comprender la distribuci√≥n de los datos.\n\n\n# Datos ficticios\ndatos = [1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8, 8, 9, 9]\n\n# Paso 1: Crear figura\nfig = plt.figure(figsize=(8, 6))\n\n# Paso 2: Obtener ejes\nax = fig.add_subplot(1, 1, 1)\n\n# Paso 3: Dibujar sobre los ejes\nax.hist(datos, bins=5, edgecolor='white')\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('Valores')\nax.set_ylabel('Frecuencia')\nax.set_title('Histograma de Ejemplo')\n\n# Paso 5: Renderizar gr√°fica\nplt.show()\n\n\n\n\n\n\n\n\nNOTA: - Estos son solo algunos ejemplos b√°sicos de visualizaciones que se pueden crear con Matplotlib. - La biblioteca ofrece una amplia gama de gr√°ficos para adaptarse a diferentes necesidades de visualizaci√≥n de datos (ver matplotlib.org).\nPor ejemplo, Matplotlib tambi√©n permite crear gr√°ficos 3D y otras visualizaciones avanzadas como mapas de calor, gr√°ficos de contorno y gr√°ficos de superficie.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Paso 1: Crear figura y obtener ejes\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\n\n# Generar datos\nx = np.linspace(-10, 10, 100)\ny = np.linspace(-10, 10, 100)\nx, y = np.meshgrid(x, y)\nz = x**2 + y**2\n\n# Paso 3: Dibujar sobre los ejes\nax.plot_surface(x, y, z)\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_zlabel('Z')\n\n# Paso 5: Renderizar gr√°fica\nplt.show()"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#personalizaci√≥n-de-gr√°ficas",
    "href": "clases2025/clase10_matplotlib-pandas.html#personalizaci√≥n-de-gr√°ficas",
    "title": "Programaci√≥n Aplicada II",
    "section": "9 Personalizaci√≥n de gr√°ficas",
    "text": "9 Personalizaci√≥n de gr√°ficas\nLas gr√°ficas de Matplotlib se pueden personalizar en gran medida, por ejemplo:\n\n9.1 Colores y estilos\nPodemos especificar colores y estilos de l√≠nea para resaltar diferentes partes de las gr√°ficas.\n\nimport numpy as np\n\n# Datos ficticios\nx = np.linspace(0, 10, 100) # Crear una secuencia de 100 valores num√©ricos distribuidos uniformemente entre 0 y 10\ny1 = np.sin(x) # Evaluamos los valores anteriores x con la funci√≥n sin(x)\ny2 = np.cos(x) # Evaluamos los valores anteriores x con la funci√≥n cos(x)\n\n\n# Paso 1: Crear figura\nfig = plt.figure(figsize=(8, 6))\n\n# Paso 2: Obtener ejes\nax = fig.add_subplot(1, 1, 1)\n\n# Paso 3: Dibujar sobre los ejes\nax.plot(x, y1, linestyle='-', color='blue', label='sin(x)')\nax.plot(x, y2, linestyle='--', color='red', label='cos(x)')\n\n# Paso 4: A√±adir elementos extra\nax.set_xlabel('X')\nax.set_ylabel('Y')\nax.set_title('Ejemplo de Personalizaci√≥n')\nax.grid(True)\nplt.legend() # Agregar leyenda\n\n# Paso 5: Renderizar gr√°fica\nplt.show()\n\n\n\n\n\n\n\n\n\n\n9.2 Etiquetas y t√≠tulos\n\nEs importante etiquetar los ejes y proporcionar un t√≠tulo descriptivo para las gr√°ficas.\n\n\n# Datos ficticios\nx = np.linspace(0, 10, 100)\ny = np.exp(x)\n\n# Crear figura\nfig = plt.figure()\n\n# Obtener ejes\nax = fig.add_subplot(1, 1, 1)\n\n# Dibujar sobre los ejes\nax.plot(x, y)\n\n# Personalizar etiquetas de los ejes\nax.set_xlabel(\"Eje X\", fontsize=14, fontweight=\"bold\", color=\"red\")\nax.set_ylabel(\"Eje Y\", fontsize=12, color=\"blue\")\n\n# Cambiar el formato de las etiquetas del eje Y\nax.set_xticks(np.arange(0, 12, 2))\n\n# Personalizar el t√≠tulo del gr√°fico\nax.set_title(\"Personalizaci√≥n de etiquetas y t√≠tulos\", \n          fontsize=16, fontfamily=\"Arial\", color=\"green\", loc=\"left\")\n\n# Mostrar la gr√°fica\nplt.show()\n\n\n\n\n\n\n\n\n\n\n9.3 Subplots y figuras m√∫ltiples\n\nEn Matplotlib es posible crear m√∫ltiples subplots (subgr√°ficas) en una sola figura para comparar diferentes conjuntos de datos.\nExisten varias maneras de hacer esta divisi√≥n en subfiguras, aqu√≠ se muestra una manera:\n\n\n# Datos ficticios\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\n\n# Pasos 1 y 2: Crear figura y obtener ejes\nfig = plt.figure(figsize=(8, 6))\n\n# add_subplot(n, m, index) a√±ade una subfigura en una cuadricula de n filas x m columnas\n# el parametro index indica la posici√≥n en la que se agrega la subfigura en esa cuadr√≠cula\n\nax1 = fig.add_subplot(2, 1, 1) \nax2 = fig.add_subplot(2, 1, 2)\n\n\n# Paso 3: Dibujar sobre los ejes\nax1.plot(x, y1)\nax2.plot(x, y2)\n\n# Paso 4: A√±adir elementos extra\nax1.grid(True)\nax1.set_title('Sin(x)')\nax1.set_xlabel('Eje X')\nax1.set_ylabel('Eje Y')\n\nax2.grid(True)\nax2.set_title('Cos(x)')\nax2.set_xlabel('X')\nax2.set_ylabel('Eje Y')\n\n# Paso 5: Renderizar gr√°fica\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#integraci√≥n-con-otras-bibliotecas",
    "href": "clases2025/clase10_matplotlib-pandas.html#integraci√≥n-con-otras-bibliotecas",
    "title": "Programaci√≥n Aplicada II",
    "section": "10 Integraci√≥n con otras bibliotecas",
    "text": "10 Integraci√≥n con otras bibliotecas\n\nMatplotlib se utiliza en una amplia gama de aplicaciones del mundo real, como visualizaci√≥n de datos cient√≠ficos, an√°lisis financiero, representaci√≥n de datos geoespaciales, entre otros.\nA continuaci√≥n algunos ejemplos.\n\n\n10.1 Pandas\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n#leemos datos de las elecciones en Reino Unido de 1966 a 2019\ndf = pd.read_csv('https://anvil.works/blog/img/plotting-in-python/uk-election-results.csv') \n\ndatos = np.loadtxt(\"uk-election-results.csv\", delimiter=',', skiprows=1)\nprint(datos)\n\nx = datos[:, 0]\ny1 = datos[:, 1]\ny2= datos[:, 2]\ny3 = datos[:, 3]\ny4 = datos[:, 4]\n\n#\nax = df.plot.bar(x='year')\nax.set_title(\"Votos por a√±o para diferentes partidos pol√≠ticos en UK\")\nplt.show()\n\n#\nfig, ax = plt.subplots(figsize=(15, 8))\nax.plot(x, y1, label = 'conservative')\nax.plot(x, y2, label = 'labour')\nax.plot(x, y3, label = 'liberal')\nax.plot(x, y4, label = 'other')\nax.set_yticks(np.arange(0, 450, 50))\nax.set_xticks(np.arange(1966, 2020, 4))\nax.set_xlabel('A√±o')\nax.set_ylabel('Votos (miles)')\nax.grid(linestyle='--')\nax.legend()\nplt.show()\n\n[[1.966e+03 2.530e+02 3.640e+02 1.200e+01 1.000e+00]\n [1.970e+03 3.300e+02 2.870e+02 6.000e+00 7.000e+00]\n [1.974e+03 2.970e+02 3.010e+02 1.400e+01 1.800e+01]\n [1.975e+03 2.770e+02 3.130e+02 1.300e+01 3.200e+01]\n [1.979e+03 3.390e+02 2.690e+02 1.100e+01 1.600e+01]\n [1.983e+03 3.970e+02 2.090e+02 2.300e+01 6.000e+00]\n [1.987e+03 3.760e+02 2.290e+02 2.200e+01 2.300e+01]\n [1.992e+03 3.360e+02 2.710e+02 2.000e+01 2.300e+01]\n [1.997e+03 1.650e+02 4.180e+02 4.600e+01 2.200e+01]\n [2.001e+03 1.660e+02 4.120e+02 5.200e+01 2.900e+01]\n [2.005e+03 1.980e+02 3.560e+02 6.200e+01 4.300e+01]\n [2.010e+03 3.060e+02 2.580e+02 5.700e+01 2.500e+01]\n [2.015e+03 3.300e+02 2.320e+02 8.000e+00 8.000e+01]\n [2.017e+03 3.170e+02 2.620e+02 1.200e+01 5.900e+01]\n [2.019e+03 3.650e+02 2.020e+02 1.100e+01 7.200e+01]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport pandas as pd\n\n# Los datos del historial de acciones de Apple se han utilizado durante mucho tiempo \n# para predecir los precios de las acciones\n\n# Leer datos hist√≥ricos \ndf = pd.read_csv(\"https://raw.githubusercontent.com/matplotlib/sample_data/master/aapl.csv\", index_col=\"Date\")\n\n# Agrupar las fechas por a√±o\ndf.index = pd.to_datetime(df.index)\ndf_resampled = df.resample('Y').mean()\n\n# Visualizar el precio de cierre\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(1, 1, 1)\nax.plot(df_resampled[\"Close\"])\nax.set_xlabel(\"A√±o\")\nax.set_ylabel(\"Precio de cierre\")\nax.grid(True)\nax.set_title(\"Datos del historial de acciones de Apple \")\nplt.show()"
  },
  {
    "objectID": "clases2025/clase10_matplotlib-pandas.html#ejercicio",
    "href": "clases2025/clase10_matplotlib-pandas.html#ejercicio",
    "title": "Programaci√≥n Aplicada II",
    "section": "11 Ejercicio",
    "text": "11 Ejercicio\nReproducir la siguiente figura utilizando lo visto durante la clase:\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n# Crear figura y subplots\nfig, axs = plt.subplots(3, 1, figsize=(8, 15))\n\n# Graficar cada funci√≥n en un subplot diferente\ndatos = np.loadtxt(\"uk-election-results.csv\", delimiter=',', skiprows=1)\nprint(datos)\n\nx = datos[:, 0]\ny1 = datos[:, 1]\ny2= datos[:, 2]\ny3 = datos[:, 3]\ny4 = datos[:, 4]\n\n\naxs[2].plot(x, y1, label = 'conservative')\naxs[2].plot(x, y2, label = 'labour')\naxs[2].plot(x, y3, label = 'liberal')\naxs[2].plot(x, y4, label = 'other')\naxs[2].set_yticks(np.arange(0, 450, 50))\naxs[2].set_xticks(np.arange(1966, 2020, 4))\naxs[2].set_xlabel('A√±o')\naxs[2].set_ylabel('Votos (miles)')\naxs[2].grid(linestyle='--')\naxs[2].legend()\n\n# Datos ficticios\nx1 = np.linspace(0, 20, 10)\nx2 = np.linspace(-5, 16, 21)\nx3 = np.linspace(-10, 10, 10)\n\ny1 = x1\ny2 = x2**2\ny3 = x3**3\n\n# axs[0].plot(x1, y1, color='blue')\n# axs[0].set_title('y = x')\n# axs[0].set_xlabel('EJE X')\n# axs[0].set_ylabel('EJE Y')\n# axs[0].grid(True)\n# # Cambiar el formato de las etiquetas del eje Y\n# axs[0].set_xticks(np.arange(0, 22, 2))\n# axs[0].set_yticks(np.arange(0, 22, 2))\n\n# Subplot 2: Gr√°fico de dispersi√≥n\naxs[1].scatter(x2, y2, color='red')\naxs[1].set_title(r'$y = x^2$')\naxs[1].set_xlabel('X')\naxs[1].set_ylabel('Y')\naxs[1].grid(True)\naxs[1].set_xticks(np.arange(-5, 17, 1))\naxs[1].set_yticks(np.arange(0, 270, 10))\n\n# Subplot 3: Gr√°fico de barras\naxs[0].plot(x3, y3, color='green', marker='*', markersize=10)\naxs[0].set_title(r'$y = x^3$')\naxs[0].set_xlabel('Abscisas')\naxs[0].set_ylabel('Ordenadas')\naxs[0].grid(True)\n# Ajustar dise√±o\nplt.tight_layout()\n\n# Mostrar la figura\nplt.savefig(\"EjercicioMatplotlib.png\")\nplt.show()\n\n\n[[1.966e+03 2.530e+02 3.640e+02 1.200e+01 1.000e+00]\n [1.970e+03 3.300e+02 2.870e+02 6.000e+00 7.000e+00]\n [1.974e+03 2.970e+02 3.010e+02 1.400e+01 1.800e+01]\n [1.975e+03 2.770e+02 3.130e+02 1.300e+01 3.200e+01]\n [1.979e+03 3.390e+02 2.690e+02 1.100e+01 1.600e+01]\n [1.983e+03 3.970e+02 2.090e+02 2.300e+01 6.000e+00]\n [1.987e+03 3.760e+02 2.290e+02 2.200e+01 2.300e+01]\n [1.992e+03 3.360e+02 2.710e+02 2.000e+01 2.300e+01]\n [1.997e+03 1.650e+02 4.180e+02 4.600e+01 2.200e+01]\n [2.001e+03 1.660e+02 4.120e+02 5.200e+01 2.900e+01]\n [2.005e+03 1.980e+02 3.560e+02 6.200e+01 4.300e+01]\n [2.010e+03 3.060e+02 2.580e+02 5.700e+01 2.500e+01]\n [2.015e+03 3.300e+02 2.320e+02 8.000e+00 8.000e+01]\n [2.017e+03 3.170e+02 2.620e+02 1.200e+01 5.900e+01]\n [2.019e+03 3.650e+02 2.020e+02 1.100e+01 7.200e+01]]"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html",
    "href": "clases2025/clase08_programacion-cientifica.html",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#clase-09-programaci√≥n-cient√≠fica-con-bibliotecas-externas",
    "href": "clases2025/clase08_programacion-cientifica.html#clase-09-programaci√≥n-cient√≠fica-con-bibliotecas-externas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#temario",
    "href": "clases2025/clase08_programacion-cientifica.html#temario",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.2 Temario",
    "text": "1.2 Temario"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#contenido",
    "href": "clases2025/clase08_programacion-cientifica.html#contenido",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.3 Contenido",
    "text": "1.3 Contenido\n\nMotivaci√≥n\n\n¬øQu√© son las bibliotecas externas?\nBibliotecas populares en las √°reas de ingenier√≠a\n¬øC√≥mo instalar una biblioteca externa?\n\nNumPy\n\n¬øQu√© es NumPy y para que sirve?\nImportaci√≥n\nCreaci√≥n de ndarrays\nDimensi√≥n de un array y c√≥mo redimensionarlo\nTipos de datos\nIndexaci√≥n y rebanado\nAplicaciones en √°lgebra lineal"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#motivaci√≥n",
    "href": "clases2025/clase08_programacion-cientifica.html#motivaci√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.4 Motivaci√≥n",
    "text": "1.4 Motivaci√≥n\n\nEn el mundo de la programaci√≥n, una biblioteca externa se refiere a un conjunto de c√≥digo predefinido y desarrollado por terceros que proporciona funcionalidades espec√≠ficas que pueden ser utilizadas por nuestros programas.\nEstas bibliotecas est√°n dise√±adas para extender y mejorar la funcionalidad del lenguaje de programaci√≥n principal (en nuestro caso Python).\nUtilizar bibliotecas externas ahorra tiempo y esfuerzo, ya que las/los desarrolladores pueden aprovechar el trabajo previo de otros."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#bibliotecas-externas-en-el-√°rea-de-ingenier√≠a",
    "href": "clases2025/clase08_programacion-cientifica.html#bibliotecas-externas-en-el-√°rea-de-ingenier√≠a",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.5 Bibliotecas externas en el √°rea de Ingenier√≠a",
    "text": "1.5 Bibliotecas externas en el √°rea de Ingenier√≠a\n\nLas operaciones b√°sicas utilizadas en Ingenier√≠a incluyen arreglos, matrices, integraci√≥n, solucionadores de sistemas de ecuaciones, ecuaciones diferenciales, estad√≠sticas y mucho m√°s.\nPython no tiene ninguna de estas funcionalidades incorporadas de manera predeterminada, excepto algunas operaciones matem√°ticas b√°sicas que solo pueden manejar una variable y no un vector o matriz."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#bibliotecas-externas-en-el-√°rea-de-ingenier√≠a-1",
    "href": "clases2025/clase08_programacion-cientifica.html#bibliotecas-externas-en-el-√°rea-de-ingenier√≠a-1",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.6 Bibliotecas externas en el √°rea de Ingenier√≠a",
    "text": "1.6 Bibliotecas externas en el √°rea de Ingenier√≠a\n\n\n\nBiblioteca\n\n\nDescripci√≥n\n\n\n\n\n\n\n\nSe especializa en el procesamiento num√©rico a trav√©s de arreglos multidimensionales (matrices, vectores, tensores). NumPy facilita operaciones comunes como sumas, promedios, multiplicaciones y manipulaciones de matrices de manera eficiente.\n\n\n\n\n\n\n\nEs una biblioteca de visualizaci√≥n en 2D y 3D. Permite la creaci√≥n de gr√°ficos est√°ticos, gr√°ficos interactivos, y diagramas de dispersi√≥n, lo que es esencial para analizar y presentar datos de manera efectiva.\n\n\n\n\n SymPy\n\n\nPermite realizar c√°lculos simb√≥licos, manipular expresiones algebraicas y resolver ecuaciones simb√≥licamente. Es √∫til para realizar c√°lculos simb√≥licos avanzados, como derivadas, integrales, l√≠mites y manipulaci√≥n algebraica. Proporciona una forma poderosa de trabajar con matem√°ticas puras en entornos de programaci√≥n.\n\n\n\n\n\n\n\nProporciona estructuras de datos flexibles y herramientas dise√±adas para facilitar el trabajo con datos estructurados o tabulares. Su principal utilidad radica en el an√°lisis y manipulaci√≥n eficiente de conjuntos de datos."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#c√≥mo-instalar-una-biblioteca-externa-en-mi-ambiente-de-python",
    "href": "clases2025/clase08_programacion-cientifica.html#c√≥mo-instalar-una-biblioteca-externa-en-mi-ambiente-de-python",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.7 ¬øC√≥mo instalar una biblioteca externa en mi ambiente de Python?",
    "text": "1.7 ¬øC√≥mo instalar una biblioteca externa en mi ambiente de Python?\nOpci√≥n 1: Instalaci√≥n con Anaconda Navigator\n\nAbre Anaconda Navigator.\nHaz clic en la pesta√±a Environments.\nSelecciona el ambiente en el que desea instalar la biblioteca.\nEn la lista desplegable, selecciona Not Installed.\nHaz clic en el cuadro de di√°logo Search.\nEscribe el nombre de la biblioteca que deseas instalar.\nMarca la casilla de verificaci√≥n de la biblioteca que deseas instalar\nHaz clic en el bot√≥n Install.\n\nOpci√≥n 2: Instalaci√≥n desde terminal con conda\n\nAbre la terminal o s√≠mbolo del sistema.\nSi est√°s usando ambientes virtuales, activa el ambiente virtual deseado. Puedes usar el comando conda activate nombre_del_ambiente.\nEjecuta el comando conda install nombre_de_la_biblioteca. Por ejemplo, conda install numpy.\n\nOpci√≥n 3: Instalaci√≥n desde terminal con pip\n\nAbre la terminal o s√≠mbolo del sistema.\nSi est√°s usando ambientes virtuales, activa el ambiente virtual deseado. Puedes usar el comando source activate nombre_del_ambiente (Linux/macOS) o venv\\Scripts\\activate nombre_del_ambiente (Windows).\nEjecuta el comando pip install nombre_de_la_biblioteca. Por ejemplo, pip install pandas."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#numpy",
    "href": "clases2025/clase08_programacion-cientifica.html#numpy",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.8 NumPy",
    "text": "1.8 NumPy"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#qu√©-es-numpy",
    "href": "clases2025/clase08_programacion-cientifica.html#qu√©-es-numpy",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.9 ¬øQu√© es NumPy?",
    "text": "1.9 ¬øQu√© es NumPy?\n\nPaquete fundamental para la computaci√≥n cient√≠fica en Python.\nAgrega capacidades para trabajar con arreglos N-dimensionales, operaciones elemento por elemento (broadcasting), √°lgebra lineal y la capacidad de integrar c√≥digo C/C++/Fortran."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#por-qu√©-usar-numpy",
    "href": "clases2025/clase08_programacion-cientifica.html#por-qu√©-usar-numpy",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.10 ¬øPor qu√© usar NumPy?",
    "text": "1.10 ¬øPor qu√© usar NumPy?\n\nAlmacenamiento de datos num√©ricos\nEn Python:\n\nTipos de datos num√©ricos: int, float\nM√©todos populares para almacenar arreglos: listas y diccionarios.\nLimitaciones de las listas: operaciones computacionalmente ineficientes debido a bucles iterativos.\n\nEn NumPy:\n\nIntroduce el objeto de almacenamiento de datos llamado ndarray.\nSimilar a listas, pero con restricciones: solo se pueden almacenar elementos del mismo tipo.\nA pesar de esta limitaci√≥n, NumPy ofrece mejoras significativas en t√©rminos de velocidad en comparaci√≥n con las listas de Python."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#ejemplo",
    "href": "clases2025/clase08_programacion-cientifica.html#ejemplo",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.11 Ejemplo:",
    "text": "1.11 Ejemplo:\n\nHagamos una comparaci√≥n de velocidad entre operaciones usando NumPy ndarray y listas de Python.\n\n\nimport numpy as np\nimport time\n\n# Definir una funci√≥n que emule la operaci√≥n de multiplicaci√≥n elemento-a-elemento en una lista\ndef multiplicar_lista(lista, escalar):\n    return [val * escalar for val in lista]\n\n# Definir una funci√≥n que haga la operaci√≥n de multiplicaci√≥n elemento-a-elemento en un ndarray \ndef multiplicar_ndarray(arreglo, escalar):\n    return arreglo * escalar\n\n# Crear un array con 10^7 elementos.\narr = np.arange(10_000_000)\n\n# Crear una lista con 10^7 elementos\nlst = list(range(10_000_000))\n\n# Medir el tiempo de ejecuci√≥n para la multiplicaci√≥n con lista\ninicio_lista = time.time()\nresultado_lista = multiplicar_lista(lst, 1.1)\ntiempo_lista = time.time() - inicio_lista\nprint(f\"Operaci√≥n en lista tom√≥ {tiempo_lista:.2f} segundos.\")\n\n# Medir el tiempo de ejecuci√≥n para la multiplicaci√≥n con ndarray\ninicio_array = time.time()\nresultado_array = multiplicar_ndarray(arr, 1.1)\ntiempo_array = time.time() - inicio_array\nprint(f\"Operaci√≥n en ndarray tom√≥ {tiempo_array:.2f} segundos.\")\n\nOperaci√≥n en lista tom√≥ 1.92 segundos.\nOperaci√≥n en ndarray tom√≥ 0.08 segundos.\n\n\n\nLa operaci√≥n usando ndarray es ‚àº38 veces m√°s r√°pida que el ciclo for.\nA partir de este momento, utilizaremos objetos ndarray en vez de listas cuando nos sea posible."
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#convenci√≥n-de-importaci√≥n",
    "href": "clases2025/clase08_programacion-cientifica.html#convenci√≥n-de-importaci√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.12 Convenci√≥n de importaci√≥n",
    "text": "1.12 Convenci√≥n de importaci√≥n\nLa convenci√≥n recomendada para importar NumPy es:\n\nimport numpy as np"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#creaci√≥n-de-arrays",
    "href": "clases2025/clase08_programacion-cientifica.html#creaci√≥n-de-arrays",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.13 Creaci√≥n de Arrays",
    "text": "1.13 Creaci√≥n de Arrays\nExisten diversas maneras de crear un array en NumPy:\n\n# Primero creamos una lista y luego la envolvemos con la funci√≥n np.array().\nlista = [1, 2, 3]\narr = np.array(lista)\n\n\n# Creando un array de ceros con cinco elementos.\narr = np.zeros(5)\n\n\n# Creando un array del 0 al 99\narr = np.arange(100)\n\n\n# Creando un array del 10 al 99\narr = np.arange(10, 100)\n\n\n# Si deseas 100 elementos de 0 a 1...\narr = np.linspace(0, 1, 100)\n\n\n# O si deseas generar un array de 1 a 99 en pasos de 2...\narr = np.arange(1, 100, 2)\n\n\n# Creando un array de ceros de 5x5 (una matriz).\nmatriz = np.zeros((5, 5))\n\n\n# Creando un tensor/cubo de 5x5x5 de 1's.\n# El m√©todo astype() establece el array con elementos enteros.\ntensor = np.zeros((5, 5, 5)).astype(int) + 1\n\n\n# O a√∫n m√°s simple \ntensor = np.ones((5, 5, 5)).astype(int)"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#dimensi√≥n-de-un-arreglo",
    "href": "clases2025/clase08_programacion-cientifica.html#dimensi√≥n-de-un-arreglo",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.14 Dimensi√≥n de un arreglo",
    "text": "1.14 Dimensi√≥n de un arreglo\nEs √∫til comprender c√≥mo examinar la dimensi√≥n (shape) de un array y su longitud (len). Por ejemplo:\n\n# Obtener la dimensi√≥n (shape) de un array\ndim_arr = tensor.shape\nprint(f\"La forma del array 3D es: {dim_arr}\")\n# Salida: La forma del array 3D es: (5, 5, 5)\n\n# Obtener la longitud de un array\nlen_arr = len(arr)\nprint(f\"La longitud del array 1D es: {len_arr}\")\n# Salida: La longitud del array 1D es: 50\n\nLa forma del array 3D es: (5, 5, 5)\nLa longitud del array 1D es: 50"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#redimensionar-arreglos",
    "href": "clases2025/clase08_programacion-cientifica.html#redimensionar-arreglos",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.15 Redimensionar arreglos",
    "text": "1.15 Redimensionar arreglos\n\nPodemos reestructurar/redimensionar/acomodar arreglos de muchas maneras diferentes:\n\nSi tenemos un array de 25 elementos, podemos convertirlo en un array de 5x5\nO podr√≠amos crear un array tridimensional a partir de un array plano.\n\n\n\n# Creando un array con elementos de 0 a 999\narr1d = np.arange(1000)\n\n# Ahora redimensionamos el array 1D a un array 3D de 10x10x10\narr3d = arr1d.reshape((10, 10, 10))\n\n# El comando reshape tambi√©n se puede llamar de esta manera\narr3d = np.reshape(arr1d, (10, 10, 10))\n\n# Inversamente, podemos aplanar arrays\narr4d = np.zeros((10, 10, 10, 10))\narr1d = arr4d.ravel()\nprint(arr1d.shape) # Salida: (10000,)\n\n(10000,)"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#tipos-de-datos-en-un-ndarray",
    "href": "clases2025/clase08_programacion-cientifica.html#tipos-de-datos-en-un-ndarray",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.16 Tipos de Datos en un ndarray",
    "text": "1.16 Tipos de Datos en un ndarray\n\nComprender y especificar el tipo de datos es crucial al trabajar con NumPy, ya que afecta la precisi√≥n de los c√°lculos y la eficiencia del uso de la memoria.\nPor default, NumPy determina autom√°ticamente el tipo de dato utilizado para almacenar en memoria, dependiendo de c√≥mo escribimos los elementos al crear un ndarray.\n\n\na = np.array([1, 2, 3])\nprint(a.dtype)\n# Salida: dtype('int64')\n\nb = np.array([1., 2., 3.])\nprint(b.dtype)\n# Salida: dtype('float64')\n\n\nDiferentes tipos de datos nos permiten almacenar datos de manera m√°s compacta en la memoria.\nLa mayor√≠a de las veces simplemente trabajamos con n√∫meros de punto flotante.\nEl tipo de datos predeterminado es el de punto flotante:\n\n\na = np.ones((3, 3))\nprint(a.dtype)\n# Salida: dtype('float64')\n\n\nTambi√©n puedes especificar expl√≠citamente el tipo de datos que deseas:\n\n\nc = np.array([1, 2, 3], dtype=float)\nprint(c.dtype)\n# Salida: dtype('float64')\n\nExisten tambi√©n otros tipos: - Complejo:\n\nd = np.array([1+2j, 3+4j, 5+6*1j])\nprint(d.dtype)\n# Salida: dtype('complex128')\n\n\nBooleano:\n\n\ne = np.array([True, False, False, True])\nprint(e.dtype)\n# Salida: dtype('bool')"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#indexaci√≥n-y-slicing-rebanado",
    "href": "clases2025/clase08_programacion-cientifica.html#indexaci√≥n-y-slicing-rebanado",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.17 Indexaci√≥n y Slicing (rebanado)",
    "text": "1.17 Indexaci√≥n y Slicing (rebanado)\n\nLos elementos de un array pueden ser accedidos y asignados de la misma manera que otras secuencias (listas, cadenas, tuplas) de Python.\n\n\na = np.arange(10)\nprint(a)\n# Salida: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nprint(a[0], a[2], a[-1])\n# Salida: (0, 2, 9)\n\n\n1.17.1 Indexaci√≥n en arrays multidimensionales\nAl indexar listas en Python, normalmente hacemos lo siguiente para un objeto \\(2 \\times 2\\):\n\nmatriz = [[1, 2], [3, 4]]\n# Para devolver el elemento (0,1), debemos indexar de la siguiente manera.\nprint(matriz[0][1])\n\nPero en el caso de NumPy, los √≠ndices son tuplas de enteros:\n\nmatriz = np.array([[1, 2], [3, 4]])\nprint(matriz)\n# Salida:\n# array([[1, 2],\n#        [3, 4]])\nprint(matriz[1, 1])\n# Salida: 4\nmatriz[1, 0] = 10  # segunda fila, primera columna\nprint(matriz)\n# Salida:\n# array([[1, 2],\n#        [10, 4]])\n\nNota: - Si queremos devolver la columna de la derecha, no hay una manera trivial de hacerlo con listas en Python. - En NumPy, la indexaci√≥n sigue una sintaxis m√°s conveniente. - En 2D, la primera dimensi√≥n corresponde a las filas, la segunda a las columnas. - Para un array multidimensional a, a[0] se interpreta tomando todos los elementos en las dimensiones no especificadas.\n\n# Para acceder a la √∫ltima columna, simplemente usamos ...\nprint(matriz[:, 1])\n# Acceder a las filas se logra de la misma manera...\nprint(matriz[1, :])\n\n\nA veces se requieren esquemas de indexaci√≥n m√°s complejos, como la indexaci√≥n condicional.\nEl tipo m√°s com√∫nmente utilizado es numpy.where(). Con esta funci√≥n, puedes devolver los √≠ndices deseados de un array, independientemente de sus dimensiones, bas√°ndote en alguna(s) condici√≥n(es).\n\n\n# Creando un array\narr = np.arange(-5, 1)\n# Creando el array de √≠ndices\nindex = np.where(arr &gt; -3)\nprint(index)\n# Salida: (array([3, 4, 5]),)\n# Creando un nuevo arreglo\nnuevo_arr = arr[index]\nprint(nuevo_arr)\n\n\n\n1.17.2 Slicing/rebanado\nLos arrays, al igual que otras secuencias de Python, tambi√©n se pueden rebanar:\n\na = np.arange(10)\nprint(a)\n# Salida: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nprint(a[2:9:3])  # [inicio:fin:paso], ¬°Ten en cuenta que el √∫ltimo √≠ndice (fin) no est√° incluido!\n# Salida: array([2, 5, 8])\nprint(a[:4])\n# Salida: array([0, 1, 2, 3])\n\nLos tres componentes de la segmentaci√≥n no son obligatorios: por defecto, inicio es 0, fin es el √∫ltimo elemento y paso es 1:\n\nprint(a[1:3])\n# Salida: array([1, 2])\nprint(a[::2])\n# Salida: array([0, 2, 4, 6, 8])\nprint(a[3:])\n# Salida: array([3, 4, 5, 6, 7, 8, 9])"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#ejercicio",
    "href": "clases2025/clase08_programacion-cientifica.html#ejercicio",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.18 Ejercicio",
    "text": "1.18 Ejercicio\n\nCrea la siguiente matriz usando Numpy\nCrea las expresiones de indexaci√≥n y/o slicing correspondientes a los elementos resaltados en la imagen (rojo, azul, verde, morado)\n\n\n\n\nimgs/ejercicio_numpy.png\n\n\nImagen de scipy-lectures.org"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#datos-reales-c√≥mo-leer-y-escribir-arreglos-desdea-archivos",
    "href": "clases2025/clase08_programacion-cientifica.html#datos-reales-c√≥mo-leer-y-escribir-arreglos-desdea-archivos",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.19 Datos reales: c√≥mo leer y escribir arreglos desde/a archivos",
    "text": "1.19 Datos reales: c√≥mo leer y escribir arreglos desde/a archivos\n\nEs com√∫n que los experimentos o simulaciones con un sensor y otro dispositivo de medici√≥n escriban los resultados en archivos.\nEstos resultados pueden ser le√≠dos en Python como arreglos de NumPy para poder manipularlos.\nTambi√©n es posible guardar arreglos de NumPy en archivos.\n\n\n1.19.1 Lectura de arreglos desde archivo\nSi los datos est√°n estructurados con filas y columnas, entonces la funci√≥n np.loadtxt funcionar√° muy bien siempre y cuando todos los datos sean de un tipo similar, es decir, enteros o flotantes.\nPor ejemplo:\n\narchivo1.txt:\n1.0 2.0 3.0\n4.0 5.0 6.0\n7.0 8.0 9.0\n\n\n# Ejemplo 1: Archivo de texto con valores separados por espacios\ndatos1 = np.loadtxt('archivo1.txt')\nprint(\"Datos del archivo 1:\")\nprint(datos1)\n\n\narchivo2.csv:\n1.0,2.0,3.0\n4.0,5.0,6.0\n7.0,8.0,9.0\n\n\n# Ejemplo 2: Archivo de texto con valores separados por comas (CSV)\ndatos2 = np.loadtxt('archivo2.csv', delimiter=',')\nprint(\"Datos del archivo 2:\")\nprint(datos2)\n\n\narchivo3.txt (separaci√≥n con tabulador):\n1.0    2.0    3.0\n4.0    5.0    6.0\n7.0    8.0    9.0\n\n\n# Ejemplo 3: Archivo de texto con valores separados por tabulaciones\ndatos3 = np.loadtxt('archivo3.txt')\nprint(\"\\nDatos del archivo 3:\")\nprint(datos3)\n\n\narchivo4.txt (encabezado y comentarios):\n# Datos experimentales\n# Tiempo (s)    Temperatura (C)\n0.0            20.0\n1.0            21.5\n2.0            22.7\n\n\n# Ejemplo 4: Archivo de texto con encabezado y comentarios\ndatos4 = np.loadtxt('archivo4.txt', skiprows=2)  # Saltamos 2 filas para ignorar los comentarios y el encabezado\nprint(\"Datos del archivo 4:\")\nprint(datos4)\n\n\narchivo5.txt:\nXR21 32.789 1\nXR22 33.091 2\n\n\n# Ejemplo 5: Archivo de texto con diferentes tipos de datos en cada columna\ndatos5 = np.loadtxt('archivo5.txt', dtype={'names': ('ID', 'Resultado', 'Tipo'), 'formats': ('S4', 'f4', 'i2')})\nprint(\"Datos del archivo 5:\")\nprint(datos5)\n\n\n\n1.19.2 Escribir arreglos a un archivo\nPodemos guardar los datos de un arreglo de numpy con la funci√≥n np.savetxt\n\n# Supongamos que tenemos un arreglo de datos\ndatos = np.arange(1,10).reshape((3,3))\n\n# Guardamos los datos en un archivo de texto\nnp.savetxt('datos_guardados.txt', datos)\n\n# Para guardar los datos con un formato espec√≠fico, podemos especificar el formato\n# Por ejemplo, para guardar los datos con dos decimales de precisi√≥n y separados por comas:\nnp.savetxt('datos_guardados.csv', datos, fmt='%.2f', delimiter=',')\n\n# Tambi√©n podemos guardar solo ciertas columnas o filas de nuestros datos\n# Por ejemplo, para guardar solo la primera y la tercera columna:\nnp.savetxt('columnas_guardadas.txt', datos[:, [0, 2]])"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#broadcasting",
    "href": "clases2025/clase08_programacion-cientifica.html#broadcasting",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.20 Broadcasting",
    "text": "1.20 Broadcasting\n\nEn NumPy, las operaciones b√°sicas en arreglos (suma, resta, multiplicaci√≥n, divisi√≥n, etc.) se realizan elemento a elemento.\nEsto funciona en arreglos del mismo tama√±o. Sin embargo, tambi√©n es posible realizar operaciones en arreglos de diferentes tama√±os si NumPy puede transformar estos arreglos para que todos tengan el mismo tama√±o; esta conversi√≥n se llama broadcasting:\n\nCuando se realizan operaciones entre dos arreglos, NumPy compara dimensiones (shapes) de los arreglos involucrados.\nDos dimensiones son compatibles para la realizar operaci√≥n cuando:\n\nTienen el mismo tama√±o.\nUna de ellas tiene tama√±o 1.\n\n\n\n\nImagen de scipy-lectures.org\n\n# Caso 1, ambas matrices coinciden en numero de filas y columnas\nm1 = np.array([[0]*3, [10]*3, [20]*3, [30]*3])\nprint(\"M1:\\n\", m1)\nm2 = np.array([0, 1, 2]*4).reshape(4, 3)\nprint(\"M2:\\n\", m2)\nprint(\"M1+M2:\\n\", m1+m2)\n\n\n# Caso 2: las matrices coinciden en numero de columnas, \n#         m2 tiene 1 fila, que se repite para poder realizar la operaci√≥n con m1\nm1 = np.array([[0]*3, [10]*3, [20]*3, [30]*3])\nprint(\"M1:\\n\", m1)\nm2 = np.array([0, 1, 2])\nprint(\"M2:\\n\", m2)\nprint(\"M1+M2:\\n\", m1+m2)\n\n\n# Caso 3: las matrices no coinciden en numero de filas nicolumnas, \n#         m1 tiene 4 filas y 1 columna, la columna se repetir√° para coincidir con m2\n#         m2 tiene 1 fila y 3 columnas, la fila se repetir√° para coincidir con m1\nm1 = np.array([[0], [10], [20], [30]])\nprint(\"M1:\\n\", m1)\nm2 = np.array([0, 1, 2])\nprint(\"M2:\\n\", m2)\nprint(\"M1+M2:\\n\", m1+m2)"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#√°lgebra-lineal-con-numpy",
    "href": "clases2025/clase08_programacion-cientifica.html#√°lgebra-lineal-con-numpy",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.21 √Ålgebra Lineal con NumPy",
    "text": "1.21 √Ålgebra Lineal con NumPy\n\n1.21.1 Multiplicaci√≥n de matrices\n\nLa multiplicaci√≥n de matrices se realiza multiplicando cada elemento de una fila de la primera matriz por cada elemento correspondiente de una columna de la segunda matriz, y luego sumando los productos resultantes.\nEn NumPy, se puede realizar multiplicaci√≥n de matrices utilizando la funci√≥n np.dot() o el operador @.\n\n\n# Definir dos matrices\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\n\n# Multiplicar las matrices\nC = np.dot(A, B)\n# Alternativamente:\n# C = A @ B\n\nprint(\"Matriz A\\n\", A)\nprint(\"Matriz B\\n\", B)\nprint(\"Resultado de la multiplicaci√≥n de matrices:\")\nprint(C)\n\n\n\n1.21.2 Transpuesta de una matriz\n\nLa transpuesta de una matriz es otra matriz obtenida intercambiando las filas y columnas de la matriz original.\nEn NumPy, se puede calcular la transpuesta de una matriz utilizando el atributo .T o la funci√≥n np.transpose().\n\n\n# Definir una matriz\nA = np.array([[1, 2, 3], [4, 5, 6]])\n\n# Calcular la transpuesta\nA_transpuesta = A.T\n\n# Alternativamente:\n# A_transpuesta = np.transpose(A)\n\nprint(\"Matriz A:\\n\", A)\nprint(\"Transpuesta de la matriz:\")\nprint(A_transpuesta)\n\n\n\n1.21.3 Determinante de una matriz\n\nEl determinante de una matriz es un valor escalar que se calcula a partir de los elementos de la matriz.\nEn NumPy, podemos calcular el determinante de una matriz utilizando la funci√≥n np.linalg.det().\n\n\n# Definir una matriz\nA = np.array([[1, 2], [3, 4]])\n\n# Calcular el determinante\ndeterminante = np.linalg.det(A)\n\nprint(\"Matriz A:\\n\", A)\nprint(\"Determinante de la matriz:\")\nprint(determinante)\n\n\n\n1.21.4 Matriz inversa\n\nLa matriz inversa es una matriz que, cuando se multiplica por la matriz original, produce la matriz identidad.\nNo todas las matrices tienen una inversa, pero si una matriz es invertible, podemos calcular la inversa de una matriz utilizando la funci√≥n np.linalg.inv().\n\n\n# Definir una matriz\nA = np.array([[1, 2], [3, 4]])\n\n# Calcular la matriz inversa\nA_inversa = np.linalg.inv(A)\n\nprint(\"Matriz A\\n\", A)\nprint(\"Matriz inversa:\")\nprint(A_inversa)\n\n\n\n1.21.5 Resolver sistemas de ecuaciones\n\nResolver sistemas de ecuaciones lineales es una tarea com√∫n en √°lgebra lineal.\nEn NumPy, se pueden resolver sistemas de ecuaciones lineales utilizando la funci√≥n np.linalg.solve().\n\n\n# Definir coeficientes y t√©rminos independientes\ncoeficientes = np.array([[2, 3], [1, -2]])\nterminos_independientes = np.array([8, -4])\n\n# Resolver el sistema de ecuaciones\nsolucion = np.linalg.solve(coeficientes, terminos_independientes)\n\nprint(\"Matriz de coeficientes\")\nprint(coeficientes)\nprint(\"Vector de t√©rminos independientes\")\nprint(terminos_independientes)\nprint(\"Soluci√≥n del sistema de ecuaciones:\")\nprint(solucion)"
  },
  {
    "objectID": "clases2025/clase08_programacion-cientifica.html#referencias",
    "href": "clases2025/clase08_programacion-cientifica.html#referencias",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.22 Referencias",
    "text": "1.22 Referencias\n1. Python for Scientific Computing. Python Autumn School 2010. https://aspp.school/python-autumnschool-2010/_media/pythonscientific-nup.pdf\n2. NumPy and SciPy. Numerical Methods in Scientific Computing. https://geofaculty.uwyo.edu/neil/teaching/Numerical_web/SciPyNumPy.pdf\n3. Schmidt, W. F. (n.d.). Lecture 5: Linear Algebra. CME 193: Introduction to Scientific Computing. Stanford University. https://web.stanford.edu/~schmit/cme193/lec/lec5.pdf\n4. SciPy: Open Source Scientific Tools for Python. SciPy Lectures. https://scipy-lectures.org/_downloads/ScipyLectures-simple.pdf"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html",
    "href": "clases2025/clase06_manejo-de-errores.html",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#clase-06-manejo-de-excepciones-y-aserciones",
    "href": "clases2025/clase06_manejo-de-errores.html#clase-06-manejo-de-excepciones-y-aserciones",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#temario",
    "href": "clases2025/clase06_manejo-de-errores.html#temario",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.2 Temario",
    "text": "1.2 Temario"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#contenido",
    "href": "clases2025/clase06_manejo-de-errores.html#contenido",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.3 Contenido",
    "text": "1.3 Contenido\n\nMotivaci√≥n: manejo de errores\n\nExcepciones incorporadas comunes\n\nExcepciones\n\n¬øQue son las excepciones?\nManejo de excepciones usando bloques try-except\nManejo de excepciones m√∫ltiples\nLas instrucciones else y finally en el bloque try-except\n\nExcepciones personalizadas\n\nC√≥mo definir y lanzar excepciones personalizadas"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#motivaci√≥n-manejo-de-errores",
    "href": "clases2025/clase06_manejo-de-errores.html#motivaci√≥n-manejo-de-errores",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.4 Motivaci√≥n: manejo de errores",
    "text": "1.4 Motivaci√≥n: manejo de errores\n\nAlgunas veces los programas o aplicaciones que ejecutamos en la computadora enfrentan situaciones inesperadas o no v√°lidas.\n¬øQu√© sucede en el programa?\nEl programa o aplicaci√≥n puede generar una excepci√≥n, que se clasifica en varios tipos:\n\n\nDe valor (Value Error): Ocurre cuando se proporciona una entrada de datos inesperada o inv√°lida.\n\n\nresultado = int(\"abc\")\n\n\nDe √≠ndice (IndexError): Se produce al intentar acceder a elementos m√°s all√° de los l√≠mites de una lista.\n\n\nlista = [1, 2, 3]\nelemento = lista[3]\n\n\nDe nombre (NameError): Surge al utilizar el nombre de una variable que no est√° definida en el programa.\n\n\nprint(variable_no_definida)\n\n\nDe atributo (AttributeError): Se presenta al intentar obtener o modificar el valor de un atributo inexistente o privado en un objeto o clase.\n\n\nclass MiClase:\n    pass\n\nobjeto = MiClase()\natributo = objeto.atributo_inexistente\n\n\nDe sintaxis (SyntaxError): Aparece al escribir c√≥digo que no sigue las reglas del lenguaje de programaci√≥n utilizado.\n\n\nz = 10\nif z&gt;1\n pass\n\n\nDe entrada/salida de archivo (IOError): Ocurre al intentar leer o escribir en un archivo inexistente o sin los permisos necesarios.\n\n\narchivo = open(\"archivo_inexistente.txt\", \"r\")     \n\n\nDivisi√≥n por cero (ZeroDivisionError): Se genera al intentar realizar una operaci√≥n aritm√©tica de divisi√≥n por cero.\n\n\nresultado = 10 / 0\n\n\nEtc.\n\n\nImagen de betterprogramming.pub"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#qu√©-son-las-excepciones",
    "href": "clases2025/clase06_manejo-de-errores.html#qu√©-son-las-excepciones",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.5 ¬øQu√© son las excepciones?",
    "text": "1.5 ¬øQu√© son las excepciones?\n\nLas excepciones son situaciones de error o eventos inesperados que pueden ocurrir durante la ejecuci√≥n y que interrumpen el flujo normal de un programa.\nEn Python, una excepci√≥n es un mecanismo para declarar y responder a condiciones excepcionales.\n\nPython genera una excepci√≥n cada vez que ocurre un error.\nLas excepciones no controladas har√°n que Python interrumpa la ejecuci√≥n del programa.\nNuestro c√≥digo puede manejar las excepciones, evitando que la ejecuci√≥n se detenga.\n\nLas excepciones son los objetos. Tienen clases con constructores."
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#para-que-sirven-las-excepciones",
    "href": "clases2025/clase06_manejo-de-errores.html#para-que-sirven-las-excepciones",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.6 ¬øPara que sirven las excepciones?",
    "text": "1.6 ¬øPara que sirven las excepciones?\n\nImagen de programmerhumor.io"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#para-que-sirven-las-excepciones-1",
    "href": "clases2025/clase06_manejo-de-errores.html#para-que-sirven-las-excepciones-1",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.7 ¬øPara que sirven las excepciones?",
    "text": "1.7 ¬øPara que sirven las excepciones?\nLas excepciones proporcionan informaci√≥n valiosa sobre posibles errores en el c√≥digo, permitiendo a las/los desarrolladores identificar y gestionar problemas de manera efectiva. \nCada tipo de excepci√≥n est√° dise√±ado para abordar situaciones espec√≠ficas, facilitando la depuraci√≥n y mejorando la robustez de la aplicaci√≥n.\n\nPara garantizar que un programa funcione de manera confiable y no se bloquee inesperadamente.\nUn manejo efectivo de errores mejora la experiencia del usuario al proporcionar mensajes de error significativos y orientaci√≥n sobre c√≥mo resolver problemas.\n\nLos errores manejados correctamente facilitan la identificaci√≥n y correcci√≥n de problemas durante el desarrollo y el mantenimiento.\nUn manejo inadecuado de errores puede llevar a vulnerabilidades de seguridad al exponer informaci√≥n sensible o proporcionar a los atacantes informaci√≥n sobre el funcionamiento interno de un sistema."
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#manejo-de-excepciones-utilizando-bloques-try-except",
    "href": "clases2025/clase06_manejo-de-errores.html#manejo-de-excepciones-utilizando-bloques-try-except",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.8 Manejo de excepciones utilizando bloques try-except:",
    "text": "1.8 Manejo de excepciones utilizando bloques try-except:\nEl manejo de excepciones permite que el programa contin√∫e ejecut√°ndose sin interrupciones, incluso si ocurre un error.\n\nEl bloque try se utiliza para encerrar el c√≥digo que podr√≠a generar una excepci√≥n.\nEl bloque except contiene el c√≥digo que se ejecutar√° si se produce la excepci√≥n especificada en el bloque try.\n\n\n1.8.1 a) Instrucci√≥n Except sin excepci√≥n espec√≠fica\n\nUna instrucci√≥n except sin el nombre de excepci√≥n espec√≠fico har√° que el int√©rprete de Python lo considere por defecto como un objeto de la clase base Exception, y capturar√° todas las excepciones.\nLa sintaxis es la siguiente:\n\ntry:\n    # C√≥digo que puede generar excepciones\nexcept:\n    # C√≥digo a ejecutar en caso de cualquier excepci√≥n\n\nEn este caso, el bloque except se activar√° para cualquier tipo de excepci√≥n que ocurra dentro del bloque try, proporcionando as√≠ una gesti√≥n general de errores.\nEs importante usar esta construcci√≥n con precauci√≥n, ya que capturar todas las excepciones puede ocultar problemas espec√≠ficos y dificultar la depuraci√≥n del c√≥digo.\n\n\n\n1.8.2 b) Instrucci√≥n Except con excepci√≥n espec√≠fica\n\nCuando se utiliza el bloque try-except con la especificaci√≥n de un tipo de excepci√≥n, estamos focalizando el manejo de errores en un tipo particular de situaci√≥n que puede surgir durante la ejecuci√≥n del c√≥digo.\nEsto permite un tratamiento m√°s espec√≠fico y preciso de las excepciones.\nLa sintaxis es la siguiente:\n\ntry:\n    # C√≥digo que puede generar una excepci√≥n espec√≠fica\nexcept TipoDeExcepcion as nombre:\n    # C√≥digo a ejecutar en caso de que se produzca la excepci√≥n espec√≠fica\nDonde TipoDeExcepcion es el tipo espec√≠fico de excepci√≥n que queremos manejar, y nombre es un identificador opcional que se vincula a la instancia de la excepci√≥n para permitir su posterior an√°lisis o manipulaci√≥n.\n\n\n1.8.3 Ejemplo\n\ndef dividir_numeros():\n    try:\n        numerador = int(input(\"Ingrese el numerador: \"))\n        denominador = int(input(\"Ingrese el denominador: \"))\n        resultado = numerador / denominador\n        print(f\"Resultado de la divisi√≥n: {resultado}\")\n    except ZeroDivisionError as e:\n        print(f\"Error: {e}. No se puede dividir por cero.\")\n        \ndividir_numeros()\n\nFlujo de ejecuci√≥n:\n\nEl bloque de instrucciones dentro de try se ejecuta primero.\nSi durante este proceso surge una excepci√≥n y si la clase de excepci√≥n coincide con la clase especificada en la cl√°usula except, entonces el bloque de instrucciones dentro de except se ejecuta.\nEn el bloque except, el identificador especificado (e en el ejemplo anteior) se vincula a la excepci√≥n generada, lo que permite el acceso a la informaci√≥n sobre la excepci√≥n para su posterior procesamiento.\n\n\n\n1.8.4 Manejo de m√∫ltiples excepciones\n\nPython permite manejar varios tipos de excepciones:\n\nen un solo bloque except.\ncon varias cl√°usulas except para diferentes tipos de excepciones.\n\nEjemplos:\n\n\ndef dividir_numeros_v2():\n    try:\n        numerador = int(input(\"Ingrese el numerador: \"))\n        denominador = int(input(\"Ingrese el denominador: \"))\n        resultado = numerador / denominador\n        print(f\"Resultado de la divisi√≥n: {resultado}\")\n    except (ZeroDivisionError, ValueError) as e:\n        print(f\"Error: {e}. Ingrese valores num√©ricos v√°lidos.\")\n\ndividir_numeros_v2()\n\n\ndef dividir_numeros_v3():\n    try:\n        numerador = int(input(\"Ingrese el numerador: \"))\n        denominador = int(input(\"Ingrese el denominador: \"))\n        resultado = numerador / denominador\n        print(f\"Resultado de la divisi√≥n: {resultado}\")\n    except ZeroDivisionError as e:\n        print(f\"Error: {e}. No se puede dividir por cero.\")\n    except ValueError as e:\n        print(f\"Error: {e}. Ingrese valores num√©ricos v√°lidos.\")\n\ndividir_numeros_v3()"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#las-instrucciones-else-y-finally",
    "href": "clases2025/clase06_manejo-de-errores.html#las-instrucciones-else-y-finally",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.9 Las instrucciones else y finally",
    "text": "1.9 Las instrucciones else y finally\nelse: - El bloque else se ejecuta cuando no se produce ninguna excepci√≥n en el bloque try. - Proporciona la oportunidad de incluir c√≥digo que debe ejecutarse solo si no se generan excepciones.\nfinally: - El bloque finally se utiliza para definir c√≥digo que siempre se ejecutar√°, independientemente de si se produce una excepci√≥n o no. - Es √∫til para realizar acciones de limpieza o liberaci√≥n de recursos, garantizando que se realicen incluso en casos de excepciones.\n\nImagen de www.datacamp.com\n\n1.9.1 Ejemplo\n\ndef leer_archivo(nombre_archivo):\n    try:\n        archivo = open(nombre_archivo, \"r\")\n        contenido = archivo.read()\n    except FileNotFoundError:\n        print(\"Error: El archivo no fue encontrado.\")\n    except IOError:\n        print(\"Error: Hubo un problema al leer el archivo.\")\n    else:\n        # Si no hubo excepciones, mostramos el contenido del archivo\n        print(\"Contenido del archivo:\")\n        print(contenido)\n    finally:\n        try:\n            archivo.close()  # Cerramos el archivo solo si fue abierto\n            print(\"El archivo ha sido cerrado.\")\n        except NameError:\n            print(\"No se pudo cerrar el archivo porque no fue abierto correctamente.\")\n\nleer_archivo(\"ejemplo.txt\")\n\nError: El archivo no fue encontrado.\nNo se pudo cerrar el archivo porque no fue abierto correctamente.\n\n\n\nEn este ejemplo, se intenta abrir el archivo ejemplo.txt para su lectura.\nSi el archivo no se encuentra, se maneja la excepci√≥n FileNotFoundError.\nSi no se produce ninguna excepci√≥n, se imprime un mensaje indicando que la lectura fue exitosa.\nFinalmente, se cierra el archivo en el bloque finally, garantizando que se realice esta acci√≥n de limpieza independientemente de si se produjo una excepci√≥n o no."
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#excepciones-personalizadas",
    "href": "clases2025/clase06_manejo-de-errores.html#excepciones-personalizadas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.10 Excepciones personalizadas",
    "text": "1.10 Excepciones personalizadas"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#definici√≥n-y-lanzamiento-de-excepciones",
    "href": "clases2025/clase06_manejo-de-errores.html#definici√≥n-y-lanzamiento-de-excepciones",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.11 Definici√≥n y lanzamiento de excepciones:",
    "text": "1.11 Definici√≥n y lanzamiento de excepciones:\n\nEn Python, podemos crear excepciones personalizadas al definir una nueva clase que herede de la clase base Exception o una de sus subclases.\nPara lanzar una excepci√≥n (ya incorporada en Python o personalizada), se usa la palabra reservada raise seguida de una instancia de la clase.\nEjemplo:\n\n\n# Definimos una clase derivada de Exception\nclass EntradaInvalidaError(Exception):\n    def __init__(self, mensaje=\"Entrada inv√°lida.\"): \n        super().__init__(mensaje)\n\n# Definimos una funci√≥n para validar si un correo electr√≥nico tiene el formato correcto\ndef validar_correo(correo):\n    if \"@\" not in correo:\n        raise EntradaInvalidaError(\"Formato de correo incorrecto.\")\n\n# Programa principal\ntry:\n    validar_correo(\"correo_invalido\")\nexcept EntradaInvalidaError as e:\n    print(f\"Error: {e}\")\n\n\nLas excepciones personalizadas son √∫tiles para representar y manejar situaciones espec√≠ficas en el c√≥digo que no se ajustan a las excepciones est√°ndar de Python."
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#ejemplo-2",
    "href": "clases2025/clase06_manejo-de-errores.html#ejemplo-2",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.12 Ejemplo",
    "text": "1.12 Ejemplo\n\n¬øQu√© error podr√≠a presentarse en el siguiente c√≥digo?\n\n\nclass CuentaBancaria:\n    def __init__(self, saldo_inicial):\n        self.saldo = saldo_inicial\n\n    def realizar_retiro(self, monto):\n        self.saldo -= monto\n        print(f\"Retiro exitoso. Saldo restante: {self.saldo}\")\n        \nsaldo_inicial = float(input(\"Ingresa el saldo inicial de la cuenta:\"))\ncuenta = CuentaBancaria(saldo_inicial)\ncantidad_a_retirar = float(input(\"¬øCuanto deseas retirar de la cuenta?:\"))\ncuenta.realizar_retiro(cantidad_a_retirar)"
  },
  {
    "objectID": "clases2025/clase06_manejo-de-errores.html#referencias-bibliograficas",
    "href": "clases2025/clase06_manejo-de-errores.html#referencias-bibliograficas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.13 Referencias bibliograficas",
    "text": "1.13 Referencias bibliograficas\n1. Jones, R. (2011). AM583 Lecture 27: Numerical Python, Part 4. University of Washington. Enlace: https://faculty.washington.edu/rjl/am583/slides2011/am583lecture27nup4.pdf\n2. G√ºltekin, M. H. (n.d.). Lecture 9: Exceptions. Hacettepe University. Enlace: https://web.cs.hacettepe.edu.tr/~muh101/lectures/lecture9/lecture9.pdf\n3. Runestone Academy. (n.d.). Exceptions. Think Cspy. Enlace: https://runestone.academy/ns/books/published/thinkcspy/Exceptions/toctree.html"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#clase-04-encapsulamiento-y-polimorfismo",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#clase-04-encapsulamiento-y-polimorfismo",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#temario",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.2 Temario",
    "text": "0.2 Temario"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#contenido",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.3 Contenido",
    "text": "0.3 Contenido\n\nEncapsulamiento\n\nMotivaci√≥n\n¬øQu√© es el encapsulamiento?\n¬øPor qu√© hacer encapsulamiento?\nAtributos|M√©todos p√∫blicos\nAtributos|M√©todos privados\nM√©todos setter y getter\nName Mangling\n\n¬øQu√© es el polimorfismo?\n\n¬øQu√© es el polimorfimo?\nPolimorfismo con funciones\nPolimorfismo con m√©todos\nPolimorfismo con sobrecarga de operadores\nPolimorfismo con herencia\n\nEjercicio"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#en-el-cap√≠tulo-anterior",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#en-el-cap√≠tulo-anterior",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.4 En el cap√≠tulo anterior ‚Ä¶",
    "text": "0.4 En el cap√≠tulo anterior ‚Ä¶\n\nVimos que una clase es una plantilla que define un tipo de dato compuesto por atributos y m√©todos, mientras que un objeto es una instancia de esa clase en la memoria del programa.\nSe demostr√≥ c√≥mo crear una clase y un objeto en Python, utilizando la palabra clave class y el constructor __init__.\nSe introdujo el concepto de atributo, que puede ser de instancia o de clase, y se mostr√≥ c√≥mo acceder a ellos.\nLos m√©todos tambi√©n fueron discutidos, incluyendo m√©todos de instancia, de clase y est√°ticos. Se proporcionaron ejemplos de c√≥mo definir y utilizar estos m√©todos en una clase."
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#motivaci√≥n",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#motivaci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.1 Motivaci√≥n",
    "text": "1.1 Motivaci√≥n\n - Como hemos visto, en Python podemos acceder a los atributos de clase con la palabra reservada self desde dentro de la clase, y con el nombre del objeto/clase, punto, y nombre del atributo desde el exterior (en el programa principal, m√≥dulo o en otra clase).\n\nNo obstante, en algunas ocasiones vamos a preferir que los atributos y m√©todos no sean accesibles desde el exterior, es decir, que sean privados."
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#qu√©-es-el-encapsulamiento",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#qu√©-es-el-encapsulamiento",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.2 ¬øQu√© es el encapsulamiento?",
    "text": "1.2 ¬øQu√© es el encapsulamiento?\n\nEs uno de los pilares de la programaci√≥n orientada a objetos (OOP).\nSe refiere a la ocultaci√≥n de los detalles internos de una clase y la restricci√≥n del acceso directo a ciertos componentes."
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#por-qu√©-hacer-encapsulamiento",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#por-qu√©-hacer-encapsulamiento",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.3 ¬øPor qu√© hacer encapsulamiento?",
    "text": "1.3 ¬øPor qu√© hacer encapsulamiento?\n\nProtege un objeto del acceso no deseado mediante c√≥digo fuera de la clase. EJ: Una aplicaci√≥n bancaria proh√≠be a un cliente cambiar el saldo de una Cuenta.\nPermite cambiar/actualizar la implementaci√≥n de la clase si es necesario, sin que eso afecte el funcionamiento de la misma. EJ: Podr√≠amos cambiar la l√≥gica detr√°s de un m√©todo, pero su nombre y par√°metros no cambian, as√≠ que se pueden seguir utilizando de la misma manera.\nPermite restringir el estado de los objetos ( atributos invariantes).\n\n\n1.3.1 Atributos y M√©todos P√∫blicos\n\nLos atributos y m√©todos p√∫blicos son accesibles desde fuera de la clase.\nLos atributos y m√©todos cuyos nombres no comienzan con dos guiones bajos se consideran p√∫blicos.\n\n\n\n1.3.2 Atributos y M√©todos Privados\n\nUn atributo o m√©todo se considera privado cuando su nombre comienza con dos guiones bajos (__).\nEstos atributos y m√©todos no son accesibles directamente desde fuera de la clase.\n\n\n\n1.3.3 Ejemplo:\n\nclass CuentaBancaria:\n    def __init__(self, titular, saldo):\n        self.__titular = titular\n        self.__saldo = saldo\n\n    def __validar_cantidad(self, cantidad):\n        # Verifica si la cantidad es v√°lida para retiro\n        if cantidad &lt;= 0:\n            print(\"Error: La cantidad debe ser mayor a cero.\")\n            return False\n        elif cantidad &gt; self.__saldo:\n            print(\"Error: Fondos insuficientes.\")\n            return False\n        return True\n\n    def depositar(self, cantidad):\n        if cantidad &gt; 0:\n            self.__saldo += cantidad\n            print(f\"Dep√≥sito exitoso. Nuevo saldo: ${self.__saldo}\")\n        else:\n            print(\"Error: La cantidad a depositar debe ser positiva.\")\n\n    def retirar(self, cantidad):\n        if self.__validar_cantidad(cantidad):\n            self.__saldo -= cantidad\n            print(f\"Retiro exitoso. Nuevo saldo: ${self.__saldo}\")\n\n\n\ncuenta = CuentaBancaria(\"Jos√© P√©rez\", 1000)\ncuenta.depositar(500)  # Dep√≥sito exitoso\ncuenta.retirar(200)    # Retiro exitoso\ncuenta.retirar(2000)   # Error: Fondos insuficientes\ncuenta.retirar(-100)   # Error: La cantidad debe ser mayor a cero\n\nDep√≥sito exitoso. Nuevo saldo: $1500\nRetiro exitoso. Nuevo saldo: $1300\nError: Fondos insuficientes.\nError: La cantidad debe ser mayor a cero.\n\n\nIntentar acceder directamente a un atributo o m√©todo privado genera un error:\n\n# Intento de llamar al atributo privado (esto fallar√°)\n# print(cuenta.__titular)  # Esto generar√° un error\n\nIntentar llamar directamente a un m√©todo privado genera un error:\n\n# Intento de llamar al m√©todo privado (esto fallar√°)\n# cuenta.__validar_cantidad(100)  # AttributeError\n\n\n\n1.3.4 M√©todos Getter y Setter\nPara acceder o modificar atributos privados, se deben implementar m√©todos llamados getters y setters. - Un getter es un m√©todo que obtiene el valor de un atributo privado. - Un setter es un m√©todo que establece el valor de un atributo privado.\nAgreguemos getters y setters para la clase Punto:"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#opci√≥n-1-m√©todo-tradicional",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#opci√≥n-1-m√©todo-tradicional",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.4 Opci√≥n 1 (m√©todo tradicional):",
    "text": "1.4 Opci√≥n 1 (m√©todo tradicional):\n\nclass CuentaBancaria:\n    def __init__(self, titular, saldo):\n        self.__titular = titular\n        self.__saldo = saldo\n\n    def __validar_cantidad(self, cantidad):\n        # Verifica si la cantidad es v√°lida para retiro\n        if cantidad &lt;= 0:\n            print(\"Error: La cantidad debe ser mayor a cero.\")\n            return False\n        elif cantidad &gt; self.__saldo:\n            print(\"Error: Fondos insuficientes.\")\n            return False\n        return True\n\n    def depositar(self, cantidad):\n        if cantidad &gt; 0:\n            self.__saldo += cantidad\n            print(f\"Dep√≥sito exitoso. Nuevo saldo: ${self.__saldo}\")\n        else:\n            print(\"Error: La cantidad a depositar debe ser positiva.\")\n\n    def retirar(self, cantidad):\n        if self.__validar_cantidad(cantidad):\n            self.__saldo -= cantidad\n            print(f\"Retiro exitoso. Nuevo saldo: ${self.__saldo}\")\n\n    # Este es un m√©todo getter para saldo\n    def obtener_saldo(self):\n        return self.__saldo\n\n    # Este es un m√©todo setter para saldo\n    def set_saldo(self, nuevo_saldo):\n        # con validaci√≥n\n        if nuevo_saldo &gt;= 0:\n            self.__saldo = nuevo_saldo\n        else:\n            print(\"Error: El saldo no puede ser negativo.\")\n\n    # Este es un m√©todo getter para titular\n    def get_titular(self):\n        return self.__titular\n\n    # Este es un m√©todo setter para titular\n    def set_titular(self, nuevo_titular):\n        if isinstance(nuevo_titular, str) and  :\n            self.__titular = nuevo_titular\n        else:\n            print(\"Error: El titular debe ser un nombre v√°lido.\")\n\nUtilizar los m√©todos getter:\n\ncuenta2 = CuentaBancaria(\"Mar√≠a L√≥pez\", 1000)\nprint(f\"Saldo actual: ${cuenta2.obtener_saldo()}\")  # Saldo actual: 1300\n\nSaldo actual: $1000\n\n\nUtilizar los m√©todos setter:\n\ncuenta2.set_saldo(1300)\n\nUtilizar los m√©todos getter para obtener las nuevas coordenadas:\n\nprint(f\"Saldo actual: ${cuenta2.obtener_saldo()}\")  # Saldo actual: 1300\n\n# Intentar modificar el atributo directamente no marca error, pero no modifica la cantidad\ncuenta2.saldo=9\nprint(f\"Saldo actual: ${cuenta2.obtener_saldo()}\")  # Saldo actual: 1300\n\nSaldo actual: $1300\nSaldo actual: $1300"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#opci√≥n-2-usando-el-decorador-property",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#opci√≥n-2-usando-el-decorador-property",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.5 Opci√≥n 2 (usando el decorador @property):",
    "text": "1.5 Opci√≥n 2 (usando el decorador @property):\n\nclass CuentaBancariaV2:\n    def __init__(self, titular, saldo):\n        self.__titular = titular\n        self.__saldo = saldo\n\n    def __validar_cantidad(self, cantidad):\n        # Verifica si la cantidad es v√°lida para retiro\n        if cantidad &lt;= 0:\n            print(\"Error: La cantidad debe ser mayor a cero.\")\n            return False\n        elif cantidad &gt; self.__saldo:\n            print(\"Error: Fondos insuficientes.\")\n            return False\n        return True\n\n    def depositar(self, cantidad):\n        if cantidad &gt; 0:\n            self.__saldo += cantidad\n            print(f\"Dep√≥sito exitoso. Nuevo saldo: ${self.__saldo}\")\n        else:\n            print(\"Error: La cantidad a depositar debe ser positiva.\")\n\n    def retirar(self, cantidad):\n        if self.__validar_cantidad(cantidad):\n            self.__saldo -= cantidad\n            print(f\"Retiro exitoso. Nuevo saldo: ${self.__saldo}\")\n\n    # Getter con @property para el saldo\n    @property\n    def saldo(self):\n        return self.__saldo\n\n    # Setter con @property para el saldo\n    @saldo.setter\n    def saldo(self, nuevo_saldo):\n        if nuevo_saldo &gt;= 0:\n            self.__saldo = nuevo_saldo\n        else:\n            print(\"Error: El saldo no puede ser negativo.\")\n\n    # Getter con @property para el titular\n    @property\n    def titular(self):\n        \"\"\"Getter para obtener el titular\"\"\"\n        return self.__titular\n    \n    # Setter con @property para el saldo\n    @titular.setter\n    def titular(self, nuevo_titular):\n        \"\"\"Setter para modificar el titular\"\"\"\n        if isinstance(nuevo_titular, str) and nuevo_titular.strip():\n            self.__titular = nuevo_titular\n        else:\n            print(\"Error: El titular debe ser un nombre v√°lido.\")\n\n\nUtilizar los m√©todos getter:\n\n# Imprimir los valores directamente utilizando las propiedades\ncuenta3 = CuentaBancariaV2(\"Juan Gonz√°lez\", 500)\nprint(f\"Titular: {cuenta3.titular}, Saldo: ${cuenta3.saldo}\")\ncuenta3.saldo = 2000  # Modifica el saldo\nprint(f\"Nuevo saldo: ${cuenta3. }\")\n\nTitular: Juan Gonz√°lez, Saldo: $500\nNuevo saldo: $2000\n\n\nModificar los atributos utilizando las propiedades (con validaci√≥n):\n\ncuenta3.titular = \"Ana Gonz√°lez\"  # Cambia el titular\nprint(f\"Nuevo titular: {cuenta3.titular}\")\n\ncuenta3.saldo = -500  # Error: saldo no puede ser negativo\ncuenta3.titular = \"\"  # Error: titular inv√°lido\n\nNuevo titular: Ana Gonz√°lez\nError: El saldo no puede ser negativo.\nError: El titular debe ser un nombre v√°lido.\n\n\n\n1.5.1 Name Mangling\n\nPython realiza un cambio de nombre (name mangling) de los atributos privados al nivel de la clase, agregando un prefijo _NombreDeLaClase antes del nombre del atributo.\nEsto dificulta el acceso a estos atributos desde fuera de la clase, pero no lo impide completamente.\nclass Ejemplo:\n    def __init__(self):\n        self.__atributo_privado = 0\n\nobjeto = Ejemplo()\n# Acceso directo al atributo privado utilizando el nombre mangling\nprint(objeto._Ejemplo__atributo_privado)"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#qu√©-es-el-polimorfismo",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#qu√©-es-el-polimorfismo",
    "title": "Programaci√≥n Aplicada II",
    "section": "2.1 ¬øQu√© es el Polimorfismo?",
    "text": "2.1 ¬øQu√© es el Polimorfismo?\n\nCapacidad de objetos de distintas clases de responder a la misma operaci√≥n o mensaje de manera diferente.\nEn Python, el polimorfismo se manifiesta de varias maneras:\n\nCon funciones\nCon m√©todos\nCon sobrecarga de operadores\nCon herencia"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#polimorfismo-con-funciones",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#polimorfismo-con-funciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "2.2 1. Polimorfismo con funciones",
    "text": "2.2 1. Polimorfismo con funciones\n\nSe puede utilizar polimorfismo en funciones que aceptan argumentos de tipos diferentes y act√∫an en consecuencia.\nEjemplo 1:\n\n    def sumar(a, b):\n        return a + b\n\n    print(sumar(5, 10))      # Imprime: 15\n    print(sumar(\"Hola\", \" Mundo\"))  # Imprime: Hola Mundo\n\nEjemplo 2:\n\n    # Devuelve la longitud de una cadena o una lista.\n    def obtener_longitud(elemento):\n        return len(elemento)\n\n    cadena = \"Hola, mundo\"\n    lista = [1, 2, 3, 4, 5]\n    longitud_cadena = obtener_longitud(cadena)\n    longitud_lista = obtener_longitud(lista)\n\n    print(f\"Longitud de la cadena: {longitud_cadena}\") # Imprime 11\n    print(f\"Longitud de la lista: {longitud_lista}\") # Imprime 5"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#polimorfismo-con-m√©todos",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#polimorfismo-con-m√©todos",
    "title": "Programaci√≥n Aplicada II",
    "section": "2.3 2. Polimorfismo con m√©todos",
    "text": "2.3 2. Polimorfismo con m√©todos\n\nUna clase puede implementar un m√©todo con el mismo nombre que otra clase, pero con un comportamiento diferente.\nEsto permite que objetos de distintas clases respondan a la misma llamada de m√©todo de manera diferente.\nEjemplo:\n\n    class Perro:\n        def sonido(self):\n            return \"Guau\"\n\n    class Gato:\n        def sonido(self):\n            return \"Miau\"\n\n    def hablar(animal):\n        return animal.sonido()\n\n    perro = Perro()\n    gato = Gato()\n\n    print(hablar(perro))  # Imprime: Guau\n    print(hablar(gato))   # Imprime: Miau"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#sobrecarga-de-operadores",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#sobrecarga-de-operadores",
    "title": "Programaci√≥n Aplicada II",
    "section": "2.4 3. Sobrecarga de operadores",
    "text": "2.4 3. Sobrecarga de operadores\n\nEs una forma de polimorfismo que permite a los objetos responder a operadores de manera diferente seg√∫n el contexto.\nLa acci√≥n de sobrecargar operadores se refiere a la implementaci√≥n de m√©todos especiales en las clases que creamos, conocidos como m√©todos m√°gicos o m√©todos dunder.\n\nLos m√©todos m√°gicos o m√©todos dunder son m√©todos especiales que tienen nombres que comienzan y terminan con doble guion bajo. Estos m√©todos son utilizados para realizar operaciones espec√≠ficas en objetos y son invocados autom√°ticamente por Python en situaciones particulares.\n\n\n\n\n\n\n\n\nM√©todo\nDescripci√≥n\nEjemplo de Uso\n\n\n\n\n__str__(self)\nRepresentaci√≥n en cadena del objeto\nstr(obj), print(obj)\n\n\n__len__(self)\nDevuelve la longitud del objeto\nlen(obj)\n\n\n__add__(self, otro)\nSobrecarga del operador de suma (+)\nobj1 + obj2\n\n\n__sub__(self, otro)\nSobrecarga del operador de resta (-)\nobj1 - obj2\n\n\n__mul__(self, otro)\nSobrecarga del operador de multiplicaci√≥n (*)\nobj1 * obj2\n\n\n__truediv__(self, otro)\nSobrecarga del operador de divisi√≥n (/)\nobj1 / obj2\n\n\n__eq__(self, otro)\nSobrecarga del operador de igualdad (==)\nobj1 == obj2\n\n\n__ne__(self, otro)\nSobrecarga del operador de desigualdad (!=)\nobj1 != obj2\n\n\n\n\nEjemplo:\n\n\nclass Punto:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def __add__(self, otro_punto):\n        if isinstance(otro_punto, Punto):\n            # Sobrecarga del operador de suma para la clase Punto\n            return Punto(self.x + otro_punto.x, self.y + otro_punto.y)\n        else:\n            print(\"Se espera un objeto de la clase Punto\")\n            return None\n\n\npunto1 = Punto(1, 2)\npunto2 = Punto(3, 4)\n\n# Utilizando el polimorfismo con el m√©todo __str__\nprint(f\"Punto 1: {punto1}\")\nprint(f\"Punto 2: {punto2}\")\n\n# Utilizando el polimorfismo con el m√©todo __add__\nprint(f\"Punto 1 + Punto 2: {punto1+punto2}\")\n\nPunto 1: (1, 2)\nPunto 2: (3, 4)\nPunto 1 + Punto 2: (4, 6)"
  },
  {
    "objectID": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#polimorfismo-con-herencia",
    "href": "clases2025/clase04_encapsulamiento-y-polimorfismo.html#polimorfismo-con-herencia",
    "title": "Programaci√≥n Aplicada II",
    "section": "2.5 4. Polimorfismo con herencia",
    "text": "2.5 4. Polimorfismo con herencia\n‚Ä¶ coming soon.\n\nUna subclase puede heredar de una clase base y proporcionar su propia implementaci√≥n de los m√©todos de la clase base.\nEsto permite que los objetos de la subclase se utilicen de manera intercambiable con los objetos de la clase base.\n\n\n2.5.1 Ejercicio 8: Encapsulamiento y Polimorfismo con vectores y matrices\nEn este ejercicio, aplicaremos los conceptos de encapsulamiento y polimorfismo en las clases Vector y Matriz. Aseg√∫rate de seguir las siguientes instrucciones:\n\n2.5.1.1 Parte 1: Encapsulamiento\n\nClase Vector:\n\nCrea los atributos elementos, dimension, y total_vectores como atributos privados.\nImplementa m√©todos getter y setter para obtener/modificar los valores de estos atributos desde fuera de la clase.\n\nClase Matriz:\n\nCrea los atributos elementos, filas, columnas y total_matrices como atributos privados.\nImplementa m√©todos getter y setter para obtener/modificar los valores de estos atributos desde fuera de la clase.\n\n\n\n\n2.5.1.2 Parte 2: Polimorfismo\n\nClase Vector:\n\nCambia el m√©todo suma por el m√©todo __add__ en la clase Vector para permitir la suma de dos vectores utilizando el operador +. Aseg√∫rate de manejar adecuadamente el caso cuando los vectores no tienen la misma dimensi√≥n.\nImplementa un m√©todo llamado __mul__ que acepte un escalar como argumento y devuelva un nuevo vector que sea el resultado de multiplicar cada elemento del vector por ese escalar.\nImplementa el m√©todo __str__ para que al imprimir un objeto de la clase Vector se muestre de forma amigable.\n\nClase Matriz:\n\nCambia el m√©todo suma por __add__ en la clase Matriz para permitir la suma de dos matrices utilizando el operador +. Aseg√∫rate de manejar adecuadamente el caso cuando las matrices no tienen las mismas dimensiones.\nImplementa el m√©todo __mul__ en la clase Matriz que acepte un escalar como argumento y devuelva una nueva matriz que sea el resultado de multiplicar cada elemento de la matriz por ese escalar.\nImplementa el m√©todo __str__ para que al imprimir un objeto de la clase Matriz se muestre de forma amigable.\n\n\n\n\n2.5.1.3 Parte 3: Pruebas\n\nPruebas con Vectores:\n\nCrea instancias de la clase Vector y realiza pruebas para asegurarte de que el encapsulamiento funcione correctamente. Utiliza los m√©todos getter y setter para obtener/modificar informaci√≥n sobre los vectores.\nRealiza pruebas utilizando el polimorfismo, sumando y multiplicando vectores, y verifica los resultados.\n\nPruebas con Matrices:\n\nCrea instancias de la clase Matriz y realiza pruebas para asegurarte de que el encapsulamiento funcione correctamente. Utiliza los m√©todos getter y setter para obtener/modificar informaci√≥n sobre las matrices.\nRealiza pruebas utilizando el polimorfismo, sumando y multiplicando matrices, y verifica los resultados.\n\n\n\n\n2.5.1.4 Consideraciones\n\nAseg√∫rate de proporcionar mensajes de error apropiados en caso de que las operaciones no sean v√°lidas debido a dimensiones incorrectas, etc.\nSube los archivos generados en este ejercicio con el prefijo E05_NombreApellido. La parte de c√≥digo debe entregarse en un archivo con extensi√≥n .py.\nNo se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc.\nEn caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° la tarea con una deducci√≥n de hasta 50pts, dependiendo de la gravedad del error.\nEn caso de que la/el estudiante utilice c√≥digo o funciones no vistas en clase, deber√° ser capaz de respaldar su c√≥digo mediante una explicaci√≥n verbal y/o escrita, en caso de que le sea requerida por la docente de la asignatura. De no cumplir con la explicaci√≥n de forma satisfactoria, se anular√° su trabajo y se pasar√° el reporte a la coordinaci√≥n de la carrera."
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html",
    "href": "clases2025/clase02_repaso-python.html",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\nImagen de programmerhumor.io"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#clase-02-repaso-de-python",
    "href": "clases2025/clase02_repaso-python.html#clase-02-repaso-de-python",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#temario",
    "href": "clases2025/clase02_repaso-python.html#temario",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.2 Temario",
    "text": "1.2 Temario"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#contenido",
    "href": "clases2025/clase02_repaso-python.html#contenido",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.3 Contenido",
    "text": "1.3 Contenido\n\n¬øPor qu√© aprender Python?\nConfiguraci√≥n\n\nVersi√≥n\nInstalaci√≥n\nEntorno de Desarrollo\n\nLo b√°sico de Python\n\nVariables y tipos de datos\nOperadores\nEntrada y salidad de datos\nEstructura condicional\nCiclos\nEstructura de un programa\n\nEjercicios"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#por-qu√©-aprender-python",
    "href": "clases2025/clase02_repaso-python.html#por-qu√©-aprender-python",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.4 ¬øPor qu√© aprender Python?",
    "text": "1.4 ¬øPor qu√© aprender Python?\n\nEs muy sencillo de utilizar y f√°cil de aprender (en comparaci√≥n con otros lenguajes).\n\n\nImagen obtenida de megratrend.com\n\nEs muy vers√°til, y bastante popular en los √∫ltimos a√±os.\n\n\nImagen obtenida de cdn.hackr.io\n\nEs utilizado para c√≥mputo cient√≠fico y como una herramienta de ense√±anza en muchos cursos universitarios.\n\n\nImagen obtenida de cacm.acm.org\nVer tambi√©n github.blog \nVer tambi√©n entrevista de Lex Fridman a Chris Lattner"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#configuraci√≥n",
    "href": "clases2025/clase02_repaso-python.html#configuraci√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.5 Configuraci√≥n",
    "text": "1.5 Configuraci√≥n"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#versi√≥n",
    "href": "clases2025/clase02_repaso-python.html#versi√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.6 Versi√≥n",
    "text": "1.6 Versi√≥n\n\nUtilizaremos Python 3.x, que ya debe estar instalado en las computadoras de esta aula a trav√©s de Anaconda (por favor verifiquen en sus computadoras que pueden iniciar la aplicaci√≥n Anaconda Navigator)."
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#instalaci√≥n",
    "href": "clases2025/clase02_repaso-python.html#instalaci√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.7 Instalaci√≥n",
    "text": "1.7 Instalaci√≥n\n\nAunque una gran parte del trabajo del curso ser√° realizada durante la hora de la clase, es muy recomendable que instalen Python en sus computadoras personales, pues hay tareas y proyectos para realizar en casa.\nUna manera f√°cil de realizar la instalaci√≥n es usar el gestor de paquetes/entornos virtuales de Python Anaconda:\n\nDescargar y ejecutar el instalador de: https://www.anaconda.com/download/\nDisponible para Windows, Linux, MacOS\nPuede crear y manejar diferentes ambientes virtuales."
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#entornos-de-desarrollo",
    "href": "clases2025/clase02_repaso-python.html#entornos-de-desarrollo",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.8 Entornos de Desarrollo",
    "text": "1.8 Entornos de Desarrollo\n\nRecordatorio: Un entorno de desarrollo (IDE, Integrated Development Environment) es una herramienta que proporciona un conjunto integrado de caracter√≠sticas para facilitar la creaci√≥n, prueba y depuraci√≥n de software.\nPara Python, algunos IDEs populares son PyCharm, Spyder y Visual Studio Code. Cada estudiante es libre de seleccionar su IDE preferido, los ejercicios y tareas se entregaran en archivos con extensi√≥n .py.\nPara los ejemplos de clase se utilizar√° Spyder o el IDE disponible en ese momento.\n\n\nTUTORIALES:\n\n\nInstala Anaconda en Windows 11 (o Mac o Linux)\nInstalar PyCharm con PyCharm\nInstalar Python con Spyder\nInstalar Python con VSCode\n\n\nDATO COMPLEMENTARIO:\n\n\nUn entorno (o ambiente) virtual de Python es una herramienta que ayuda a gestionar las dependencias y las versiones de los paquetes de Python para un proyecto espec√≠fico.\nEn lugar de instalar paquetes de Python directamente en el sistema global de Python, puedes crear entornos virtuales separados para cada proyecto.\nCada entorno virtual tiene su propio directorio de instalaci√≥n de paquetes y su propio int√©rprete de Python, lo que permite que los proyectos tengan dependencias espec√≠ficas sin interferir entre s√≠."
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#lo-b√°sico-de-python",
    "href": "clases2025/clase02_repaso-python.html#lo-b√°sico-de-python",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.9 Lo b√°sico de Python",
    "text": "1.9 Lo b√°sico de Python"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#variable",
    "href": "clases2025/clase02_repaso-python.html#variable",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.10 Variable",
    "text": "1.10 Variable\n\nDefinici√≥n:\n\n\nEs un espacio de almacenamiento nombrado que contiene un valor.\nSe utiliza para representar informaci√≥n que puede cambiar durante la ejecuci√≥n del programa.\n\n\nComponentes\n\n\nIdentificador: Es el nombre dado a la variable para referirse a ella en el c√≥digo.\nValor: Es el contenido almacenado en la variable, que puede ser de diversos tipos.\nTipo: Define la naturaleza del dato que la variable puede almacenar (e.g., entero, flotante, cadena, booleano).\n\n\nTipos de datos\n\n\nTipos de datos num√©ricos:\n\nüî¥ int: n√∫meros enteros.\nüîµfloat: n√∫meros de punto flotante.\nüü£bool: valores booleanos (True o False).\n\nTipos de datos de secuencia:\n\nüü® Listas: Colecci√≥n mutable y ordenada de elementos.\nüüß Tuplas: Colecci√≥n inmutable y ordenada de elementos.\nüü´Cadenas: Secuencia inmutable de caracteres.\n\nTipos de datos de mapeo:\n\nüîº Diccionarios: Colecci√≥n no ordenada de pares clave-valor.\n\nNone:\n\nüîªEs un valor especial en Python que representa la ausencia de un valor o un objeto nulo."
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#enteros-int",
    "href": "clases2025/clase02_repaso-python.html#enteros-int",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.11 üî¥ Enteros (int)",
    "text": "1.11 üî¥ Enteros (int)\n\nLos enteros son un tipo de dato que permite representar n√∫meros enteros, positivos o negativos, sin decimales.\nSistemas de numeraci√≥n:\n\nBinario: Prefijo 0b (ej., 0b101).\nHexadecimal: Prefijo 0x (ej., 0xA1).\nOctal: Prefijo 0o (ej., 0o17).\nAl imprimir, el n√∫mero se convierte a decimal.\n\n\n\nnum_decimal = 42\nnum_binario = 0b101\nnum_hexadecimal = 0xA1\nnum_octal = 0o17\n\nprint(num_decimal, num_binario, num_hexadecimal, num_octal)  # Esto imprime: 42 5 161 15\n\nüìå Recordatorio: - Python asigna bits seg√∫n el valor del n√∫mero. Puedes usar sys.getsizeof() para conocer el tama√±o en memoria. - Puedes convertir otros tipos a int. Los decimales se truncan al convertir a int.\n\n# ¬øCu√°l es la salida de este c√≥digo?\n\nimport sys\n\nnum = 4\nprint(sys.getsizeof(num))  \n\nnum_decimal = 3.7\nnum_entero = int(num_decimal)\nprint(num_entero)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#flotantes-float",
    "href": "clases2025/clase02_repaso-python.html#flotantes-float",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.12 üîµ Flotantes (float)",
    "text": "1.12 üîµ Flotantes (float)\n\nRepresentan n√∫meros positivos o negativos con decimales.\nNo tienen precisi√≥n infinita. Los valores m√°ximos y m√≠nimos est√°n definidos por el sistema, aunque podemos hacer una representaci√≥n simb√≥lica del n√∫mero infinito y NaN.\n\n\n# Float\nnum1 = 3.14159\nprint(num1, type(num1))\n\n# Infinito y NaN\nnum_infinito = float('inf')\nnum_nan = float('nan')\nprint(num_infinito, num_nan)\n\n# M√≠nimo y m√°ximo\nimport sys\nprint(\"Valor m√≠nimo\", sys.float_info.min)\nprint(\"Valor m√°ximo\", sys.float_info.max)\n\n# ¬øCu√°l es el resultado de esta operaci√≥n?\nnum2 = 1-2.2250738585072014e-308\nprint(num2)\n\n3.14159 &lt;class 'float'&gt;\ninf nan\nValor m√≠nimo 2.2250738585072014e-308\nValor m√°ximo 1.7976931348623157e+308\n1.0\n\n\nüìå Recordatorio: - Podemos indicar n√∫meros flotantes mediante notaci√≥n cient√≠fica, usamos e para indicar el exponente. - Podemos convertir otros tipos a float usando float().\n\nnum3 = 1.2e3  # Notaci√≥n cient√≠fica (1200.0)\nprint(num3)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#booleanos-bool",
    "href": "clases2025/clase02_repaso-python.html#booleanos-bool",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.13 üü£ Booleanos (bool)",
    "text": "1.13 üü£ Booleanos (bool)\n\nTipo de dato que almacena True o False.\nSe utiliza con operadores como &gt;, &lt;, ==, que devuelven valores booleanos.\nPodemos convertir valores a bool usando bool().\n\n\nvalor1 = True\nvalor2 = (5 &gt; 3)  # True\nvalor3 = bool(0)   # False\nvalor4 = bool(1)   # True\nprint(valor1, valor2, valor3, valor4)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#listas-list",
    "href": "clases2025/clase02_repaso-python.html#listas-list",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.14 üü® Listas (list)",
    "text": "1.14 üü® Listas (list)\n\nEstructura de datos mutable y din√°mica.\nPropiedades:\n\nOrdenadas.\nContienen tipos arbitrarios.\nSe crean e indexan con [].\nPueden anidarse.\n\n\n\nmi_lista = [1, 2, 3, \"Python\", [5, 6]]\nprint(mi_lista[0])      # Salida? \nprint(mi_lista[-1])     # Salida?\nmi_lista[1] = \"Nuevo\"\nprint(mi_lista)         # Salida?\n\nüìå Recordatorio: - M√©todos comunes de las listas: - append(valor): Agrega elemento al final. - extend(iterable): Agrega elementos de un iterable. - insert(pos, valor): Inserta en una posici√≥n. - pop(indice): Elimina y devuelve el elemento en el √≠ndice (por defecto el √∫ltimo). - remove(valor): Elimina la primera aparici√≥n del valor. - reverse(): Invierte el orden. - sort(): Ordena la lista.\n\nmi_lista2 = [3, 1, 4]\nmi_lista2.append(5)\nmi_lista2.sort()\nprint(mi_lista2)  # Salida?"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#tuplas-tuple",
    "href": "clases2025/clase02_repaso-python.html#tuplas-tuple",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.15 üüß Tuplas (tuple)",
    "text": "1.15 üüß Tuplas (tuple)\n\nEstructura de datos inmutable. Una vez que una tupla ha sido creada, sus elementos no pueden ser modificados.\nPropiedades:\n\nInmutables.\nOrdenadas.\nContienen tipos arbitrarios.\nSe crean con (), se indexan con [].\nPueden anidarse.\nPueden contener duplicados.\n\n\n\nmi_tupla = (10, 20, 30, 40)\nprint(mi_tupla[0])  # Imprime: 10\nprint(mi_tupla[-1])  # Imprime: 40\n\nmi_tupla2 = (1, 2, 3)\na, b, c = mi_tupla2\nprint(a, b, c)  # Imprime: 1 2 3\n\nes_tupla = (5)  # ¬øEsto es una tupla?\n\nüìå Recordatorio: - M√©todos comunes de las tuplas: - count(): Cuenta cu√°ntas veces aparece un elemento. - index(): Devuelve el √≠ndice de la primera ocurrencia de un elemento.\n\nEn todos los iterables (listas, tuplas, cadenas, diccionarios), podemos verificar la existencia de un elemento dentro del iterable.\n\n\nmi_tupla3 = (1, 2, 3, 1, 2, 1)\nprint(mi_tupla3.count(1))  # Imprime: 3\nprint(mi_tupla3.index(2))  # Imprime: 1\n\n\nmi_tupla4 = (\"rojo\", \"azul\", \"verde\")\nprint(\"rojo\" in mi_tupla4)  # Imprime: True"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#cadenas-str",
    "href": "clases2025/clase02_repaso-python.html#cadenas-str",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.16 üü´ Cadenas (str)",
    "text": "1.16 üü´ Cadenas (str)\n\nTipo inmutable que almacena secuencias de caracteres.\nSe usan comillas simples o dobles. \nFunciones y operaciones comunes:\n\nConcatenaci√≥n.\nRepetici√≥n.\nLongitud.\nIndexaci√≥n y slicing.\n\n\n\ntexto = \"Hola, Python!\"\nprint(texto[0])      # Salida?\nprint(len(texto))    # Salida?\nprint(texto[7:])     # Salida?\nprint(texto * 3)     # Salida?"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#diccionarios-dict",
    "href": "clases2025/clase02_repaso-python.html#diccionarios-dict",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.17 üîº Diccionarios (dict)",
    "text": "1.17 üîº Diccionarios (dict)\n\nSon estructuras de datos que almacenan pares de clave-valor.\nLas claves deben ser √∫nicas e inmutables (pueden ser cadenas, n√∫meros o tuplas).\n\nSe crean con llaves {}. \nPropiedades:\n\nNo ordenados** (antes de Python 3.7). Desde Python 3.7, mantienen el orden de inserci√≥n.\n\nAcceso r√°pido a los valores usando las claves.\n\nMutables.\n\n\n\nalumno = {\n    \"nombre\": \"Ana\",\n    \"edad\": 21,\n    \"carrera\": \"Ingenier√≠a en IA\"\n}\n\nprint(alumno[\"nombre\"])  # Salida: \"Ana\"\nalumno[\"promedio\"] = 9.5  # Agregar nueva clave\nalumno[\"edad\"] = 22       # Modificar valor\nprint(alumno)\n\nüìå Recordatorio: - M√©todos comunes de los diccionarios: - keys(): Devuelve las claves.\n- values(): Devuelve los valores.\n- items(): Devuelve los pares clave-valor como tuplas.\n- get(): Accede a un valor de forma segura (sin causar error si la clave no existe).\n- del: Elimina una clave y su valor.\n- pop(): Elimina una clave y devuelve su valor.\n- Tambi√©n podemos iterar sobre un diccionario: - Claves: for clave in diccionario.\n- Valores: for valor in diccionario.values().\n- Pares clave-valor: for clave, valor in diccionario.items().\n\ndel alumno[\"carrera\"]\npromedio = alumno.pop(\"promedio\")\nprint(alumno)  # Salida: {\"nombre\": \"Ana\", \"edad\": 22}\nprint(alumno.keys())      # Salida: dict_keys([\"nombre\", \"edad\"])\nprint(alumno.get(\"edad\")) # Salida: 22\n\n\nfor clave, valor in alumno.items():\n       print(f\"{clave}: {valor}\") # Salida?"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#preguntas",
    "href": "clases2025/clase02_repaso-python.html#preguntas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.18 Preguntas",
    "text": "1.18 Preguntas\n¬øQu√© tipo de variable es?\nnombre = \"Juan\"\n¬øQu√© tipo de variable es?\nes_mayor_de_edad = True\n¬øQu√© tipo de variable es?\nprecio = 45.99\n¬øQu√© tipo de variable es?\nnumeros = [1, 2, 3, 4, 5]\n¬øC√≥mo imprimir√≠as el tercer elemento de la lista numeros?\n¬øC√≥mo se podr√≠a modificar el contenido de la lista numeros?\n¬øQu√© tipo de variable es?\nestudiantes = {\"001\": \"Ana\", \"002\": \"Carlos\"}\n¬øQu√© error podr√≠as encontrar al intentar acceder a una clave que no existe en un diccionario?\n¬øQu√© tipo de variable es?\nedad = 25\n¬øQu√© sucede si intentas sumar un n√∫mero entero con una cadena?\n¬øQu√© tipo de variable es?\nvalor = None\n¬øC√≥mo puedes comprobar si una variable contiene un valor nulo en Python?\n¬øQu√© tipo de variable es?\ncolores = (\"rojo\", \"verde\", \"azul\")\n¬øQu√© ocurre si intentas modificar una tupla despu√©s de haberla creado?"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#operadores",
    "href": "clases2025/clase02_repaso-python.html#operadores",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.19 Operadores",
    "text": "1.19 Operadores\n\nDefinici√≥n:\n\n\nSon s√≠mbolos especiales que realizan operaciones en uno o m√°s operandos. Los operandos pueden ser variables, valores o expresiones.\n\n\nTipos de Operadores:\n\n\nAritm√©ticos: Realizan operaciones matem√°ticas.\n\n+ (suma), - (resta), * (multiplicaci√≥n), / (divisi√≥n), // (divisi√≥n entera), % (m√≥dulo o residuo), ** (exponenciaci√≥n).\nEjemplos:\n\na = 10\nb = 3\nsuma = a + b\nresta = a - b\nmultiplicacion = a * b\ndivision = a / b\ndivision_entera = a // b\nmodulo = a % b\nexponenciacion = a ** b\nDe Asignaci√≥n: Asignan valores a variables.\n\n= (asignaci√≥n simple), += (suma y asignaci√≥n), -= (resta y asignaci√≥n), *= (multiplicaci√≥n y asignaci√≥n), /= (divisi√≥n y asignaci√≥n), //= (divisi√≥n entera y asignaci√≥n), %=(m√≥dulo y asignaci√≥n), **=(exponenciaci√≥n y asignaci√≥n).\nEjemplo:\n\nx = 5\nx += 3  # Equivalente a x = x + 3\nRelacionales: Comparan valores y devuelven un resultado booleano.\n\n== (igual a), != (no igual a), &lt; (menor que), &gt; (mayor que), &lt;= (menor o igual a), &gt;= (mayor o igual a).\nEjemplo:\n\na = 10\nb = 3\nresultado = (a &gt; b)  # True, ya que 10 es mayor que 3\nL√≥gicos: Realizan operaciones l√≥gicas en valores booleanos.\n\nand (y l√≥gico), or (o l√≥gico), not (no l√≥gico).\nEjemplos:\n\na = 10\nb = 3\ncondicion1 = (a &gt; b) and (b != 0)  # True, ambas condiciones son verdaderas\ncondicion2 = (a &lt; b) or (b == 0)   # False, ninguna condici√≥n es verdadera\nDe Membres√≠a: Verifican si un valor est√° presente en una secuencia.\n\nin (est√° en), not in (no est√° en).\nEjemplos:\n\nlista = [1, 2, 3, 4, 5]\npertenece = 3 in lista  # True, ya que 3 est√° en la lista\nno_pertenece = 6 not in lista  # True, ya que 6 no est√° en la lista\nDe Identidad: Verifican si dos variables se refieren al mismo objeto en la memoria.\n\nis (es), is not (no es).\nEjemplos: ```python a = [1, 2, 3] b = a # b ahora apunta al mismo objeto que a c = [1, 2, 3] # un nuevo objeto con el mismo contenido que a\n\n\nprint(a is b) # True, ya que b apunta al mismo objeto que a print(a is c) # False, ya que c es un objeto diferente con el mismo contenido que a print(a is not c) # True, ya que a y c no apuntan al mismo objeto\n\n## Ejemplos / Preguntas\n\n\n**¬øCu√°l es la diferencia entre `=` y `==`?**\n\n**Sin usar calculadora ni Python, ¬øCu√°l es el resultado de la expresi√≥n `(5 + 3) * 2 / 4`?**\n\n\n**Dado el c√≥digo `x += 2`, ¬øcu√°l es el valor final de la variable `x` si su valor inicial es 7?**\n\n\n**¬øC√≥mo podr√≠as verificar si un n√∫mero es par utilizando operadores relacionales y aritm√©ticos?**\n\n\n**Si tienes una lista `numeros = [1, 2, 3, 4, 5]`, ¬øc√≥mo verificar√≠as si el n√∫mero 6 est√° presente en la lista?**\n\n\n**¬øC√≥mo utilizar√≠as el operador ` ** ` para calcular la ra√≠z cuadrada de un n√∫mero?**\n\n\n**¬øQu√© sucede si intentas realizar una divisi√≥n entre cero en Python?**\n\n\n**Dado un diccionario `persona = {\"nombre\": \"Juan\", \"edad\": 25}`, ¬øc√≥mo verificar√≠as si la clave \"edad\" est√° presente?**\n\n**¬øCu√°l es la diferencia entre `is` y `==`?**\n\n## Entrada y salida de datos\n\n## Entrada y salida de Datos\n\n&lt;h3 style=\"background-color:#E1F25C; margin-left:auto; margin-right:auto; width: 100%;\"&gt;Entrada de Datos&lt;/h3&gt;\n    \n- La funci√≥n `input()` se utiliza para obtener datos desde la entrada est√°ndar (generalmente el teclado) y asignarlos a variables. \n- La entrada se toma como una cadena (`str`), por lo que a menudo es necesario convertirla al tipo de dato adecuado.\n- Ejemplo:\n```python\nnombre = input(\"Ingrese su nombre: \")\nedad = int(input(\"Ingrese su edad: \"))  # Convertir la entrada a entero\n\nConversi√≥n de Tipos\n\n\nLa conversi√≥n de tipos, o type casting, se refiere a cambiar el tipo de dato de una variable a otro. Por ejemplo, convertir una cadena a un entero o viceversa.\nEjemplos:\n\n    edad = 25\n    edad_str = str(edad)  # Convertir entero a cadena\n\nSalida de Datos\n\n\nLa funci√≥n print() se utiliza para mostrar informaci√≥n en la salida est√°ndar (generalmente la consola).\nPuede imprimir valores de variables, texto y realizar formateo b√°sico.\nEjemplo:\n\n    nombre = \"Juan\"\n    edad = 30\n    print(\"Nombre:\", nombre, \"Edad:\", edad)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#ejemplos-preguntas",
    "href": "clases2025/clase02_repaso-python.html#ejemplos-preguntas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.20 Ejemplos / Preguntas",
    "text": "1.20 Ejemplos / Preguntas\n¬øCu√°l ser√° la salida si el usuario ingresa ‚Äú3‚Äù?\nx = input(\"Ingrese un n√∫mero: \")\ny = x * 2\nprint(y)\n¬øCu√°l ser√° la salida de este c√≥digo?\na = \"5\"\nb = int(a) + 2\nc = str(b)\nprint(a + c)\n¬øQu√© tipo de error obtendr√≠as al intentar ejecutar este c√≥digo? python    num_str = \"abc\"    num_int = int(num_str)\n¬øCu√°l ser√° el error en este c√≥digo y c√≥mo lo corregir√≠as? python    edad = 25    print(\"Mi edad es: \" + edad)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#flujo-de-ejecuci√≥n",
    "href": "clases2025/clase02_repaso-python.html#flujo-de-ejecuci√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.21 Flujo de ejecuci√≥n",
    "text": "1.21 Flujo de ejecuci√≥n\n\nFlujo Secuencial:\n\n\nImplica ejecutar las instrucciones en orden, una tras otra.\nEjemplo:\n\nprint(\"Inicio del programa\")\nedad = 20\nprint(\"La edad es:\", edad)\nprint(\"Fin del programa\")\n\nEstructuras Condicionales (if, elif, else):\n\n\nPermiten ejecutar bloques de c√≥digo dependiendo si una condici√≥n es verdadera o falsa.\n\nEstructura if: Ejecuta el bloque de c√≥digo dentro del if si la condici√≥n es verdadera. - Sintaxis:\nif condici√≥n:\n\nEjemplo:\n\nedad = 20\nif edad &gt;= 18:\n   print(\"Eres mayor de edad.\")\nEstructura elif: Se utiliza para evaluar condiciones adicionales si la condici√≥n del if no se cumple. - Sintaxis:\nelif condici√≥n:\n\nEjemplo:\n\ntemperatura = 25\nif temperatura &gt; 30:\n   print(\"Hace mucho calor.\")\nelif temperatura &gt; 20:\n   print(\"La temperatura es agradable.\")\nEstructura else: Proporciona un bloque de c√≥digo que se ejecuta si ninguna de las condiciones anteriores es verdadera. - Sintaxis:\nelse:\n\nEjemplo:\n\nedad = 15\nif edad &gt;= 18:\n    print(\"Eres mayor de edad.\")\nelse:\n    print(\"Eres menor de edad.\")"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#ejemplos-preguntas-1",
    "href": "clases2025/clase02_repaso-python.html#ejemplos-preguntas-1",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.22 Ejemplos / Preguntas",
    "text": "1.22 Ejemplos / Preguntas\n¬øCu√°l ser√° la salida de este c√≥digo?\nx = 10\nif x &gt; 5:\n    print(\"A\")\nelif x &lt; 15:\n    print(\"B\")\nelse:\n    print(\"C\")\n¬øCu√°l es el error y c√≥mo se puede corregir? python    if x &gt; 10        print(\"Mayor que 10\")\n\nEstructuras de Iteraci√≥n/Ciclos (for, while):\n\n\nPermiten repetir bloques de c√≥digo mientras se cumpla una condici√≥n.\n\n\nCiclo for:\n\nSintaxis:\n\n     for variable in iterable:\n\nFunci√≥n: Obtiene los elementos de un iterable (como una lista) y ejecuta el bloque de c√≥digo en cada iteraci√≥n.\nEjemplo:\nfrutas = [\"manzana\", \"banana\", \"cereza\"]\nfor fruta in frutas:\n    print(fruta)\n\nCiclo while:\n\nSintaxis:\n\n     while condici√≥n:\n\nFunci√≥n: Ejecuta el bloque de c√≥digo mientras la condici√≥n sea verdadera.\nEjemplo:\ncontador = 0\nwhile contador &lt; 5:\n    print(contador)\n    contador += 1"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#ejemplos-preguntas-2",
    "href": "clases2025/clase02_repaso-python.html#ejemplos-preguntas-2",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.23 Ejemplos / Preguntas",
    "text": "1.23 Ejemplos / Preguntas\n¬øQu√© valores imprimir√° este ciclo? python    for i in range(2, 5):        print(i)\n¬øCu√°l es el error y c√≥mo se puede corregir? python    while True        print(\"Instrucci√≥n dentro de un ciclo\")\n¬øQu√© diferencia hay entre while y for en t√©rminos de su comportamiento?\n¬øPuedes modificar el ejemplo del bucle for para imprimir las frutas en may√∫sculas?\nfrutas = [\"manzana\", \"banana\", \"cereza\"]\nfor fruta in frutas:\n    print(fruta)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#funciones",
    "href": "clases2025/clase02_repaso-python.html#funciones",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.24 Funciones",
    "text": "1.24 Funciones"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#funciones-definidas-por-el-programador",
    "href": "clases2025/clase02_repaso-python.html#funciones-definidas-por-el-programador",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.25 Funciones definidas por el programador",
    "text": "1.25 Funciones definidas por el programador\n\nSon bloques de c√≥digo reutilizables dise√±ados para realizar una tarea espec√≠fica.\nSe definen utilizando la palabra clave def seguida del nombre de la funci√≥n y par√©ntesis que pueden contener par√°metros.\nSintaxis:\n\ndef nombre_de_funcion(parametro1, parametro2, ...):\n    # Cuerpo de la funci√≥n\n    # Realizar operaciones\n    return resultado  # Opcional, devuelve un valor\nEjemplos:\n\n\nFunci√≥n simple sin par√°metros ni valor de retorno:\n\n\ndef saludar():\n    print(\"¬°Hola, mundo!\")\n\nsaludar()  # Llamada a la funci√≥n\n\n\nFunci√≥n con par√°metros y valor de retorno:\n\n\ndef suma(a, b):\n    resultado = a + b\n    return resultado\n\nresultado_suma = suma(3, 4)\nprint(resultado_suma)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#ejemplos-preguntas-3",
    "href": "clases2025/clase02_repaso-python.html#ejemplos-preguntas-3",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.26 Ejemplos / Preguntas",
    "text": "1.26 Ejemplos / Preguntas\n¬øC√≥mo creamos una funci√≥n que tome dos n√∫meros como par√°metros y devuelva su multiplicaci√≥n?\n¬øC√≥mo dise√±amos una funci√≥n que determine si un n√∫mero dado es par o impar?\nDado el siguiente c√≥digo, ¬øpuedes identificar el error y corregirlo?\n\ndef cuadrado(x):\n    resultado = x * x\n    print(result)\n\ncuadrado(5)\n\nAnaliza el siguiente fragmento de c√≥digo. ¬øCu√°l ser√° la salida cuando se llame a la funci√≥n imprimir_mensaje con el argumento ‚ÄúPython‚Äù?\n\ndef imprimir_mensaje(nombre):\n    print(\"Hola, \" + nombre + \"!\")\n    \nimprimir_mensaje(\"Python\")\n\nEncuentra el error en la siguiente funci√≥n que deber√≠a devolver el doble de un n√∫mero.\n\ndef doble(numero)\n    resultado = 2 * numero\n    return resultado\n\n¬øCu√°l es la diferencia entre par√°metros y argumentos en una funci√≥n?\nDefine una funci√≥n que reciba una lista y devuelva la suma de sus elementos.\nEscribe una funci√≥n que calcule el factorial de un n√∫mero."
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#estructura-de-un-programa",
    "href": "clases2025/clase02_repaso-python.html#estructura-de-un-programa",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.27 Estructura de un Programa",
    "text": "1.27 Estructura de un Programa\n\n\nComentario:\n\nEs una porci√≥n de texto que se incluye en el c√≥digo pero que no afecta la ejecuci√≥n del programa.\nSirve para proporcionar explicaciones, aclaraciones o notas dentro del c√≥digo, facilitando la comprensi√≥n del mismo.\nEjemplo 1:\n\n# Este es un comentario de una sola linea\n\nEjemplo 2 :\n\n\"\"\" Este comentario\nabarca m√°s de una l√≠nea\n\"\"\"\nSentencia:\n\nEs una instrucci√≥n que realiza una acci√≥n espec√≠fica. Puede ser una asignaci√≥n, una expresi√≥n, una instrucci√≥n de control de flujo (como if, for, while), entre otras.\nEjemplo: Sentencia de asignaci√≥n.\n\nx = 10\nIndentaci√≥n:\n\nSe refiere a la sangr√≠a (espacios o tabulaciones al principio de una l√≠nea) que se utiliza para indicar la estructura del c√≥digo.\nLa indentaci√≥n se utiliza en lugar de llaves u otros delimitadores y es crucial para definir bloques de c√≥digo.\nEjemplo:\nif x &gt; 0:\n    print(f\"{x} es positivo\")\n\nFunci√≥n y llamada a funci√≥n:\n\nFunci√≥n:\n\nEs un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. Puede aceptar par√°metros y devolver un valor.\nEjemplo:\ndef suma(a, b):\n    return a + b\n\nLlamada a funci√≥n:\n\nEs el acto de ejecutar o invocar una funci√≥n previamente definida. Se realiza indicando el nombre de la funci√≥n seguido de par√©ntesis que pueden contener argumentos.\nEjemplo: resultado = suma(3, 5) invoca la funci√≥n suma con argumentos 3 y 5.\n\n\nExpresi√≥n:\n\nEs una combinaci√≥n de valores, variables, operadores y llamadas a funciones que da como resultado un valor. Puede ser utilizada en asignaciones, impresiones, c√°lculos, etc.\nEjemplo: 3 + 5 es una expresi√≥n que eval√∫a a 8.\n\nBloque:\n\nEs un conjunto de sentencias o expresiones que est√°n agrupadas y forman una unidad l√≥gica. La indentaci√≥n se utiliza para definir bloques.\nEjemplo:\nif x &gt; 0:\n    print(\"x es positivo\")\n    resultado = x * 2\n    print(\"El doble de x es:\", resultado)"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#ejercicios",
    "href": "clases2025/clase02_repaso-python.html#ejercicios",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.28 Ejercicios",
    "text": "1.28 Ejercicios\nDos gatos y un rat√≥n\n\nDos gatos y un rat√≥n se encuentran en varias posiciones sobre una l√≠nea.\nComo valor de entrada, solicita al usuario sus posiciones iniciales.\nTu tarea es determinar cu√°l gato alcanzar√° al rat√≥n primero, asumiendo que el rat√≥n no se mueve y ambos gatos se mueven a la misma velocidad.\nOJO: Si ambos gatos llegan al mismo tiempo, el rat√≥n podr√° escapar mientras que los dos gatos pelean.\nEntrada\nSolicita como valores de entrada tres enteros, los cuales representan respectivamente las posiciones del gato \\(A\\), del gato \\(B\\) y del rat√≥n \\(C\\). Puedes suponer que \\(1\\leq A, B, C\\leq 100\\).\nSalida\n\nSi el gato A alcanza primero al rat√≥n, imprime como salida ‚Äúgato A‚Äù.\nSi el gato B alcanza primero al rat√≥n, imprime como salida ‚Äúgato B‚Äù.\nSi ambos gatos alcanzan al rat√≥n C al mismo tiempo, imprimir como salida ‚Äúraton C‚Äù.\n\n\nEjemplos\n\n\n\nEntrada\nSalida\n\n\n\n\n1 2 3\ngato B\n\n\n1 3 2\nraton C\n\n\n4 8 10\ngato B\n\n\n8 3 12\ngato A\n\n\n\nUna sumatoria muy extra√±a\n\nEscribe un programa que eval√∫e el valor de \\(\\sum_{i=m}^{n}\\) donde: \\[\n\\begin{eqnarray}\nm &=& \\sum_{i=1}^{a} i \\\\\nn &=& \\sum_{i=1}^{b} i\n\\end{eqnarray}\n\\] Entrada\n\nSolicita como valores de entrada dos enteros \\(a\\) y \\(b\\). Puedes suponer que \\(1\\leq a\\leq b \\leq 100\\)\n\nSalida\n\nUn entero que sea el valor de la f√≥rmula evaluada.\n\nEjemplo\n\n\n\n\nEntrada\nSalida\n\n\n\n\n3 5\n105\n\n\n\nUna serie poco interesante - La serie num√©rica 1,2,3,1,2,3,1‚Ä¶ es infinita pero no por eso deja de ser bastante aburrida. - Por ejemplo, es f√°cil darnos cuenta que despu√©s de un 1 siempre sigue un 2 y que antes de un 1 siempre hay un 3. - Si N es el n√∫mero actual de la serie, ¬øpodr√°s adivinar qu√© n√∫meros est√°n P posiciones antes y despu√©s de N?\nEntrada - Solicita como valores de entrada dos enteros \\(N\\) y \\(P\\). Puedes suponer que \\(1\\leq N\\leq3\\) y \\(0\\leq P\\leq10^9\\).\nSalida - Dos enteros separados por un espacio donde el primero sea el n√∫mero que est√° \\(P\\) posiciones antes de \\(N\\) y el segundo el que est√° \\(P\\) posiciones despu√©s.\nEjemplo\n\n\n\nEntrada\nSalida\n\n\n\n\n2 1\n1 3\n\n\n2 0\n2 2\n\n\n1 2\n2 3"
  },
  {
    "objectID": "clases2025/clase02_repaso-python.html#referencias",
    "href": "clases2025/clase02_repaso-python.html#referencias",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.29 Referencias",
    "text": "1.29 Referencias\nT√≠tulo: Computer Science with Python. (2020)\nAutor: Preeti Arora\nLink: Computer Science with Python\n\nT√≠tulo: Stanford CS224N Python Review.\nAutor: Stanford University Link: Stanford CS224N Python Review\n\nEjercicio 1: Dos gatos y un rat√≥n\nLink: Dos gatos y un rat√≥n\nEjercicio 2: Una sumatoria muy extra√±a Link: Una sumatoria muy extra√±a\nEjercicio 3: Una serie poco interesante\nLink: Una serie poco interesante\n\nimport os\nfrom pyhtml2pdf import converter\n\npath = os.path.abspath('clase02_repaso-python.html')\nprint(path)\nconverter.convert(f'file:///{path}', 'clase02_repaso-python.pdf')"
  },
  {
    "objectID": "clases/index.html",
    "href": "clases/index.html",
    "title": "Clases del curso",
    "section": "",
    "text": "Bienvenidos a la secci√≥n de clases. Aqu√≠ encontrar√°n el material actualizado cada semana."
  },
  {
    "objectID": "clases/index.html#listado-de-clases",
    "href": "clases/index.html#listado-de-clases",
    "title": "Clases del curso",
    "section": "1 Listado de clases",
    "text": "1 Listado de clases"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#fundamentos",
    "href": "clases/02_repaso-fundamentos.html#fundamentos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Fundamentos de programaci√≥n",
    "text": "Fundamentos de programaci√≥n\n\nImagen de programmerhumor.io"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ventajas-de-python",
    "href": "clases/02_repaso-fundamentos.html#ventajas-de-python",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ventajas de Python",
    "text": "Ventajas de Python\n\n\n\n\n\n\nImagen de megratrend.com\n\n\n\n\n\n\n\nImagen de github.blog\n\n\n\n\n\n\n\n\n\nImagen de instagram.com\n\n\n\n\n\n\nSintaxis clara y concisa.\nAmpliamente utilizado en la industria y academia.\nAmplia comunidad y ecosistema de bibliotecas.\nPortabilidad y versatilidad en m√∫ltiples dominios: desarrollo web, inteligencia artificial, an√°lisis de datos, automatizaci√≥n, etc.\n\nEn este curso se utilizar√° Python por su facilidad de aprendizaje y su aplicabilidad profesional."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#entorno-de-trabajo",
    "href": "clases/02_repaso-fundamentos.html#entorno-de-trabajo",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Entorno de Trabajo",
    "text": "Entorno de Trabajo\nEl entorno de trabajo adoptado en este curso ser√°:\n\nPython 3.9+\nLa distribuci√≥n Anaconda\nEl entorno de desarrollo Spyder, instalado en el ambiente base\n\n\n\n\n\n\n\nEn los equipos de la sala de c√≥mputo:\n\n\n\nAnaconda y Spyder est√°n instalados en el ambiente base.\nNo se cuenta con privilegios administrativos para instalar Spyder en nuevos ambientes.\nSin embargo, se requiere trabajar con ambientes virtuales separados por buenas pr√°cticas.\n\n\n\n\nPara conciliar ambos objetivos, se utilizar√° Spyder desde el ambiente base, pero configurado para ejecutar el c√≥digo en el int√©rprete de un entorno virtual independiente."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#editor-vs.-ide",
    "href": "clases/02_repaso-fundamentos.html#editor-vs.-ide",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Editor vs.¬†IDE",
    "text": "Editor vs.¬†IDE\n\nEditor de c√≥digo\nUn editor de c√≥digo es una herramienta de software utilizada para escribir y editar c√≥digo fuente.\nFuncionalidades comunes:\n\nColoreado de sintaxis\nAutocompletado\nIdentaci√≥n autom√°tica\n\nEjemplos: VSCode, Sublime Text, Notepad++\n\n\nEntorno de desarrollo (IDE)\nUn IDE es una plataforma que unifica m√∫ltiples herramientas necesarias para el desarrollo.\nComponentes comunes:\n\nEditor de c√≥digo y consola\nDepurador (debugger)\nExplorador de archivos\nVisualizador de variables\n\nEjemplos: Spyder, PyCharm, Thonny\nSpyder ser√° el IDE utilizado en este curso. Est√° orientado a desarrollo cient√≠fico y educativo, y forma parte de la distribuci√≥n Anaconda."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#anaconda",
    "href": "clases/02_repaso-fundamentos.html#anaconda",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Anaconda",
    "text": "Anaconda\nAnaconda es una distribuci√≥n de Python ampliamente utilizada que incluye:\n\nUn conjunto de bibliotecas preinstaladas.\nEntornos gr√°ficos para desarrollo (Spyder, Jupyter).\nconda, su propio gestor de paquetes.\nHerramientas para crear y gestionar entornos virtuales.\n\n\n\n\n\n\n\n¬øQu√© es un gestor de paquetes?\n\n\nEs una herramienta que permite instalar, actualizar y administrar bibliotecas y dependencias externas al lenguaje.\nNota: Mientras Anaconda usa conda, el gestor est√°ndar de Python es pip."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ambiente-virtual",
    "href": "clases/02_repaso-fundamentos.html#ambiente-virtual",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ambiente virtual",
    "text": "Ambiente virtual\nUn ambiente virtual es una instancia aislada del int√©rprete de Python y sus paquetes, utilizada para gestionar proyectos de manera independiente.\n¬øPor qu√© utilizarlos?\n\nEvita conflictos: Impide que las actualizaciones de un proyecto rompan otro que requiere versiones anteriores.\nReproducibilidad: Permite que otros colaboradores instalen exactamente las mismas versiones de paquetes.\nLimpieza: Facilita la instalaci√≥n controlada de dependencias sin ‚Äúensuciar‚Äù la instalaci√≥n global de Python en el sistema.\n\n\n\n\n\n\n\nImportant\n\n\nEn este curso, crearemos un ambiente espec√≠fico para Programaci√≥n Aplicada II para asegurar que todos trabajemos con las mismas versiones de NumPy, Pandas y Matplotlib."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#estructura-de-un-programa",
    "href": "clases/02_repaso-fundamentos.html#estructura-de-un-programa",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Estructura de un programa",
    "text": "Estructura de un programa\n\n\nComentario: Texto que no afecta la ejecuci√≥n. Sirve para aclaraciones.\n\n# Una sola linea\n\"\"\" Varias \n    lineas \"\"\"\n\nSentencia: Instrucci√≥n que realiza una acci√≥n. El salto de l√≠nea (Enter) indica el fin.\n\nx = 10\n\nIndentaci√≥n: Sangr√≠a obligatoria para definir bloques de c√≥digo en lugar de llaves {}.\n\nif x &gt; 0:\n    print(\"Identado\")\n\nFunci√≥n y llamada: Bloque reutilizable (def) y su invocaci√≥n por nombre.\n\ndef suma(a, b): \n    return a + b\nres = suma(3, 5)\n\nExpresi√≥n: Combinaci√≥n de valores y operadores que producen un resultado (ej. 3 + 5).\nBloque: Conjunto de sentencias agrupadas por la misma indentaci√≥n."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#variables-y-tipos-de-datos",
    "href": "clases/02_repaso-fundamentos.html#variables-y-tipos-de-datos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Variables y tipos de datos",
    "text": "Variables y tipos de datos\n\n\n\n\n\n\nVariable\n\n\nUna variable es un nombre asociado a un valor almacenado en memoria.\n\n\n\n\nPython permite declarar variables sin indicar su tipo expl√≠citamente (tipado din√°mico).\nLos nombres deben ser descriptivos y no pueden iniciar con n√∫meros ni contener espacios.\n\nnombre = \"Ana\"       # Cadena de texto (str)\nedad = 25            # Entero (int)\naltura = 1.68        # Decimal (float)\nes_estudiante = True # Booleano (bool)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#tipos-de-datos-b√°sicos",
    "href": "clases/02_repaso-fundamentos.html#tipos-de-datos-b√°sicos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Tipos de datos b√°sicos",
    "text": "Tipos de datos b√°sicos\nClasificaci√≥n\n\n\nNum√©ricos\n\nüî¥ int: n√∫meros enteros.\nüîµ float: punto flotante.\nüü£ bool: l√≥gicos (True/False).\n\nMapeo\n\nüîº dict: pares clave-valor.\n\n\nSecuencias\n\nüü® list: mutable y ordenada.\nüüß tuple: inmutable y ordenada.\nüü´ str: texto inmutable.\n\nEspeciales\n\nüîª None: ausencia de valor."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#enteros-int",
    "href": "clases/02_repaso-fundamentos.html#enteros-int",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üî¥ Enteros (int)",
    "text": "üî¥ Enteros (int)\nLos enteros son un tipo de dato que permite representar n√∫meros enteros, positivos o negativos, sin decimales.\nSistemas de numeraci√≥n:\n\nBinario: Prefijo 0b (ej., 0b101).\nHexadecimal: Prefijo 0x (ej., 0xA1).\nOctal: Prefijo 0o (ej., 0o17).\nAl imprimir, el n√∫mero se convierte a decimal.\n\nnum_decimal = 42\nnum_binario = 0b101\nnum_hexadecimal = 0xA1\nnum_octal = 0o17\n\nprint(num_decimal, num_binario, num_hexadecimal, num_octal)\n# Esto imprime: 42 5 161 15"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#enteros---recordatorio",
    "href": "clases/02_repaso-fundamentos.html#enteros---recordatorio",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üî¥ Enteros - Recordatorio",
    "text": "üî¥ Enteros - Recordatorio\nüìå Recordatorio:\n\nPython asigna bits seg√∫n el valor del n√∫mero. Puedes usar sys.getsizeof() para conocer el tama√±o en memoria.\nPuedes convertir otros tipos a int. Los decimales se truncan al convertir a int.\n\n# ¬øCu√°l es la salida de este c√≥digo?\nimport sys\n\nnum = 4\nprint(sys.getsizeof(num))\n\nnum_decimal = 3.7\nnum_entero = int(num_decimal)\nprint(num_entero)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#flotantes-float",
    "href": "clases/02_repaso-fundamentos.html#flotantes-float",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üîµ Flotantes (float)",
    "text": "üîµ Flotantes (float)\nRepresentan n√∫meros positivos o negativos con decimales.\nNo tienen precisi√≥n infinita. Los valores m√°ximos y m√≠nimos est√°n definidos por el sistema, aunque podemos hacer una representaci√≥n simb√≥lica del n√∫mero infinito y NaN.\n# Float\nnum1 = 3.14159\nprint(num1, type(num1))\n\n# Infinito y NaN\nnum_infinito = float('inf')\nnum_nan = float('nan')\nprint(num_infinito, num_nan)\n\n# M√≠nimo y m√°ximo\nimport sys\nprint(\"Valor m√≠nimo\", sys.float_info.min)\nprint(\"Valor m√°ximo\", sys.float_info.max)\n\n# ¬øCu√°l es el resultado de esta operaci√≥n?\nnum2 = 1-2.2250738585072014e-308\nprint(num2)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#flotantes---recordatorio",
    "href": "clases/02_repaso-fundamentos.html#flotantes---recordatorio",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üîµ Flotantes - Recordatorio",
    "text": "üîµ Flotantes - Recordatorio\nüìå Recordatorio:\n\nPodemos indicar n√∫meros flotantes mediante notaci√≥n cient√≠fica, usamos e para indicar el exponente.\nPodemos convertir otros tipos a float usando float().\n\nnum3 = 1.2e3  # Notaci√≥n cient√≠fica (1200.0)\nprint(num3)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#booleanos-bool",
    "href": "clases/02_repaso-fundamentos.html#booleanos-bool",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üü£ Booleanos (bool)",
    "text": "üü£ Booleanos (bool)\n\nTipo de dato que almacena True o False.\nSe utiliza con operadores como &gt;, &lt;, ==, que devuelven valores booleanos.\nPodemos convertir valores a bool usando bool().\n\nvalor1 = True\nvalor2 = (5 &gt; 3)  # True\nvalor3 = bool(0)   # False\nvalor4 = bool(1)   # True\nprint(valor1, valor2, valor3, valor4)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#listas-list",
    "href": "clases/02_repaso-fundamentos.html#listas-list",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üü® Listas (list)",
    "text": "üü® Listas (list)\nEstructura de datos mutable y din√°mica.\nPropiedades:\n\nOrdenadas.\nContienen tipos arbitrarios.\nSe crean e indexan con [].\nPueden anidarse.\n\nmi_lista = [1, 2, 3, \"Python\", [5, 6]]\nprint(mi_lista[0])      # Salida?\nprint(mi_lista[-1])     # Salida?\nmi_lista[1] = \"Nuevo\"\nprint(mi_lista)         # Salida?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#listas---m√©todos-comunes",
    "href": "clases/02_repaso-fundamentos.html#listas---m√©todos-comunes",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üü® Listas - M√©todos comunes",
    "text": "üü® Listas - M√©todos comunes\nüìå Recordatorio:\nM√©todos comunes de las listas:\n\nappend(valor): Agrega elemento al final.\nextend(iterable): Agrega elementos de un iterable.\ninsert(pos, valor): Inserta en una posici√≥n.\npop(indice): Elimina y devuelve el elemento en el √≠ndice (por defecto el √∫ltimo).\nremove(valor): Elimina la primera aparici√≥n del valor.\nreverse(): Invierte el orden.\nsort(): Ordena la lista.\n\nmi_lista2 = [3, 1, 4]\nmi_lista2.append(5)\nmi_lista2.sort()\nprint(mi_lista2)  # Salida?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#tuplas-tuple",
    "href": "clases/02_repaso-fundamentos.html#tuplas-tuple",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üüß Tuplas (tuple)",
    "text": "üüß Tuplas (tuple)\nEstructura de datos inmutable. Una vez que una tupla ha sido creada, sus elementos no pueden ser modificados.\nPropiedades:\n\nInmutables.\nOrdenadas.\nContienen tipos arbitrarios.\nSe crean con (), se indexan con [].\nPueden anidarse.\nPueden contener duplicados.\n\nmi_tupla = (10, 20, 30, 40)\nprint(mi_tupla[0])  # Imprime: 10\nprint(mi_tupla[-1])  # Imprime: 40\n\nmi_tupla2 = (1, 2, 3)\na, b, c = mi_tupla2\nprint(a, b, c)  # Imprime: 1 2 3\n\nes_tupla = (5)  # ¬øEsto es una tupla?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#tuplas---m√©todos-comunes",
    "href": "clases/02_repaso-fundamentos.html#tuplas---m√©todos-comunes",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üüß Tuplas - M√©todos comunes",
    "text": "üüß Tuplas - M√©todos comunes\nüìå Recordatorio:\nM√©todos comunes de las tuplas:\n\ncount(): Cuenta cu√°ntas veces aparece un elemento.\nindex(): Devuelve el √≠ndice de la primera ocurrencia de un elemento.\n\nEn todos los iterables (listas, tuplas, cadenas, diccionarios), podemos verificar la existencia de un elemento dentro del iterable.\nmi_tupla3 = (1, 2, 3, 1, 2, 1)\nprint(mi_tupla3.count(1))  # Imprime: 3\nprint(mi_tupla3.index(2))  # Imprime: 1\n\nmi_tupla4 = (\"rojo\", \"azul\", \"verde\")\nprint(\"rojo\" in mi_tupla4)  # Imprime: True"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#cadenas-str",
    "href": "clases/02_repaso-fundamentos.html#cadenas-str",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üü´ Cadenas (str)",
    "text": "üü´ Cadenas (str)\nTipo inmutable que almacena secuencias de caracteres. Se usan comillas simples o dobles.\nFunciones y operaciones comunes:\n\nConcatenaci√≥n.\nRepetici√≥n.\nLongitud.\nIndexaci√≥n y slicing.\n\ntexto = \"Hola, Python!\"\nprint(texto[0])      # Salida?\nprint(len(texto))    # Salida?\nprint(texto[7:])     # Salida?\nprint(texto * 3)     # Salida?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#diccionarios-dict",
    "href": "clases/02_repaso-fundamentos.html#diccionarios-dict",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üîº Diccionarios (dict)",
    "text": "üîº Diccionarios (dict)\nSon estructuras de datos que almacenan pares de clave-valor.\nLas claves deben ser √∫nicas e inmutables (pueden ser cadenas, n√∫meros o tuplas). Se crean con llaves {}.\nPropiedades:\n\nNo ordenados (antes de Python 3.7). Desde Python 3.7, mantienen el orden de inserci√≥n.\nAcceso r√°pido a los valores usando las claves.\nMutables.\n\nalumno = {\n    \"nombre\": \"Ana\",\n    \"edad\": 21,\n    \"carrera\": \"Ingenier√≠a en IA\"\n}\n\nprint(alumno[\"nombre\"])  # Salida: \"Ana\"\nalumno[\"promedio\"] = 9.5  # Agregar nueva clave\nalumno[\"edad\"] = 22       # Modificar valor\nprint(alumno)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#diccionarios---m√©todos-comunes",
    "href": "clases/02_repaso-fundamentos.html#diccionarios---m√©todos-comunes",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "üîº Diccionarios - M√©todos comunes",
    "text": "üîº Diccionarios - M√©todos comunes\nüìå Recordatorio:\nM√©todos comunes de los diccionarios:\n\nkeys(): Devuelve las claves.\nvalues(): Devuelve los valores.\nitems(): Devuelve los pares clave-valor como tuplas.\nget(): Accede a un valor de forma segura (sin causar error si la clave no existe).\ndel: Elimina una clave y su valor.\npop(): Elimina una clave y devuelve su valor.\n\nTambi√©n podemos iterar sobre un diccionario:\n\nClaves: for clave in diccionario.\nValores: for valor in diccionario.values().\nPares clave-valor: for clave, valor in diccionario.items().\n\ndel alumno[\"carrera\"]\npromedio = alumno.pop(\"promedio\")\nprint(alumno)  # Salida: {\"nombre\": \"Ana\", \"edad\": 22}\nprint(alumno.keys())      # Salida: dict_keys([\"nombre\", \"edad\"])\nprint(alumno.get(\"edad\")) # Salida: 22\n\nfor clave, valor in alumno.items():\n    print(f\"{clave}: {valor}\") # Salida?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejercicio-2-tipos-de-variables",
    "href": "clases/02_repaso-fundamentos.html#ejercicio-2-tipos-de-variables",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejercicio 2: Tipos de variables",
    "text": "Ejercicio 2: Tipos de variables\n1. Identificaci√≥n de tipos\nIndica el tipo de dato de cada una de las siguientes variables:\nnombre = \"Juan\"                   # ?\nes_mayor_de_edad = True           # ?\nprecio = 45.99                    # ?\nnumeros = [1, 2, 3, 4, 5]         # ?\nestudiantes = {\"001\": \"Ana\",      # ?\n               \"002\": \"Carlos\"}\nedad = 25                         # ?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#comportamiento-y-evidencia",
    "href": "clases/02_repaso-fundamentos.html#comportamiento-y-evidencia",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "2. Comportamiento y evidencia",
    "text": "2. Comportamiento y evidencia\n\nResponde las siguientes preguntas. Justifica tu respuesta mostrando la evidencia del comportamiento observado (c√≥digo, resultado, explicaci√≥n de lo que sucede y por qu√©).\n\n¬øC√≥mo imprimir√≠as el tercer elemento de la lista numeros?\n¬øC√≥mo se podr√≠a modificar el contenido de la lista numeros?\n¬øQu√© error aparece al intentar acceder a una clave que no existe en un diccionario?\n¬øQu√© sucede si intentas sumar un n√∫mero entero con una cadena?\n¬øQu√© ocurre si intentas modificar una tupla despu√©s de haberla creado?\n¬øC√≥mo puedes comprobar si una variable contiene un valor nulo?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ops",
    "href": "clases/02_repaso-fundamentos.html#ops",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Operadores",
    "text": "Operadores\n\n\n\n\n\n\nOperador\n\n\nEs un s√≠mbolo especial que realiza una operaci√≥n en uno o m√°s operandos.\n\n\n\nTipos de Operadores\n\n\n\nTipo\nOperadores\nEjemplo\n\n\n\n\nAritm√©ticos\n+, -, *, /, //, %, **\na + b\n\n\nRelacionales\n==, !=, &gt;, &lt;, &gt;=, &lt;=\nx &gt;= 10\n\n\nL√≥gicos\nand, or, not\nx &gt; 5 and x &lt; 20\n\n\nAsignaci√≥n\n=, +=, -=, *=, /=\ncontador += 1\n\n\nMembres√≠a\nin, not in\n\"a\" in \"cadena\"\n\n\nIdentidad\nis, is not\nx is None\n\n\n\nReglas de precedencia\nTIPS:\n\nUsa par√©ntesis para agrupar expresiones y evitar errores de precedencia.\nPotencia (**) se eval√∫a de derecha a izquierda.\nLos operadores l√≥gicos siguen el orden: not &gt; and &gt; or.\nLa asignaci√≥n siempre ocurre al final.\n\n\n\n\n\n\n\n\n\n\nNivel\nOperador(es)\nDescripci√≥n\nEjemplo\n\n\n\n\n1 (m√°s alta)\n()\nAgrupaci√≥n mediante par√©ntesis\n(5 + 3) * 2 ‚Üí 16\n\n\n2\n**\nPotencia\n2 ** 3 ** 2 ‚Üí 512\n\n\n3\n+x, -x\nOperadores unarios\n-3 + 4 ‚Üí 1\n\n\n4\n*, /, //, %\nMultiplicaci√≥n, divisi√≥n, divisi√≥n entera, m√≥dulo\n10 % 3 ‚Üí 1\n\n\n5\n+, -\nSuma y resta\n10 - 4 + 2 ‚Üí 8\n\n\n6\n==, !=, &gt;, &lt;, &gt;=, &lt;=, is, in\nComparaci√≥n, identidad y pertenencia\na in lista\n\n\n7\nnot\nNegaci√≥n l√≥gica\nnot True ‚Üí False\n\n\n8\nand\nConjunci√≥n l√≥gica\nTrue and False ‚Üí False\n\n\n9\nor\nDisyunci√≥n l√≥gica\nFalse or True ‚Üí True\n\n\n10 (m√°s baja)\n=, +=, -=, *=, /=\nAsignaci√≥n\nx = 5; x += 1 ‚Üí 6"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejemplos-de-operadores",
    "href": "clases/02_repaso-fundamentos.html#ejemplos-de-operadores",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejemplos de operadores",
    "text": "Ejemplos de operadores\nveamos algunos ejemplos‚Ä¶\n\nSin usar calculadora ni Python, ¬øCu√°l es el resultado de la expresi√≥n (5 + 3) * 2 / 4?\nDado el c√≥digo x += 2, ¬øcu√°l es el valor final de la variable x si su valor inicial es 7?\n¬øC√≥mo podr√≠as verificar si un n√∫mero es par utilizando operadores relacionales y aritm√©ticos?\n¬øC√≥mo utilizar√≠as el operador ** para calcular la ra√≠z cuadrada de un n√∫mero?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejercicio-3.-tipos-de-operadores",
    "href": "clases/02_repaso-fundamentos.html#ejercicio-3.-tipos-de-operadores",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejercicio 3. Tipos de operadores",
    "text": "Ejercicio 3. Tipos de operadores\nSup√≥n que tienes las siguientes variables iniciales:\na = 10\nb = 4\nlista = [1, 2, 3, 4, 5]\nnombre = \"Juan\"\npersona = {\"nombre\": \"Juan\", \"edad\": 25}\nResponde las siguientes preguntas. Justifica tu respuesta mostrando la evidencia del comportamiento observado.\n\n¬øCu√°l es el resultado de a + b * 2 - 3?\nSi haces a //= 3, ¬øcu√°l es el nuevo valor de a?\nUsa el operador de potencia ** para calcular el cuadrado de b.\n¬øCu√°l es el resultado de a &gt; b and b &lt; 5?\n¬øQu√© valor retorna not (a == 10)?\nVerifica si a es m√∫ltiplo de b utilizando una expresi√≥n booleana.\n¬øC√≥mo verificar√≠as si el n√∫mero 6 est√° o no en lista?\n¬øC√≥mo saber si la clave ‚Äúedad‚Äù est√° presente en el diccionario persona?\nDeclara c = 10 y verifica si a is c y luego si a == c. ¬øPor qu√© puede haber diferencia?\n¬øQu√© ocurre si ejecutas a / 0? ¬øQu√© tipo de error se genera?\n¬øC√≥mo podr√≠as validar que una variable no es None?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#io",
    "href": "clases/02_repaso-fundamentos.html#io",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Entrada y salida de datos",
    "text": "Entrada y salida de datos"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#entrada-de-datos",
    "href": "clases/02_repaso-fundamentos.html#entrada-de-datos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Entrada de datos",
    "text": "Entrada de datos\n\n\n\nEntrada de datos\n\n\nLa funci√≥n input() se utiliza para obtener datos desde la entrada est√°ndar (generalmente el teclado) y asignarlos a variables. La entrada se toma como una cadena (str).\nnombre = input(\"Ingrese su nombre: \")\nedad = int(input(\"Ingrese su edad: \"))  # Convertir a entero"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#salida-de-datos",
    "href": "clases/02_repaso-fundamentos.html#salida-de-datos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Salida de datos",
    "text": "Salida de datos\n\n\n\nSalida de datos\n\n\nLa funci√≥n print() se utiliza para mostrar informaci√≥n en la salida est√°ndar (consola).\nnombre = \"Juan\"\nedad = 30\nprint(\"Nombre:\", nombre, \"Edad:\", edad)\nUso recomendado: f-strings (desde Python 3.6)\nprint(f\"{nombre} tiene {edad} a√±os\")"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#conversi√≥n-de-tipos",
    "href": "clases/02_repaso-fundamentos.html#conversi√≥n-de-tipos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Conversi√≥n de tipos",
    "text": "Conversi√≥n de tipos\n\n\n\n\n\n\nConversi√≥n de tipos\n\n\nLa conversi√≥n de tipos, o type casting, se refiere a cambiar el tipo de dato de una variable a otro.\nedad = 25\nedad_str = str(edad)  # Convertir entero a cadena"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#preguntas---io",
    "href": "clases/02_repaso-fundamentos.html#preguntas---io",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Preguntas - I/O",
    "text": "Preguntas - I/O"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-1---io",
    "href": "clases/02_repaso-fundamentos.html#pregunta-1---io",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 1 - I/O",
    "text": "Pregunta 1 - I/O\n¬øCu√°l ser√° la salida si el usuario ingresa 3?\nx = input(\"Ingrese un n√∫mero: \")\ny = x * 2\nprint(y)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-2---io",
    "href": "clases/02_repaso-fundamentos.html#pregunta-2---io",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 2 - I/O",
    "text": "Pregunta 2 - I/O\n¬øCu√°l ser√° la salida de este c√≥digo?\na = \"5\"\nb = int(a) + 2\nc = str(b)\nprint(a + c)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-3---io",
    "href": "clases/02_repaso-fundamentos.html#pregunta-3---io",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 3 - I/O",
    "text": "Pregunta 3 - I/O\n¬øQu√© tipo de error obtendr√≠as al intentar ejecutar este c√≥digo?\nnum_str = \"abc\"\nnum_int = int(num_str)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-4---io",
    "href": "clases/02_repaso-fundamentos.html#pregunta-4---io",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 4 - I/O",
    "text": "Pregunta 4 - I/O\n¬øCu√°l ser√° el error en este c√≥digo y c√≥mo lo corregir√≠as?\nedad = 25\nprint(\"Mi edad es: \" + edad)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#flujo-de-ejecuci√≥n",
    "href": "clases/02_repaso-fundamentos.html#flujo-de-ejecuci√≥n",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Flujo de ejecuci√≥n",
    "text": "Flujo de ejecuci√≥n\nFlujo Secuencial\nImplica ejecutar las instrucciones en orden, una tras otra.\nprint(\"Inicio del programa\")\nedad = 20\nprint(\"La edad es:\", edad)\nprint(\"Fin del programa\")\nEstructuras Condicionales\nPermiten ejecutar bloques de c√≥digo dependiendo si una condici√≥n es verdadera o falsa.\nEstructura if: Ejecuta el bloque de c√≥digo dentro del if si la condici√≥n es verdadera.\nedad = 20\nif edad &gt;= 18:\n    print(\"Eres mayor de edad.\")\nEstructura elif: Se utiliza para evaluar condiciones adicionales si la condici√≥n del if no se cumple.\ntemperatura = 25\nif temperatura &gt; 30:\n    print(\"Hace mucho calor.\")\nelif temperatura &gt; 20:\n    print(\"La temperatura es agradable.\")\nEstructura else: Proporciona un bloque de c√≥digo que se ejecuta si ninguna de las condiciones anteriores es verdadera.\nedad = 15\nif edad &gt;= 18:\n    print(\"Eres mayor de edad.\")\nelse:\n    print(\"Eres menor de edad.\")"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#preguntas---condicionales",
    "href": "clases/02_repaso-fundamentos.html#preguntas---condicionales",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Preguntas - Condicionales",
    "text": "Preguntas - Condicionales"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-1---condicionales",
    "href": "clases/02_repaso-fundamentos.html#pregunta-1---condicionales",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 1 - Condicionales",
    "text": "Pregunta 1 - Condicionales\n¬øCu√°l ser√° la salida de este c√≥digo?\nx = 10\nif x &gt; 5:\n    print(\"A\")\nelif x &lt; 15:\n    print(\"B\")\nelse:\n    print(\"C\")"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-2---condicionales",
    "href": "clases/02_repaso-fundamentos.html#pregunta-2---condicionales",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 2 - Condicionales",
    "text": "Pregunta 2 - Condicionales\n¬øCu√°l es el error y c√≥mo se puede corregir?\nif x &gt; 10\n    print(\"Mayor que 10\")"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#cycles",
    "href": "clases/02_repaso-fundamentos.html#cycles",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Estructuras de Iteraci√≥n/Ciclos (for, while):",
    "text": "Estructuras de Iteraci√≥n/Ciclos (for, while):\nPermiten repetir bloques de c√≥digo mientras se cumpla una condici√≥n.\nCiclo for:\nObtiene los elementos de un iterable (como una lista) y ejecuta el bloque de c√≥digo en cada iteraci√≥n.\nfrutas = [\"manzana\", \"banana\", \"cereza\"]\nfor fruta in frutas:\n    print(fruta)\nCiclo while:\nEjecuta el bloque de c√≥digo mientras la condici√≥n sea verdadera.\ncontador = 0\nwhile contador &lt; 5:\n    print(contador)\n    contador += 1"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#preguntas---ciclos",
    "href": "clases/02_repaso-fundamentos.html#preguntas---ciclos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Preguntas - Ciclos",
    "text": "Preguntas - Ciclos"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-1---ciclos",
    "href": "clases/02_repaso-fundamentos.html#pregunta-1---ciclos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 1 - Ciclos",
    "text": "Pregunta 1 - Ciclos\n¬øQu√© valores imprimir√° este ciclo?\nfor i in range(2, 5):\n    print(i)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-2---ciclos",
    "href": "clases/02_repaso-fundamentos.html#pregunta-2---ciclos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 2 - Ciclos",
    "text": "Pregunta 2 - Ciclos\n¬øCu√°l es el error y c√≥mo se puede corregir?\nwhile True\n    print(\"Instrucci√≥n dentro de un ciclo\")"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-3---ciclos",
    "href": "clases/02_repaso-fundamentos.html#pregunta-3---ciclos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 3 - Ciclos",
    "text": "Pregunta 3 - Ciclos\n¬øQu√© diferencia hay entre while y for en t√©rminos de su comportamiento?"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#pregunta-4---ciclos",
    "href": "clases/02_repaso-fundamentos.html#pregunta-4---ciclos",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Pregunta 4 - Ciclos",
    "text": "Pregunta 4 - Ciclos\n¬øPuedes modificar el ejemplo del bucle for para imprimir las frutas en may√∫sculas?\nfrutas = [\"manzana\", \"banana\", \"cereza\"]\nfor fruta in frutas:\n    print(fruta)"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#estructuras-de-control",
    "href": "clases/02_repaso-fundamentos.html#estructuras-de-control",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Estructuras de control",
    "text": "Estructuras de control\n\n\n\n\n\n\n\n\n\nTipo\nEstructura\nDescripci√≥n\nEjemplo de uso\n\n\n\n\nCondicional\nif\nEval√∫a una condici√≥n y ejecuta un bloque si se cumple.\nif edad &gt;= 18:\n\n\nCondicional\nif ... else\nEjecuta un bloque si se cumple la condici√≥n, otro si no.\nif edad &gt;= 18: ... else: ...\n\n\nCondicional\nif ... elif ... else\nPermite m√∫ltiples condiciones encadenadas.\nif x &gt; 0: ... elif x &lt; 0: ...\n\n\nCiclo\nwhile\nRepite un bloque mientras una condici√≥n sea verdadera.\nwhile i &lt; 10:\n\n\nCiclo\nfor\nItera sobre elementos de una secuencia.\nfor letra in palabra:\n\n\nControl de flujo\nbreak\nTermina un ciclo de forma anticipada.\nif x == 5: break\n\n\nControl de flujo\ncontinue\nOmite el resto del ciclo actual.\nif x == 0: continue\n\n\nControl nulo\npass\nNo hace nada; marcador de posici√≥n.\nif condicion: pass\n\n\n\nTips: Usa if...elif...else para condiciones excluyentes. Prefiere for para recorrer elementos y while cuando no sabes cu√°ntas iteraciones. Evita ciclos infinitos."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejemplos-de-estructuras-de-control",
    "href": "clases/02_repaso-fundamentos.html#ejemplos-de-estructuras-de-control",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejemplos de estructuras de control",
    "text": "Ejemplos de estructuras de control\nveamos algunos ejemplos‚Ä¶\n\n\nEscribe un programa que solicite una calificaci√≥n (0 a 100) y muestre:\n\n‚ÄúExcelente‚Äù si es ‚â• 90\n‚ÄúBueno‚Äù si es ‚â• 70\n‚ÄúSuficiente‚Äù si es ‚â• 60\n‚ÄúReprobado‚Äù en caso contrario\n\n\n\n\n\nEscribe un programa que declare una lista de nombres y salude a cada uno.\n\n\n\n\nSolicita al usuario contrase√±as hasta que escriba ‚Äúpython‚Äù."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#funciones",
    "href": "clases/02_repaso-fundamentos.html#funciones",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Funciones",
    "text": "Funciones\n\n\n\n\n\n\nFunci√≥n\n\n\n\nUna funci√≥n es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica.\nPermite dividir un programa en partes m√°s peque√±as, legibles y mantenibles.\n\n\n\n\n\nUna funci√≥n encapsula una acci√≥n o un conjunto de instrucciones que pueden ejecutarse varias veces sin reescribir el c√≥digo.\n\n¬øPor qu√© usar funciones?\n\nEvitan la repetici√≥n de c√≥digo (DRY: Don‚Äôt Repeat Yourself).\nMejoran la organizaci√≥n del programa.\nPermiten dividir problemas complejos en partes m√°s manejables.\nFacilitan las pruebas y el mantenimiento."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#sintaxis-de-funciones",
    "href": "clases/02_repaso-fundamentos.html#sintaxis-de-funciones",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Sintaxis de funciones",
    "text": "Sintaxis de funciones\ndef nombre_funcion(par√°metros):\n    \"\"\"Docstring opcional que explica qu√© hace la funci√≥n\"\"\"\n    # cuerpo de la funci√≥n\n    return valor\nEjemplo:\ndef saludar(nombre):\n    print(f\"Hola, {nombre}!\")\n\n# llamada\nsaludar(\"Ana\")"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#funciones-con-retorno-return",
    "href": "clases/02_repaso-fundamentos.html#funciones-con-retorno-return",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Funciones con retorno (return)",
    "text": "Funciones con retorno (return)\ndef cuadrado(x):\n    return x * x\n\nresultado = cuadrado(5)\nprint(resultado)  # Imprime 25"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#buenas-pr√°cticas-al-definir-funciones",
    "href": "clases/02_repaso-fundamentos.html#buenas-pr√°cticas-al-definir-funciones",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Buenas pr√°cticas al definir funciones",
    "text": "Buenas pr√°cticas al definir funciones\n\nUsa nombres descriptivos en min√∫sculas y con guiones bajos (snake_case).\nIncluye una docstring que explique qu√© hace la funci√≥n.\nLimita la funci√≥n a una sola responsabilidad.\nEvita efectos secundarios innecesarios (modificar variables externas).\nUsa return para valores que necesites reutilizar.\n\n\n\n\n\n\n\n\n\nTipo\nDescripci√≥n\nEjemplo\n\n\n\n\nSin par√°metros, sin retorno\nEjecuta acciones, pero no recibe ni devuelve valores\ndef bienvenida():\n\n\nCon par√°metros\nRecibe datos para trabajar con ellos\ndef saludar(nombre):\n\n\nCon retorno\nDevuelve un valor con return\ndef suma(a, b): return a + b\n\n\nPar√°metros por defecto\nAsignan valores si no se proporcionan argumentos\ndef saludar(nombre=\"invitado\"):"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#qu√©-es-un-par√°metro-qu√©-es-un-argumento",
    "href": "clases/02_repaso-fundamentos.html#qu√©-es-un-par√°metro-qu√©-es-un-argumento",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "¬øQu√© es un par√°metro? ¬øQu√© es un argumento?",
    "text": "¬øQu√© es un par√°metro? ¬øQu√© es un argumento?\n\nPar√°metro: variable declarada en la definici√≥n de la funci√≥n.\nArgumento: valor real que se pasa cuando se llama a la funci√≥n.\nEjemplo:\ndef saludar(nombre):  # nombre es un par√°metro\n    print(\"Hola\", nombre)\n\nsaludar(\"Luc√≠a\")  # \"Luc√≠a\" es un argumento"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejercicio-4.-estructuras-de-control-y-funciones",
    "href": "clases/02_repaso-fundamentos.html#ejercicio-4.-estructuras-de-control-y-funciones",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejercicio 4. Estructuras de control y funciones",
    "text": "Ejercicio 4. Estructuras de control y funciones\nPara cada uno de los siguientes problemas, realiza lo siguiente:\n\nDise√±a el algoritmo o pseudoc√≥digo que describa paso a paso la soluci√≥n.\nEscribe el c√≥digo usando funciones y estructuras de control. Recuerda que el c√≥digo debe ser eficiente y organizado.\nResponde las preguntas espec√≠ficas de reflexi√≥n que se indican."
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejercicio-4.1-dos-gatos-y-un-rat√≥n",
    "href": "clases/02_repaso-fundamentos.html#ejercicio-4.1-dos-gatos-y-un-rat√≥n",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejercicio 4.1 Dos gatos y un rat√≥n",
    "text": "Ejercicio 4.1 Dos gatos y un rat√≥n\nDos gatos y un rat√≥n se encuentran en varias posiciones sobre una l√≠nea.\n\nComo valor de entrada, solicita al usuario sus posiciones iniciales.\nTu tarea es determinar cu√°l gato alcanzar√° al rat√≥n primero, asumiendo que el rat√≥n no se mueve y ambos gatos se mueven a la misma velocidad.\nOJO: Si ambos gatos llegan al mismo tiempo, el rat√≥n podr√° escapar mientras que los dos gatos pelean.\n\nEntrada: Solicita como valores de entrada tres enteros, los cuales representan respectivamente las posiciones del gato A, del gato B y del rat√≥n C. Puedes suponer que 1‚â§A, B, C‚â§100.\nSalida:\n\nSi el gato A alcanza primero al rat√≥n, imprime como salida ‚Äúgato A‚Äù.\nSi el gato B alcanza primero al rat√≥n, imprime como salida ‚Äúgato B‚Äù.\nSi ambos gatos alcanzan al rat√≥n C al mismo tiempo, imprimir como salida ‚Äúraton C‚Äù.\n\nEjemplos:\n\n\n\nEntrada\nSalida\n\n\n\n\n1 2 3\ngato B\n\n\n1 3 2\nraton C\n\n\n4 8 10\ngato B\n\n\n8 3 12\ngato A"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejercicio-4.2-una-sumatoria-muy-extra√±a",
    "href": "clases/02_repaso-fundamentos.html#ejercicio-4.2-una-sumatoria-muy-extra√±a",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejercicio 4.2 Una sumatoria muy extra√±a",
    "text": "Ejercicio 4.2 Una sumatoria muy extra√±a\nEscribe un programa que eval√∫e el valor de \\(\\sum_{i=m}^{n}\\) donde:\n\\[\n\\begin{eqnarray}\nm &=& \\sum_{i=1}^{a} i \\\\\nn &=& \\sum_{i=1}^{b} i\n\\end{eqnarray}\n\\]\nEntrada: Solicita como valores de entrada dos enteros a y b. Puedes suponer que 1‚â§a‚â§b‚â§100\nSalida: Un entero que sea el valor de la f√≥rmula evaluada.\nEjemplo:\n\n\n\nEntrada\nSalida\n\n\n\n\n3 5\n105"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#ejercicio-4.3-una-serie-poco-interesante",
    "href": "clases/02_repaso-fundamentos.html#ejercicio-4.3-una-serie-poco-interesante",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Ejercicio 4.3 Una serie poco interesante",
    "text": "Ejercicio 4.3 Una serie poco interesante\nLa serie num√©rica 1,2,3,1,2,3,1‚Ä¶ es infinita pero no por eso deja de ser bastante aburrida.\nPor ejemplo, es f√°cil darnos cuenta que despu√©s de un 1 siempre sigue un 2 y que antes de un 1 siempre hay un 3.\nSi N es el n√∫mero actual de la serie, ¬øpodr√°s adivinar qu√© n√∫meros est√°n P posiciones antes y despu√©s de N?\nEntrada: Solicita como valores de entrada dos enteros N y P. Puedes suponer que 1‚â§N‚â§3 y 0‚â§P‚â§10‚Åπ.\nSalida: Dos enteros separados por un espacio donde el primero sea el n√∫mero que est√° P posiciones antes de N y el segundo el que est√° P posiciones despu√©s.\nEjemplo:\n\n\n\nEntrada\nSalida\n\n\n\n\n2 1\n1 3\n\n\n2 0\n2 2\n\n\n1 2\n2 3"
  },
  {
    "objectID": "clases/02_repaso-fundamentos.html#referencias",
    "href": "clases/02_repaso-fundamentos.html#referencias",
    "title": "Clase 02 - Fundamentos de programaci√≥n",
    "section": "Referencias",
    "text": "Referencias\n\nArora, Pretti. Computer Science with Python. (2020). Computer Science with Python\nStanford University. Stanford CS224N Python Review. Stanford CS224N Python Review\n\nEjercicio 1: Dos gatos y un rat√≥n\nDos gatos y un rat√≥n\nEjercicio 2: Una sumatoria muy extra√±a\nUna sumatoria muy extra√±a\nEjercicio 3: Una serie poco interesante\nUna serie poco interesante"
  },
  {
    "objectID": "clases/01_logistica.html#contenido",
    "href": "clases/01_logistica.html#contenido",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Contenido",
    "text": "Contenido\n\nAcerca del curso\n\nInformaci√≥n del curso\nQu√© esperar y que NO esperar del curso\nPrerrequisitos\nObjetivos\n\nC√≥digo de conducta\n\nComunicaci√≥n oficial 455\n\nTemario\nEvaluaci√≥n\nFechas importantes\nMaterial de estudio"
  },
  {
    "objectID": "clases/01_logistica.html#acercade",
    "href": "clases/01_logistica.html#acercade",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Acerca del curso",
    "text": "Acerca del curso\nProgramaci√≥n Aplicada II\n\nHorario: Lunes y Mi√©rcoles, 07:00 a 09:00 hrs\nDocente: Dra. Dora Alvarado\n\nEmail: 27382@iberoleon.edu.mx; doraelisa.alvaradocarrillo@iberoleon.edu.mx\n\nAvisos, ex√°menes, tareas a trav√©s de la p√°gina del curso en Moodle."
  },
  {
    "objectID": "clases/01_logistica.html#codigo",
    "href": "clases/01_logistica.html#codigo",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "C√≥digo de conducta",
    "text": "C√≥digo de conducta\nVersi√≥n resumida:\n\n\n\n\n\n\nDisciplina\n\n\nCualquier indisciplina en el sal√≥n de clase implicar√° la salida del sal√≥n con falta y un reporte a la coordinaci√≥n de la carrera."
  },
  {
    "objectID": "clases/01_logistica.html#temario-sujeto-a-cambios-seg√∫n-sea-necesario",
    "href": "clases/01_logistica.html#temario-sujeto-a-cambios-seg√∫n-sea-necesario",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Temario (sujeto a cambios seg√∫n sea necesario):",
    "text": "Temario (sujeto a cambios seg√∫n sea necesario):"
  },
  {
    "objectID": "clases/01_logistica.html#evaluacion",
    "href": "clases/01_logistica.html#evaluacion",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Evaluaci√≥n",
    "text": "Evaluaci√≥n"
  },
  {
    "objectID": "clases/01_logistica.html#evaluaci√≥n",
    "href": "clases/01_logistica.html#evaluaci√≥n",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Evaluaci√≥n",
    "text": "Evaluaci√≥n\n\n\n\n\n\n\n\n\nComponente\nPorcentaje\nDetalles\n\n\n\n\nEx√°menes parciales (3)\n75% (25% c/u)\nEvaluaciones te√≥rico-pr√°cticas al final de cada unidad.\n\n\nProyecto final\n15%\nIndividual o en equipos de m√°ximo 3 integrantes. Incluye 1 avance obligatorio durante el semestre.\n\n\nEjercicios de clase\n10%\nEntrega individual. Ejercicios, pseudoc√≥digo, pr√°cticas guiadas.\n\n\n\n\nNota importante:\n- La calificaci√≥n que se reporta por parcial corresponde √∫nicamente al examen parcial y tiene car√°cter informativo.\n- Los ejercicios se revisar√°n al final de la clase o, en su defecto, al inicio de la siguiente clase si as√≠ se indica.\n- No se recibir√°n ejercicios fuera de tiempo, excepto en casos debidamente justificados y avalados por la coordinaci√≥n de carrera."
  },
  {
    "objectID": "clases/01_logistica.html#fechas",
    "href": "clases/01_logistica.html#fechas",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Fechas importantes",
    "text": "Fechas importantes\n\n\n\nEvento\nFecha\n\n\n\n\nüü¢ INICIO DE SEMESTRE\nMartes 13 de Enero\n\n\nüü° 1era evaluaci√≥n parcial\nMi√©rcoles 11 de febrero\n\n\nüü° 2da evaluaci√≥n parcial\nMi√©rcoles 25 de marzo\n\n\nüü° Evaluaci√≥n final\nLunes 04 de mayo\n\n\nüîµ Entrega de calificaciones finales\nMi√©rcoles 06 de mayo\n\n\nüî¥ FIN DE SEMESTRE\nViernes 08 de Mayo"
  },
  {
    "objectID": "clases/01_logistica.html#material",
    "href": "clases/01_logistica.html#material",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Material de estudio",
    "text": "Material de estudio\n\n\n\n\n\n\n\nLibro\nDescripci√≥n\n\n\n\n\n\nHow to Think Like a Computer Scientist, 3rd Edition (Using Python 3.x)\n\n\n\nEl Libro de Python\n\n\n\nIntroduction to Computation and Programming Using Python, 3rd edition John V. Guttag"
  },
  {
    "objectID": "clases/01_logistica.html#diagnostico",
    "href": "clases/01_logistica.html#diagnostico",
    "title": "Clase 01 - Log√≠stica del curso",
    "section": "Actividad diagn√≥stica",
    "text": "Actividad diagn√≥stica\nAbrir formulario de diagn√≥stico: https://forms.office.com/r/iy9LhBQ1XE\nEscanea el c√≥digo QR:"
  },
  {
    "objectID": "clases/03_poo.html#contenido",
    "href": "clases/03_poo.html#contenido",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Contenido",
    "text": "Contenido\n\nIntroducci√≥n\n\nDefinici√≥n\nPilares\n\nClases y objetos\n\n¬øQu√© es una clase?\n¬øQu√© es un objeto?\nEjemplos y analog√≠as de clase y objeto\n\n¬øC√≥mo crear una clase y un objeto en Python?\n\nSintaxis\n¬øQu√© es un constructor?\n\nEncapsulamiento\nPolimorfismo\nHerencia\nAbstracci√≥n"
  },
  {
    "objectID": "clases/03_poo.html#intro",
    "href": "clases/03_poo.html#intro",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Introducci√≥n (paradigmas de programaci√≥n)",
    "text": "Introducci√≥n (paradigmas de programaci√≥n)\n\n\n\nExisten muchos paradigmas (estilos gen√©ricos) de programaci√≥n:\n\n\n\nProgramaci√≥n Declarativa\nProgramaci√≥n Imperativa\nProgramaci√≥n Estructurada\nProgramaci√≥n L√≥gica\nProgramaci√≥n Funcional\nProgramaci√≥n Orientada a Objetos"
  },
  {
    "objectID": "clases/03_poo.html#def",
    "href": "clases/03_poo.html#def",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Programaci√≥n Orientada a Objetos",
    "text": "Programaci√≥n Orientada a Objetos\n\n\n\nLa Programaci√≥n Orientada a Objetos es un paradigma que consiste en modelar sistemas a trav√©s de la creaci√≥n de objetos que contienen atributos y m√©todos.\nTiene como objetivos el facilitar el desarrollo de software robusto y adaptable a medida que el proyecto crece y mejorar el mantenimiento del software mediante la estructuraci√≥n en clases, facilitando la comprensi√≥n y modificaciones.\n\n\nPilares\nPara cumplir los objetivos anteriores, se utilizan los siguientes pilares, que explicaremos durante esta sesi√≥n.\n\nAbstracci√≥n: Simplifica la representaci√≥n de un objeto, centr√°ndose en aspectos esenciales.\nEncapsulamiento: Oculta detalles internos, exponiendo solo interfaces necesarias.\nPolimorfismo: Capacidad de objetos de diferentes clases de comportarse de manera uniforme (interfaz com√∫n).\nHerencia: Crear nuevas clases basadas en clases existentes.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbstracci√≥n\nEncapsulamiento\n\n\n\n\n\n\nPolimorfismo\nHerencia\n\n\n\nIm√°genes de los apuntes de nlaredo.tecnm.mx y stayfreemagazine.org"
  },
  {
    "objectID": "clases/03_poo.html#clases-objs",
    "href": "clases/03_poo.html#clases-objs",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Clases y objetos",
    "text": "Clases y objetos\nHemos visto que Python ofrece distintos tipos de datos para crear variables (int, float, String, etc), pero tambi√©n ofrece la posibilidad de crear nuestros propios tipos de datos para modelar conceptos m√°s complejos."
  },
  {
    "objectID": "clases/03_poo.html#howto",
    "href": "clases/03_poo.html#howto",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "¬øC√≥mo crear una clase y un objeto en Python?",
    "text": "¬øC√≥mo crear una clase y un objeto en Python?\nSintaxis\nPara crear una clase, se utiliza la palabra clave class, seguida del nombre de la clase y dos puntos.\nclass MiClase:\n    pass  # pass no realiza ninguna acci√≥n, se usa para indicar que aqu√≠ pondremos m√°s c√≥digo en el futuro"
  },
  {
    "objectID": "clases/03_poo.html#qu√©-son-los-atributos",
    "href": "clases/03_poo.html#qu√©-son-los-atributos",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "¬øQu√© son los atributos?",
    "text": "¬øQu√© son los atributos?\n\nSon variables que pertenecen a un objeto espec√≠fico de una clase.\nRepresentan caracter√≠sticas o propiedades del objeto.\nEn Python, los atributos pueden ser de dos tipos principales:\n\natributos de instancia\natributos de clase.\n\n\n\n\n\n\n\n\n\n\n\nTipo de atributo\nDefinici√≥n\nAcceso desde objeto\n¬øSe comparte entre objetos?\n\n\n\n\nDe instancia\nDentro de __init__ con self.\nobj.atributo\n‚ùå No\n\n\nDe clase\nDentro de la clase, fuera de m√©todos\nClase.atributo o obj.atributo\n‚úÖ S√≠"
  },
  {
    "objectID": "clases/03_poo.html#qu√©-son-los-m√©todos",
    "href": "clases/03_poo.html#qu√©-son-los-m√©todos",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "¬øQu√© son los m√©todos?",
    "text": "¬øQu√© son los m√©todos?\n\nSon funciones que est√°n definidas dentro de esa clase y act√∫an sobre los atributos que pertenecen a la misma.\nRepresentan acciones o comportamientos del objeto.\nHay tres diferentes tipos de m√©todos que puedes tener en una clase de Python:\n\nM√©todos de instancia\nM√©todos de clase\nM√©todos est√°ticos\n\n\n\n\n\n\n\n\n\n\n\n\nTipo de m√©todo\nDecorador\nPrimer par√°metro\nAccede a atributos\nUso principal\n\n\n\n\nInstancia\n‚Äî\nself\nS√≠ (de instancia)\nComportamiento espec√≠fico del objeto\n\n\nClase\n@classmethod\ncls\nS√≠ (de clase)\nAcceso/modificaci√≥n compartida\n\n\nEst√°tico\n@staticmethod\n‚Äî\nNo\nFunciones utilitarias dentro de clase"
  },
  {
    "objectID": "clases/03_poo.html#encapsulamiento",
    "href": "clases/03_poo.html#encapsulamiento",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Encapsulamiento",
    "text": "Encapsulamiento\n\n\n\nComo hemos visto, en Python podemos acceder a los atributos de clase con la palabra reservada self desde dentro de la clase, y con el nombre del objeto/clase, punto, y nombre del atributo desde el exterior (en el programa principal, m√≥dulo o en otra clase).\nNo obstante, en algunas ocasiones vamos a preferir que los atributos y m√©todos no sean accesibles desde el exterior, es decir, que sean privados.\n\n\n\nIm√°genes de los apuntes de nlaredo.tecnm.mx"
  },
  {
    "objectID": "clases/03_poo.html#qu√©-es-el-encapsulamiento",
    "href": "clases/03_poo.html#qu√©-es-el-encapsulamiento",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "¬øQu√© es el encapsulamiento?",
    "text": "¬øQu√© es el encapsulamiento?\n\nEs uno de los pilares de la programaci√≥n orientada a objetos (OOP).\nSe refiere a la ocultaci√≥n de los detalles internos de una clase y la restricci√≥n del acceso directo a ciertos componentes."
  },
  {
    "objectID": "clases/03_poo.html#por-qu√©-hacer-encapsulamiento",
    "href": "clases/03_poo.html#por-qu√©-hacer-encapsulamiento",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "¬øPor qu√© hacer encapsulamiento?",
    "text": "¬øPor qu√© hacer encapsulamiento?\n\nProtege un objeto del acceso no deseado mediante c√≥digo fuera de la clase. EJ: Una aplicaci√≥n bancaria proh√≠be a un cliente cambiar el saldo de una Cuenta.\nPermite cambiar/actualizar la implementaci√≥n de la clase si es necesario, sin que eso afecte el funcionamiento de la misma. EJ: Podr√≠amos cambiar la l√≥gica detr√°s de un m√©todo, pero su nombre y par√°metros no cambian, as√≠ que se pueden seguir utilizando de la misma manera.\nPermite restringir el estado de los objetos (atributos invariantes)."
  },
  {
    "objectID": "clases/03_poo.html#polimorfismo",
    "href": "clases/03_poo.html#polimorfismo",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Polimorfismo",
    "text": "Polimorfismo\n\n\n\nEtimol√≥gicamente, ‚Äúpolimorfismo‚Äù significa ‚Äúmuchas formas‚Äù.\nEl polimorfismo es un principio de la POO que permite que distintos objetos respondan a la misma operaci√≥n (funci√≥n o m√©todo) de maneras diferentes.\nEn POO, el polimorfismo se manifiesta de varias maneras:\n\nCon m√©todos\nCon sobrecarga de operadores\nCon herencia\n\n\n\n\nIm√°genes de stayfreemagazine.org"
  },
  {
    "objectID": "clases/03_poo.html#herencia",
    "href": "clases/03_poo.html#herencia",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Herencia",
    "text": "Herencia\n\n\n\nLa herencia es un mecanismo de la POO que permite a una clase adquirir atributos y m√©todos de otra clase.\nSe utiliza para modelar relaciones jer√°rquicas entre clases.\n\n\n\nIm√°genes de los apuntes de nlaredo.tecnm.mx\n\n\n\nClase base\n\nLas clases existentes se llaman clases base. Son las que proporcionan los atributos y m√©todos.\nTambi√©n reciben otros nombres como superclase, clase padre o antepasado.\n\nClase derivada\n\nLa clase que hereda de otra se llama clase derivada.\nTambi√©n se llama con otros nombres como subclase, clase secundaria y descendiente.\nLa clase derivada hereda los atributos/m√©todos de la clase base y normalmente contiene atributos/m√©todos adicionales.\n\n\n\nImagen de www.unipamplona.edu.co"
  },
  {
    "objectID": "clases/03_poo.html#sintaxis-1",
    "href": "clases/03_poo.html#sintaxis-1",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Sintaxis",
    "text": "Sintaxis\n\nEn Python, la herencia se implementa mediante el uso del operador ().\nPor ejemplo, para crear una clase derivada de la clase Vehiculo, se puede usar el siguiente c√≥digo:\n\n‚Äì\nLa funci√≥n super\n\nLa funci√≥n super() es una funci√≥n incorporada que se utiliza para acceder a m√©todos y atributos de una clase base.\nSe puede usar para llamar a m√©todos y atributos de la clase base sin tener que especificar expl√≠citamente el nombre de la clase base.\n\n\nclass Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def __str__(self):\n        return f'Persona (nombre: {self.nombre})'\n\nclass Estudiante(Persona):\n    def __init__(self, nombre, carrera):\n        super().__init__(nombre)  # llama al constructor de Persona\n        self.carrera = carrera\n    def __str__(self):\n        return f'Estudiante (nombre: {self.nombre}; carrera: {self.carrera})'\n\nestudiante1 = Estudiante(\"Ra√∫l Rojas\", \"Ing. en Rob√≥tica\")\nprint(estudiante1)\n\nEstudiante (nombre: Ra√∫l Rojas; carrera: Ing. en Rob√≥tica)"
  },
  {
    "objectID": "clases/03_poo.html#abstraccion",
    "href": "clases/03_poo.html#abstraccion",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Abstracci√≥n",
    "text": "Abstracci√≥n\n\n\n\nLa abstracci√≥n es el principio de la POO que permite ocultar los detalles internos de implementaci√≥n de un objeto y exponer solo lo necesario para su uso.\nEn otras palabras, permite modelar lo esencial de una entidad y ocultar lo irrelevante o complejo para el usuario del objeto.\n\nUn auto: puedes encenderlo y conducirlo sin saber c√≥mo funciona el motor internamente.\nUna cafetera: basta con oprimir un bot√≥n; no necesitas conocer el sistema de calentamiento ni presi√≥n.\nEn ambos casos, el usuario interact√∫a con una interfaz simple y el funcionamiento interno est√° abstra√≠do.\n\n\n\n\nIm√°genes de los apuntes de nlaredo.tecnm.mx"
  },
  {
    "objectID": "clases/03_poo.html#referencias",
    "href": "clases/03_poo.html#referencias",
    "title": "Clase 03 - Programaci√≥n Orientada a Objetos",
    "section": "Referencias",
    "text": "Referencias\n\nPhillips, D. (n.d.). Python 3 object-oriented programming (2nd ed.). Retrieved from https://library.kre.dp.ua/‚Ä¶\nJordan, K. (n.d.). Classes and objects. Retrieved from https://20f.comp110.com/‚Ä¶"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html",
    "href": "clases2025/clase01_logistica-curso.html",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\nImagen de coderpad.io"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#clase-01-log√≠stica-del-curso",
    "href": "clases2025/clase01_logistica-curso.html#clase-01-log√≠stica-del-curso",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#contenido",
    "href": "clases2025/clase01_logistica-curso.html#contenido",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.2 Contenido",
    "text": "1.2 Contenido\n\nAcerca del curso\n\nInformaci√≥n del curso\nQu√© esperar y que NO esperar del curso\nPrerrequisitos\nObjetivos\n\nC√≥digo de conducta\n\nComunicaci√≥n oficial 455\n\nTemario\nEvaluaci√≥n\nFechas importantes\nMaterial de estudio"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#acerca-del-curso",
    "href": "clases2025/clase01_logistica-curso.html#acerca-del-curso",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.3 Acerca del curso",
    "text": "1.3 Acerca del curso"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#programaci√≥n-aplicada-ii-1",
    "href": "clases2025/clase01_logistica-curso.html#programaci√≥n-aplicada-ii-1",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.4 Programaci√≥n Aplicada II",
    "text": "1.4 Programaci√≥n Aplicada II\n\n\n\nHorario: Lunes y Jueves, 09:00 a 11:00 hrs\nDocente: Dra. Dora Alvarado\n\nEmail: 27382@iberoleon.edu.mx; doraelisa.alvaradocarrillo@iberoleon.edu.mx\n\nAvisos, ex√°menes, tareas a trav√©s de la p√°gina del curso en Moodle.\n\n\n\n\n\n  \n\n\n\n\n\n1.4.1 Qu√© esperar y qu√© no esperar del curso\n\n&lt;h4 style=\"background-color:#FFB695;\"&gt;En esta clase NO aprenderemos:&lt;/h4&gt;\n  &lt;ul&gt;\n    &lt;li&gt;Tipos de variables (enteros, flotantes, listas, tuplas, cadenas, etc)&lt;/li&gt;\n    &lt;li&gt;Operadores (de asignaci√≥n, aritm√©ticos, relacionales, l√≥gicos, etc)&lt;/li&gt;\n    &lt;li&gt;Estructuras de control (if, while, for)&lt;/li&gt;\n    &lt;li&gt;Funciones (incorporadas, definidas, an√≥nimas)&lt;/li&gt;\n  &lt;/ul&gt;\n\n\n    &lt;h4 style=\"background-color:#96D1CD; \"&gt;En esta clase SI aprenderemos:&lt;/h4&gt;\n    &lt;ul&gt;\n        &lt;li&gt;Programaci√≥n orientada a objetos (polimorfismo, herencia, abstracci√≥n, etc)&lt;/li&gt;\n        &lt;li&gt;Buenas pr√°cticas de desarrollo de software (Pruebas de software, debugging, complejidad)&lt;/li&gt;\n        &lt;li&gt;Bibliotecas externas (numpy, matplotlib, pandas)&lt;/li&gt;\n        &lt;li&gt;Algoritmos (con grafos, aleatorios, geom√©tricos)&lt;/li&gt;\n      &lt;/ul&gt;\n\n\n\n1.4.2 Prerrequisitos\n\nPrerequisitos: Programaci√≥n Aplicada I\nConocimientos previos: Conceptos b√°sicos de programaci√≥n con Python, incluyendo variables, operadores, estructuras condicionales, estructuras de repetici√≥n, funciones, manejo de archivos y manejo de bibliotecas est√°ndar de Python.\n\n\n\n1.4.3 Objetivos\n\nComprender y aplicar los conceptos fundamentales de Programaci√≥n Orientada a Objetos con Python, incluyendo clases, objetos, constructores, encapsulamiento, y polimorfismo.\nAplicar principios del desarrollo de software como manejo de errores, aserciones, pruebas de software y debugging para mejorar la calidad y robustez del c√≥digo.\nUtilizar eficientemente bibliotecas externas como NumPy, Pandas y Matplotlib para an√°lisis num√©rico, manipulaci√≥n de datos y visualizaci√≥n.\nFamiliarizarse con algoritmos de grafos, aleatorios y geom√©tricos, aplicando estos conocimientos a la resoluci√≥n de problemas espec√≠ficos.\nTrabajar en proyectos de desarrollo de software de manera colaborativa, desarrollando habilidades de presentaci√≥n y comunicaci√≥n.\n\n\n\n\n1.5 C√≥digo de conducta\nVersi√≥n resumida:\n\nCualquier indisciplina en el sal√≥n de clase implicar√° la salida del sal√≥n con falta y un reporte a la coordinaci√≥n de la carrera.\n\n\n\n1.6 C√≥digo de conducta\nVersi√≥n extendida:\n\nRespetar las opiniones, antecedentes y experiencias de todos los miembros del grupo.\n\nTodas las preguntas sobre la clase son bienvenidas. Evitar lenguaje ofensivo o actitudes que desalienten la participaci√≥n.\n\nSer responsables. Revisar notas de clase, asistir a clases, completar ejercicios y tareas, y participar en los ex√°menes.\n\nSer proactivas y proactivos durante el curso. Participar en la clase y compartir el conocimiento, sin caer en el plagio.\n\nDurante las clases, evitar distracciones como el uso innecesario de dispositivos electr√≥nicos.\n\nEntregar todas las tareas y ejercicios a tiempo. Retrasos tendr√°n penalizaciones, salvo casos justificados.\n\n\n1.6.0.1 Mis compromisos como docente:\n\nEstructurar mis clases y alinearlas con los objetivos del curso.\n\nEstar disponible para resolver dudas y dar retroalimentaci√≥n.\n\nRespetar los criterios de evaluaci√≥n establecidos desde el inicio del curso.\n\n\n\n1.6.0.2 Mis expectativas hacia el trabajo estudiantil:\n\nProhibido compartir o copiar c√≥digo. Esta permitido apoyarse de ejemplos en internet, pero aseg√∫rate de entenderlos y adaptarlos a tu propio trabajo. Adem√°s, si usas recursos abiertos, debes mencionarlos expl√≠citamente en tus entregas.\n\nTodas las entregas deben reflejar tu propio esfuerzo y aprendizaje. El plagio, en cualquier forma, ser√° sancionado seg√∫n las pol√≠ticas institucionales.\n\n\n\n1.6.0.3 Consecuencias del incumplimiento en el c√≥digo de conducta\n\nLos incumplimientos menores, como interrupciones en clase o descuidos ocasionales, resultar√°n en una advertencia inicial. Si la conducta persiste, se podr√° descontar la asistencia del d√≠a y/o reducir la calificaci√≥n en participaci√≥n.\nLas faltas graves, como el plagio o comportamientos irrespetuosos, se reportar√°n formalmente a las autoridades acad√©micas y podr√°n implicar calificaciones de ‚Äú0‚Äù en actividades espec√≠ficas, e incluso la exclusi√≥n del curso en casos de gravedad o reincidencia.\n\n\nComunicaci√≥n Oficial No.¬†455: Lineamientos acad√©micos sobre plagio y fraude\n\n\n\nComunicaci√≥n Oficial No.¬†455: Lineamientos acad√©micos sobre plagio y fraude\n\n\n\nComunicaci√≥n Oficial No.¬†455: Lineamientos acad√©micos sobre plagio y fraude\n\n\n\n\n\n1.7 Temario (sujeto a cambios seg√∫n sea necesario):\n\n\n\n1.7.1 Evaluaci√≥n\n\n\n\n1ER y 2DO PARCIAL\n\n\n\nCriterio\n%\n\n\n\n\nüìöExamen\n50\n\n\n‚úèÔ∏èEjercicios de clase\n20\n\n\nüìùTareas\n20\n\n\nüí¨Participaciones\n10\n\n\n\n\n\n\n\n\n3ER PARCIAL\n\n\n\nCriterio\n%\n\n\n\n\nüìöExamen o tarea final\n20\n\n\n‚úèÔ∏èEjercicios de clase\n20\n\n\nüìäProyecto final\n50\n\n\nüí¨Participaciones\n10\n\n\n\n\n\n\n\n\nEVALUACI√ìN FINAL\n\n\n\nCriterio\n%\n\n\n\n\n1er Parcial\n30\n\n\n2do Parcial\n30\n\n\n3er Parcial\n40\n\n\n\n\n\n\n\n\n1.7.2 Fechas importantes\n\n\n\nEvento\nFecha\n\n\n\n\nüîµüè´ INICIO DE SEMESTRE\nMartes 14 de Enero\n\n\nüü°üìö 1era evaluaci√≥n parcial\nJueves 20 de Febrero\n\n\nüü°üìö 2da evaluaci√≥n parcial\nLunes 07 de Abril\n\n\nüü°üìö Evaluaci√≥n final\nLunes 28 de Abril\n\n\nüü¢üìä Presentaci√≥n de proyectos\nLunes 05 de Mayo\n\n\nüìã Entrega de calificaciones finales\nJueves 08 de Mayo\n\n\nüî¥üèÅ FIN DE SEMESTRE\nViernes 09 de Mayo\n\n\n\n\n\n\n1.8 Material de estudio\n\n\n\n\nHow to Think Like a Computer Scientist, 3rd Edition (Using Python 3.x)  Jeffrey Elkner, Peter Wentworth, Allen B. Downey, and Chris Meyers  Ilustrado por: Dario Mitchell  - Link: How to Think Like a Computer Scientist\n\n\n\n\n\nEl Libro de Python  - Link: El Libro de Python\n\n\n‚Äî\n‚Äî\n\n\n\nIntroduction to Computation and Programming Using Python, 3rd edition  John V. Guttag  \n\n\n‚Äî\n‚Äî"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#c√≥digo-de-conducta",
    "href": "clases2025/clase01_logistica-curso.html#c√≥digo-de-conducta",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.5 C√≥digo de conducta",
    "text": "1.5 C√≥digo de conducta\nVersi√≥n resumida:\n\nCualquier indisciplina en el sal√≥n de clase implicar√° la salida del sal√≥n con falta y un reporte a la coordinaci√≥n de la carrera."
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#c√≥digo-de-conducta-1",
    "href": "clases2025/clase01_logistica-curso.html#c√≥digo-de-conducta-1",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.6 C√≥digo de conducta",
    "text": "1.6 C√≥digo de conducta\nVersi√≥n extendida:\n\nRespetar las opiniones, antecedentes y experiencias de todos los miembros del grupo.\n\nTodas las preguntas sobre la clase son bienvenidas. Evitar lenguaje ofensivo o actitudes que desalienten la participaci√≥n.\n\nSer responsables. Revisar notas de clase, asistir a clases, completar ejercicios y tareas, y participar en los ex√°menes.\n\nSer proactivas y proactivos durante el curso. Participar en la clase y compartir el conocimiento, sin caer en el plagio.\n\nDurante las clases, evitar distracciones como el uso innecesario de dispositivos electr√≥nicos.\n\nEntregar todas las tareas y ejercicios a tiempo. Retrasos tendr√°n penalizaciones, salvo casos justificados.\n\n\n1.6.0.1 Mis compromisos como docente:\n\nEstructurar mis clases y alinearlas con los objetivos del curso.\n\nEstar disponible para resolver dudas y dar retroalimentaci√≥n.\n\nRespetar los criterios de evaluaci√≥n establecidos desde el inicio del curso.\n\n\n\n1.6.0.2 Mis expectativas hacia el trabajo estudiantil:\n\nProhibido compartir o copiar c√≥digo. Esta permitido apoyarse de ejemplos en internet, pero aseg√∫rate de entenderlos y adaptarlos a tu propio trabajo. Adem√°s, si usas recursos abiertos, debes mencionarlos expl√≠citamente en tus entregas.\n\nTodas las entregas deben reflejar tu propio esfuerzo y aprendizaje. El plagio, en cualquier forma, ser√° sancionado seg√∫n las pol√≠ticas institucionales.\n\n\n\n1.6.0.3 Consecuencias del incumplimiento en el c√≥digo de conducta\n\nLos incumplimientos menores, como interrupciones en clase o descuidos ocasionales, resultar√°n en una advertencia inicial. Si la conducta persiste, se podr√° descontar la asistencia del d√≠a y/o reducir la calificaci√≥n en participaci√≥n.\nLas faltas graves, como el plagio o comportamientos irrespetuosos, se reportar√°n formalmente a las autoridades acad√©micas y podr√°n implicar calificaciones de ‚Äú0‚Äù en actividades espec√≠ficas, e incluso la exclusi√≥n del curso en casos de gravedad o reincidencia.\n\n\nComunicaci√≥n Oficial No.¬†455: Lineamientos acad√©micos sobre plagio y fraude\n\n\n\nComunicaci√≥n Oficial No.¬†455: Lineamientos acad√©micos sobre plagio y fraude\n\n\n\nComunicaci√≥n Oficial No.¬†455: Lineamientos acad√©micos sobre plagio y fraude"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#temario-sujeto-a-cambios-seg√∫n-sea-necesario",
    "href": "clases2025/clase01_logistica-curso.html#temario-sujeto-a-cambios-seg√∫n-sea-necesario",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.7 Temario (sujeto a cambios seg√∫n sea necesario):",
    "text": "1.7 Temario (sujeto a cambios seg√∫n sea necesario):\n\n\n\n1.7.1 Evaluaci√≥n\n\n\n\n1ER y 2DO PARCIAL\n\n\n\nCriterio\n%\n\n\n\n\nüìöExamen\n50\n\n\n‚úèÔ∏èEjercicios de clase\n20\n\n\nüìùTareas\n20\n\n\nüí¨Participaciones\n10\n\n\n\n\n\n\n\n\n3ER PARCIAL\n\n\n\nCriterio\n%\n\n\n\n\nüìöExamen o tarea final\n20\n\n\n‚úèÔ∏èEjercicios de clase\n20\n\n\nüìäProyecto final\n50\n\n\nüí¨Participaciones\n10\n\n\n\n\n\n\n\n\nEVALUACI√ìN FINAL\n\n\n\nCriterio\n%\n\n\n\n\n1er Parcial\n30\n\n\n2do Parcial\n30\n\n\n3er Parcial\n40\n\n\n\n\n\n\n\n\n1.7.2 Fechas importantes\n\n\n\nEvento\nFecha\n\n\n\n\nüîµüè´ INICIO DE SEMESTRE\nMartes 14 de Enero\n\n\nüü°üìö 1era evaluaci√≥n parcial\nJueves 20 de Febrero\n\n\nüü°üìö 2da evaluaci√≥n parcial\nLunes 07 de Abril\n\n\nüü°üìö Evaluaci√≥n final\nLunes 28 de Abril\n\n\nüü¢üìä Presentaci√≥n de proyectos\nLunes 05 de Mayo\n\n\nüìã Entrega de calificaciones finales\nJueves 08 de Mayo\n\n\nüî¥üèÅ FIN DE SEMESTRE\nViernes 09 de Mayo"
  },
  {
    "objectID": "clases2025/clase01_logistica-curso.html#material-de-estudio",
    "href": "clases2025/clase01_logistica-curso.html#material-de-estudio",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.8 Material de estudio",
    "text": "1.8 Material de estudio\n\n\n\n\nHow to Think Like a Computer Scientist, 3rd Edition (Using Python 3.x)  Jeffrey Elkner, Peter Wentworth, Allen B. Downey, and Chris Meyers  Ilustrado por: Dario Mitchell  - Link: How to Think Like a Computer Scientist\n\n\n\n\n\nEl Libro de Python  - Link: El Libro de Python\n\n\n‚Äî\n‚Äî\n\n\n\nIntroduction to Computation and Programming Using Python, 3rd edition  John V. Guttag  \n\n\n‚Äî\n‚Äî"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html",
    "href": "clases2025/clase03_clases-objetos-constructores.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#clase-03-clases-objetos-constructores",
    "href": "clases2025/clase03_clases-objetos-constructores.html#clase-03-clases-objetos-constructores",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#temario",
    "href": "clases2025/clase03_clases-objetos-constructores.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 Temario",
    "text": "2 Temario"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#contenido",
    "href": "clases2025/clase03_clases-objetos-constructores.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Contenido",
    "text": "3 Contenido\n\nIntroducci√≥n a la Programaci√≥n Orientada a Objetos\n\nDefinici√≥n\nObjetivos\nPilares\n\nClases y objetos\n\n¬øQu√© es una clase?\n¬øQu√© es un objeto?\nEjemplos y analog√≠as de clase y objeto\n\n¬øC√≥mo crear una clase y un objeto en Python?\n\nSintaxis\n¬øQu√© es un constructor?"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#introducci√≥n-a-la-programaci√≥n-orientada-a-objetos",
    "href": "clases2025/clase03_clases-objetos-constructores.html#introducci√≥n-a-la-programaci√≥n-orientada-a-objetos",
    "title": "Programaci√≥n Aplicada II",
    "section": "4 Introducci√≥n a la Programaci√≥n Orientada a Objetos",
    "text": "4 Introducci√≥n a la Programaci√≥n Orientada a Objetos\n\n\nExisten muchos paradigmas (estilos gen√©ricos) de programaci√≥n:\n\n\n\n\n\nProgramaci√≥n Estructurada\nProgramaci√≥n Orientada a Objetos\nProgramaci√≥n L√≥gica\nProgramaci√≥n Funcional\nProgramaci√≥n Declarativa\nProgramaci√≥n Imperativa\n\nProgramaci√≥n Estructurada üß±\n\nEs un paradigma que organiza el c√≥digo en bloques l√≥gicos para hacerlo m√°s f√°cil de entender, mantener y depurar. Se basa en tres estructuras principales:\n\nSecuencia: Instrucciones ejecutadas en orden.\nSelecci√≥n: Decisiones condicionales como if-else.\nIteraci√≥n: Repetici√≥n mediante bucles como for o while.\n\n\n\ncalificacion = float(input(\"Ingresa una calificaci√≥n (0-100): \"))\n\nif 0 &lt;= calificacion &lt;= 100:\n    total += calificacion\n    cantidad += 1\nelse:\n    print(\"‚ö†Ô∏è La calificaci√≥n debe estar entre 0 y 100.\")\n\nprint(\"Fin del programa.\")\n\nProgramaci√≥n Orientada a Objetosüß©\n\nOrganiza el c√≥digo en objetos, que combinan datos (atributos) y comportamientos (m√©todos). Este paradigma se enfoca en modelar entidades del mundo real.\n\n\nclass Rectangulo:\n    def __init__(self, base, altura):\n        self.base = base\n        self.altura = altura\n\n    def calcular_area(self):\n        return self.base * self.altura\n\nrectangulo = Rectangulo(5, 10)\nprint(rectangulo.calcular_area())  \n\nProgramaci√≥n L√≥gicaüß†\n\nSe basa en la l√≥gica formal y trabaja definiendo hechos, reglas y consultas.\nEn lugar de decirle al programa c√≥mo realizar una tarea, se especifica qu√© condiciones deben cumplirse.\n\n% Hechos\npadre(juan, maria).\npadre(juan, pedro).\n\n% Regla\nhermanos(X, Y) :- padre(P, X), padre(P, Y), X \\= Y.\n\n% Consulta\n?- hermanos(maria, pedro).  % Resultado: true\nProgramaci√≥n Funcionalüîó - Utiliza funciones, donde cada funci√≥n produce el mismo resultado si se le dan los mismos argumentos. - Las funciones pueden asignarse a variables o pasarse como argumentos.\n\n# Funci√≥n \ndef suma_cuadrados(lista):\n    return sum(x**2 for x in lista)\n\nnumeros = [1, 2, 3, 4]\nprint(suma_cuadrados(numeros))  # Resultado: 30\n\nProgramaci√≥n Declarativa - Describes qu√© debe hacerse, sin especificar c√≥mo lograrlo. - Se enfoca en el resultado, no en el proceso. - Los lenguajes SQL y HTML son ejemplos de este paradigma.\nSELECT nombre, edad FROM estudiantes WHERE edad &gt; 18;\nProgramaci√≥n Imperativa\n\nDescribe una serie de instrucciones que se ejecutan en un orden espec√≠fico para cambiar el estado del programa.\nSe enfoca en c√≥mo realizar tareas.\nUsa variables mutables y estructuras de control como bucles y condicionales.\nEs el enfoque m√°s tradicional y ampliamente utilizado.\n\n\nnumeros = [1, 2, 3, 4]\nsuma = 0\nfor numero in numeros:\n    suma += numero ** 2\nprint(suma)  # Resultado: 30\n\n\n(en el curso anterior estuvimos usando los paradigmas estructurado, funcional e imperativo)\n\n\n\n\n\nLos programas se ejecutan de forma secuencial (una instrucci√≥n tras otra).\nLo √∫nico que puede desviar el flujo del programa son las estructuras condicionales (como if-elif-else), las estructuras de repetici√≥n (como for, while) o las funciones que encapsulan bloques de c√≥digo reutilizable.\nEstos paradigmas se enfocan en el control preciso del flujo del programa, lo que significa que el programador debe especificar exactamente c√≥mo deben ejecutarse las instrucciones.\n\n\n&lt;img style=\"width: 55%; display: block; margin: auto\" src=\"https://edteam-media.s3.amazonaws.com/blogs/original/f1f62d2f-2403-4b53-8636-8d0fd31a319b.png\" alt=\"Your Image\"&gt;\n\nImagen de edteam-media.s3\n\n(en este curso abordaremos el paradigma orientado a objetos)"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#programaci√≥n-orientada-a-objetos",
    "href": "clases2025/clase03_clases-objetos-constructores.html#programaci√≥n-orientada-a-objetos",
    "title": "Programaci√≥n Aplicada II",
    "section": "5 Programaci√≥n Orientada a Objetos",
    "text": "5 Programaci√≥n Orientada a Objetos\nLa Programaci√≥n Orientada a Objetos es un paradigma que consiste en modelar sistemas a trav√©s de la creaci√≥n de objetos que contienen atributos y m√©todos.\n\nObjetivos:\n\n\nEscalabilidad: Facilitar el desarrollo de software robusto y adaptable a medida que el proyecto crece.\nOrganizaci√≥n: Mejorar el mantenimiento del software mediante la estructuraci√≥n en clases, facilitando la comprensi√≥n y modificaciones.\nAgilidad: Permitir la r√°pida incorporaci√≥n de nuevas caracter√≠sticas y adaptaciones a trav√©s de una arquitectura flexible.\nReutilizaci√≥n: Aprovechar eficientemente el c√≥digo existente mediante la modularidad y la herencia, reduciendo la duplicaci√≥n y optimizando el desarrollo.\nUsabilidad: Mejorar la experiencia general al modelar interfaces m√°s intuitivas y coherentes con el uso de objetos y clases.\n\n\nPilares:\n\nPara cumplir los objetivos anteriores, se utilizan los siguientes conceptos, que explicaremos durante este primer parcial.\n\nAbstracci√≥n: Simplifica la representaci√≥n de un objeto, centr√°ndose en aspectos esenciales. Las clases act√∫an como modelos abstractos.\nEncapsulamiento: Oculta detalles internos, exponiendo solo interfaces necesarias. Mejora la seguridad y organizaci√≥n del c√≥digo.\nPolimorfismo: Se refiere a la capacidad de objetos de diferentes clases de comportarse de manera uniforme cuando se trata con una interfaz com√∫n.\nHerencia: Permite crear nuevas clases basadas en clases existentes. Fomenta la reutilizaci√≥n de c√≥digo y jerarqu√≠as de clases.\n\n\n\n\n\n\n\n\nAbstracci√≥n\nEncapsulamiento\n\n\n\n\n\n\n\n\nPolimorfismo\nHerencia\n\n\n\n\n\n\n\nIm√°genes de los apuntes de nlaredo.tecnm.mx y stayfreemagazine.org"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#clases-y-objetos",
    "href": "clases2025/clase03_clases-objetos-constructores.html#clases-y-objetos",
    "title": "Programaci√≥n Aplicada II",
    "section": "6 Clases y objetos",
    "text": "6 Clases y objetos\nHasta ahora, hemos visto que Python ofrece distintos tipos de datos para crear variables (int, float, String, etc), pero tambi√©n ofrece la posibilidad de crear nuestros propios tipos de datos para modelar conceptos m√°s complejos.\n\n¬øQu√© es una clase?\n\n\nEs una plantilla para definir un tipo de dato compuesto por atributos (variables) y m√©todos (funciones/comportamientos).\n\n\n¬øQu√© es un Objeto?\n\n\nEs un valor o variable cuyo tipo de dato es compuesto, es decir es elemento que tiene atributos y m√©todos.\nM√°s t√©cnicamente, un objeto es una instancia de una clase en la memoria del programa.\n\n\nAlgunos ejemplos y analog√≠as\n\n\nPiensa en una clase como un cortador de galletas y en un objeto como una galleta en particular.\n\n\nImagen de Twitter\n\nOtra manera de asociar los conceptos es pensar en una clase como un plano, y en un objeto como el elemento que ya se ha construido a partir de dicho plano.\n\n\nImagen de codestall.wordpress.com\n\nUn ejemplo de clase puede ser la plantilla de perfil de Twitter. Los atributos que deben tener los perfiles son nombre, fotograf√≠a, biograf√≠a, n√∫mero de seguidores, etc. Los m√©todos (o comportamientos) son postear, responder, reaccionar a una publicaci√≥n, etc.\n\n\nImagen de 20f.comp110.com/\n\nEjemplos de objetos de esta clase son perfiles ya creados en Twitter, con diferentes atributos (datos) dependiendo de cada persona u organizaci√≥n, aunque sus m√©todos (o acciones que pueden realizar) son los mismos."
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#c√≥mo-crear-una-clase-y-un-objeto-en-python",
    "href": "clases2025/clase03_clases-objetos-constructores.html#c√≥mo-crear-una-clase-y-un-objeto-en-python",
    "title": "Programaci√≥n Aplicada II",
    "section": "7 ¬øC√≥mo crear una clase y un objeto en Python?",
    "text": "7 ¬øC√≥mo crear una clase y un objeto en Python?\n\nPara crear una clase, se utiliza la palabra clave class, seguida del nombre de la clase y dos puntos.\n\n    class MiClase:\n        pass # pass no realiza ninguna acci√≥n, se usa para indicar que aqu√≠ pondremos m√°s c√≥digo en el futuro\n\nLa creaci√≥n de un objeto se realiza mediante la asignaci√≥n de una instancia de la clase a una variable. Es decir, escribimos el nombre que tendr√° el objeto a crear, el s√≠mbolo = y el nombre de la clase (tipo de dato del objeto) seguido de par√©ntesis.\n\n    mi_objeto = MiClase()\n\n## Ejemplo\n\n# Define una nueva clase (plantilla/tipo de dato/plano) llamada \"Estudiante\"\nclass Estudiante:\n    pass\n\n# Crea un objeto de la clase \"Estudiante\"\nnuevo_estudiante = Estudiante()\n# Imprime su tipo de dato\nprint(type(nuevo_estudiante)) # Imprime &lt;class '__main__.Estudiante'&gt;\n\n‚Ä¶Por ahora la clase estudiante no tiene definidos atributos ni m√©todos"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#qu√©-es-un-constructor",
    "href": "clases2025/clase03_clases-objetos-constructores.html#qu√©-es-un-constructor",
    "title": "Programaci√≥n Aplicada II",
    "section": "8 ¬øQu√© es un constructor?",
    "text": "8 ¬øQu√© es un constructor?\n\nUn constructor es un m√©todo especial en una clase que se llama autom√°ticamente cuando se crea un objeto de esa clase.\n(un m√©todo es una funci√≥n dentro de la clase)\nEn Python, el constructor se llama __init__ y se utiliza para inicializar los atributos del objeto.\nEl constructor puede tener cualquier n√∫mero de par√°metros, incluso ninguno.\nPor ejemplo, en nuestra clase Estudiante podemos agregar algunos atributos (variables) que se crear√°n al crear un nuevo objeto.\n\n\n# Define una nueva clase (plantilla/tipo de dato/plano) llamada \"Estudiante\"\nclass Estudiante:\n    def __init__(self, nombre, no_cuenta, asignaturas = []): # Constructor de la clase\n        self.nombre = nombre \n        self.no_cuenta = no_cuenta\n        self.asignaturas = asignaturas\n\n# Crea un objeto de la clase \"Estudiante\"\nestudiante1 = Estudiante(\"Ana\", \"192344-I\")\n\n# Imprime su tipo de dato\nprint(type(estudiante1)) # Imprime &lt;class '__main__.Estudiante'&gt;\n\n\nLa palabra self\n\n\nLa palabra self se refiere al objeto que est√° siendo creado o manipulado dentro de los m√©todos de la clase.\nCuando se llama a un m√©todo de una clase, la instancia (objeto) en la que se invoca ese m√©todo se pasa autom√°ticamente como el primer argumento, y se nombra convencionalmente como self.\nAunque self es solo una convenci√≥n y podr√≠a llamarse de otra manera, su uso es altamente recomendado para mantener un c√≥digo claro y f√°cil de entender."
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#qu√©-son-los-atributos",
    "href": "clases2025/clase03_clases-objetos-constructores.html#qu√©-son-los-atributos",
    "title": "Programaci√≥n Aplicada II",
    "section": "9 ¬øQu√© son los atributos?",
    "text": "9 ¬øQu√© son los atributos?\n\nSon variables que pertenecen a un objeto espec√≠fico de una clase.\nRepresentan caracter√≠sticas o propiedades del objeto.\nEn Python, los atributos pueden ser de dos tipos principales:\n\natributos de instancia\natributos de clase.\n\n\n\nAtributos de Instancia\n\n\nSon espec√≠ficos de cada instancia de la clase.\nCada objeto tiene su propia copia del atributo de instancia.\nSe definen dentro de los m√©todos de la clase: generalmente en el m√©todo init, utilizando el prefijo self.\nEjemplo:\n\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\nAtributos de Clase\n\n\nSon compartidos por todas las instancias de la clase.\nSe definen fuera de cualquier m√©todo de la clase, generalmente al principio de la clase.\nSe accede a trav√©s de la clase en lugar de a trav√©s de instancias individuales.\nEjemplo:\n\nclass Vehiculo:\n    cantidad_vehiculos = 0   # Atributo de clase\n    \n    def __init__(self, marca, modelo):\n        self.marca = marca   # Atributo de instancia\n        self.modelo = modelo   # Atributo de instancia\n        Vehiculo.cantidad_vehiculos += 1   # Acceso al atributo de clase\n\nVolviendo al ejemplo de la clase Estudiante ‚Ä¶\n\n\n# Define una nueva clase (plantilla/tipo de dato/plano) llamada \"Estudiante\"\nclass Estudiante:\n    \n    total_estudiantes = 0  # Atributo de clase, para contar el total de objetos tipo Estudiante\n    \n    def __init__(self, nombre, no_cuenta, asignaturas = []): # Constructor de la clase, \"self\" representa la instancia actual \n        self.nombre = nombre # Atributo de instancia\n        self.no_cuenta = no_cuenta # Atributo de instancia\n        self.asignaturas = asignaturas\n        \n        Estudiante.total_estudiantes += 1\n\nestudiante1 = Estudiante(\"Ana\", \"192344-I\")\notro_estudiante = Estudiante(\"Juan\", \"182621-M\")\n\n# Accede a los atributos del objeto estudiante1\nprint(estudiante1.nombre)  # Imprime \"Ana\"\nprint(estudiante1.no_cuenta)  # Imprime \"192344-I\"\nprint(estudiante1.asignaturas) # Imprime []\n\n# Accede a los atributos de la clase\nprint(Estudiante.total_estudiantes) # Imprime 2\n\n# Imprime su tipo de dato\nprint(type(estudiante1)) # Imprime &lt;class '__main__.Estudiante'&gt;\n\nPREGUNTA: ¬øC√≥mo imprimo los atributos del objeto otro_estudiante?"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#qu√©-son-los-m√©todos",
    "href": "clases2025/clase03_clases-objetos-constructores.html#qu√©-son-los-m√©todos",
    "title": "Programaci√≥n Aplicada II",
    "section": "10 ¬øQu√© son los m√©todos?",
    "text": "10 ¬øQu√© son los m√©todos?\n\nSon funciones que est√°n definidas dentro de esa clase y act√∫an sobre los atributos que pertenecen a la misma.\nRepresentan acciones o comportamientos del objeto.\nHay tres diferentes tipos de m√©todos que puedes tener en una clase de Python:\n\nM√©todos de instancia\nM√©todos de clase\nM√©todos est√°ticos\n\n\n\nM√©todos de Instancia\n\n\nSe definen con el primer par√°metro como self, que hace referencia a la instancia de la clase en s√≠.\nAcceden y manipulan los atributos de la instancia.\n\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n    def presentarse(self):\n        print(f\"Soy {self.nombre} y tengo {self.edad} a√±os.\")\n        \n# Uso de m√©todos de instancia\npersona1 = Persona(\"Frida\", 30)\npersona1.presentarse()  # Salida: Soy Frida y tengo 30 a√±os.\n\nM√©todos de clase:\n\n\nSe definen con el decorador @classmethod.\nEl primer par√°metro es la clase misma, por convenci√≥n llamado cls.\nSe utilizan para operaciones que involucran la clase en lugar de instancias individuales.\n\nimport math\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def obtener_area(self):\n        return math.pi * self.radio**2\n\n    @classmethod\n    def crear_con_diametro(cls, diametro):\n        return cls(diametro/2)\n\n# Uso de m√©todo de clase\ncirculo = Circulo.crear_con_diametro(5)\n\nM√©todos est√°ticos:\n\n\nSe definen con el decorador @staticmethod.\nNo toman una referencia a la instancia (self) o la clase (cls) como primer par√°metro.\nSe pueden llamar en la clase, sin crear una instancia.\n\nclass Calculadora:\n    @staticmethod\n    def sumar(a, b):\n        return a + b\n\n# Uso de m√©todos est√°ticos\nresultado_suma = Calculadora.sumar(5, 3)\nprint(f\"Suma: {resultado_suma}\")  # Salida: Suma: 8\n\nVolviendo al ejemplo de la clase Estudiante ‚Ä¶\n\n\nclass Estudiante:\n    total_estudiantes = 0  # Atributo de clase para contar el total de estudiantes\n\n    def __init__(self, nombre, no_cuenta, asignaturas=[]):\n        self.nombre = nombre\n        self.no_cuenta = no_cuenta\n        self.asignaturas = asignaturas\n        Estudiante.total_estudiantes += 1\n\n    def agregar_asignatura(self, asignatura):\n        self.asignaturas.append(asignatura)\n        print(f\"{self.nombre} ha agregado la asignatura {asignatura}.\")\n\n    @classmethod\n    def obtener_total_estudiantes(cls):\n        print(f\"Total de estudiantes: {cls.total_estudiantes}\")\n\n    @staticmethod\n    def validar_edad(edad):\n        return edad &gt;= 18\n\n# Uso de la clase Estudiante\nestudiante1 = Estudiante(\"Juan\", 209812-1, [\"An√°lisis num√©rico\", \"Probabilidad y Estad√≠stica\"])\nestudiante2 = Estudiante(\"Ana\", 191102-5, [\"Qu√≠mica\", \"√Ålgebra Lineal\"])\n\n# M√©todos de instancia\nestudiante1.agregar_asignatura(\"F√≠sica\")  # Salida: Juan ha agregado la asignatura F√≠sica.\n\n# M√©todos de clase\nEstudiante.obtener_total_estudiantes()  # Salida: Total de estudiantes: 2\n\n# M√©todos est√°ticos\nprint(Estudiante.validar_edad(20))  # Salida: True\nprint(Estudiante.validar_edad(16))  # Salida: False"
  },
  {
    "objectID": "clases2025/clase03_clases-objetos-constructores.html#referencias",
    "href": "clases2025/clase03_clases-objetos-constructores.html#referencias",
    "title": "Programaci√≥n Aplicada II",
    "section": "11 Referencias",
    "text": "11 Referencias\nT√≠tulo: Python 3 Object-oriented Programming (Second Edition) Autor: Dusty Phillips Link: Python 3 Object-oriented Programming (Second Edition)\n\nT√≠tulo: Classes and Objects Autor: Kris Jordan Link: Classes and Objects"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html",
    "href": "clases2025/clase05_herencia-abstraccion.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#clase-05-herencia-y-abstracci√≥n",
    "href": "clases2025/clase05_herencia-abstraccion.html#clase-05-herencia-y-abstracci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#temario",
    "href": "clases2025/clase05_herencia-abstraccion.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.2 Temario",
    "text": "0.2 Temario"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#en-el-cap√≠tulo-anterior",
    "href": "clases2025/clase05_herencia-abstraccion.html#en-el-cap√≠tulo-anterior",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.3 En el cap√≠tulo anterior ‚Ä¶",
    "text": "0.3 En el cap√≠tulo anterior ‚Ä¶\nEncapsulamiento: - Oculta detalles internos y restringe acceso directo a ciertos componentes. - Protege objeto, permite cambios sin afectar funcionamiento externo. - Atributos/M√©todos P√∫blicos: - Accesibles desde fuera de la clase. - Nombres sin dos guiones bajos. - Atributos/M√©todos Privados: - Inician con dos guiones bajos (__). - No accesibles directamente desde fuera de la clase. - M√©todos Getter y Setter: - Getter: Obtiene valor de atributo privado. - Setter: Establece valor de atributo privado. - Name Mangling: - Cambio de nombre de atributos privados al nivel de la clase.\nPolimorfismo: - Capacidad de objetos de distintas clases de responder a misma operaci√≥n de manera diferente. - Polimorfismo con Funciones: - Funciones aceptan argumentos de tipos diferentes y act√∫an en consecuencia. - Polimorfismo con M√©todos: - Clases implementan m√©todos con mismo nombre pero comportamientos diferentes. - Sobrecarga de Operadores: - Implementaci√≥n de m√©todos m√°gicos para operadores espec√≠ficos. - Polimorfismo con Herencia: - Subclases heredan de clase base, pueden proporcionar implementaciones propias."
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#contenido",
    "href": "clases2025/clase05_herencia-abstraccion.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.4 Contenido",
    "text": "0.4 Contenido\n\nHerencia\n\n¬øQu√© es herencia?\n\nClase Base\nClase Derivada\n\n¬øPor qu√© usar herencia?\nTipos de herencia\n\nHerencia simple\nHerencia jer√°rquica\nHerencia m√∫ltiple\n\n\nAbstracci√≥n\n\n¬øQu√© es la abstracci√≥n?\nClases abstractas"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#qu√©-es-herencia",
    "href": "clases2025/clase05_herencia-abstraccion.html#qu√©-es-herencia",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.1 ¬øQu√© es herencia?",
    "text": "1.1 ¬øQu√© es herencia?\n\nEs el proceso por el cual una clase nueva adquiere los atributos y m√©todos de una o m√°s clases ya existentes.\n\n\n1.1.1 Clase base\n\nLa(s) clase(s) existente(s) se llama(n) clase(s) base.\nTambi√©n recibe(n) otros nombres como superclase, clase padre o antepasado.\n\n\n\n1.1.2 Clase derivada\n\nLa clase reci√©n creada se llama clase derivada.\nTambi√©n se llama con otros nombres como subclase, clase secundaria y descendiente.\n\nLa clase derivada hereda los atributos/m√©todos de la clase base y normalmente contiene atributos/m√©todos adicionales.\n\n\nImagen de www.unipamplona.edu.co"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#sintaxis",
    "href": "clases2025/clase05_herencia-abstraccion.html#sintaxis",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.2 Sintaxis",
    "text": "1.2 Sintaxis\n\nEn Python, la herencia se implementa mediante el uso del operador ().\nPor ejemplo, para crear una clase derivada de la clase Vehiculo, se puede usar el siguiente c√≥digo:\n\n\n1.2.1 La funci√≥n super\n\nLa funci√≥n super() es una funci√≥n incorporada que se utiliza para acceder a m√©todos y atributos de una clase base.\n\nSe puede usar para llamar a m√©todos y atributos de la clase base sin tener que especificar expl√≠citamente el nombre de la clase base.\n\n\n# Clase base\nclass Vehiculo:\n    def __init__(self, marca, modelo):\n        self.marca = marca\n        self.modelo = modelo\n\n    def describir(self):\n        return f\"{self.marca} {self.modelo}\"\n\n# Clase derivada\nclass Automovil(Vehiculo):\n    def __init__(self, marca, modelo, tipo_carroceria):\n        super().__init__(marca, modelo)\n        self.tipo_carroceria = tipo_carroceria\n\n    def describir(self):\n        return f\"{super().describir()}, Tipo de carrocer√≠a: {self.tipo_carroceria}\"\n\n# Uso de las clases\nauto = Automovil(\"Toyota\", \"Camry\", \"Sed√°n\")\nprint(auto.describir())  # Salida: Toyota Camry, Tipo de carrocer√≠a: Sed√°n"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#por-qu√©-usar-herencia",
    "href": "clases2025/clase05_herencia-abstraccion.html#por-qu√©-usar-herencia",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.3 ¬øPor qu√© usar herencia?",
    "text": "1.3 ¬øPor qu√© usar herencia?\n\nLa raz√≥n principal es para reutilizar c√≥digo: nos permite obtener propiedades de las clases anteriores.\nOtra raz√≥n es que podemos aumentar la complejidad de nuestro c√≥digo: podemos agregar caracter√≠sticas adicionales a clases existentes creando una nueva clase que tendr√° nuevos atributos/m√©todos, adem√°s de los atributos/m√©todos adquiridos de la clase base."
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#tipos-de-herencia",
    "href": "clases2025/clase05_herencia-abstraccion.html#tipos-de-herencia",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.4 Tipos de herencia",
    "text": "1.4 Tipos de herencia\n\nHerencia simple: una clase derivada hereda de una sola clase base.\nHerencia jer√°rquica: Una clase derivada hereda de otra clase que, a su vez, hereda de otra clase.\nHerencia m√∫ltiple: una clase derivada hereda de dos o m√°s clases base.\n\nNota: La herencia m√∫ltiple puede dar lugar a conflictos de nombres, en caso de que los padres tengan m√©todos con el mismo nombre."
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#herencia-simple",
    "href": "clases2025/clase05_herencia-abstraccion.html#herencia-simple",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.5 1. Herencia simple",
    "text": "1.5 1. Herencia simple\n\nUna clase derivada hereda de una sola clase base.\n\n\n# Clase base\nclass Empleado:\n    def __init__(self, nombre, salario):\n        self.nombre = nombre\n        self.salario = salario\n\n    def calcular_bono(self):\n        return 0.05 * self.salario  # Bono del 5% del salario\n\n# Clase derivada\nclass Gerente(Empleado):\n    def __init__(self, nombre, salario, departamento):\n        # Llamamos al constructor de la clase base\n        super().__init__(nombre, salario)\n        self.departamento = departamento\n\n    def calcular_bono(self):\n        # Los gerentes obtienen un bono adicional del 10%\n        return 0.10 * self.salario + super().calcular_bono()\n\n    def describir(self):\n        return f\"{self.nombre} es gerente del departamento {self.departamento}\"\n\n# Uso de la clase derivada\ngerente1 = Gerente(\"Ana\", 60000, \"Finanzas\")\nprint(gerente1.describir())\nprint(f\"Salario: ${gerente1.salario}\")\nprint(f\"Bono: ${gerente1.calcular_bono()}\")"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#herencia-jer√°rquica",
    "href": "clases2025/clase05_herencia-abstraccion.html#herencia-jer√°rquica",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.6 2. Herencia jer√°rquica",
    "text": "1.6 2. Herencia jer√°rquica\n\nUna clase derivada hereda de otra clase que, a su vez, hereda de otra clase.\n\n\n# Clase base\nclass Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n    def presentarse(self):\n        return f\"Me llamo {self.nombre} y tengo {self.edad} a√±os.\"\n\n# Clase intermedia\nclass Estudiante(Persona):\n    def __init__(self, nombre, edad, curso):\n        # Llamamos al constructor de la clase base\n        super().__init__(nombre, edad)\n        self.curso = curso\n\n    def estudiar(self):\n        return f\"Estoy estudiando en el curso de {self.curso}.\"\n\n# Clase derivada\nclass EstudianteUniversitario(Estudiante):\n    def __init__(self, nombre, edad, curso, carrera):\n        # Llamamos al constructor de la clase intermedia\n        super().__init__(nombre, edad, curso)\n        self.carrera = carrera\n\n    def presentarse(self):\n        estudiante_desc = super().presentarse()\n        return f\"{estudiante_desc} Estoy cursando la carrera de {self.carrera}.\"\n\n# Uso de la clase derivada\nestudiante_universitario = EstudianteUniversitario(\"Ana\", 20, \"Matem√°ticas Avanzadas\", \"Ingenier√≠a Inform√°tica\")\nprint(estudiante_universitario.presentarse())\nprint(estudiante_universitario.estudiar())"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#herencia-m√∫ltiple",
    "href": "clases2025/clase05_herencia-abstraccion.html#herencia-m√∫ltiple",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.7 3. Herencia m√∫ltiple",
    "text": "1.7 3. Herencia m√∫ltiple\n\nUna clase derivada hereda de dos o m√°s clases base.\n\n\n# Clases bases\nclass InstrumentoMusical:\n    def tocar(self):\n        return \"Tocando el instrumento musical\"\n\nclass DispositivoElectronico:\n    def encender(self):\n        return \"Encendiendo el dispositivo electr√≥nico\"\n\n# Clase derivada que hereda de dos clases bases\nclass Teclado(InstrumentoMusical, DispositivoElectronico):\n    def usar(self):\n        return \"Usando el teclado\"\n\n# Uso de la clase derivada\nteclado = Teclado()\nprint(teclado.encender()) # Salida: Encendiendo el dispositivo electr√≥nico\nprint(teclado.tocar())    # Salida: Tocando el instrumento musical\nprint(teclado.usar())      # Salida: Usando el teclado\n\nNota:\n\nLa herencia m√∫ltiple puede dar lugar a conflictos de nombres, en caso de que los padres tengan m√©todos con el mismo nombre.\nPython sigue el orden de izquierda a derecha para buscar atributos o m√©todos en las clases base.\nSi dos clases base tienen un m√©todo con el mismo nombre, el m√©todo de la clase m√°s a la izquierda se utilizar√°.\n\n\n# Clase base 1\nclass ClaseBase1:\n    def metodo_comun(self):\n        return \"M√©todo com√∫n de ClaseBase1\"\n    \n# Clase base 2\nclass ClaseBase2:\n    def metodo_comun(self):\n        return \"M√©todo com√∫n de ClaseBase2\"\n\n# Clase derivada que hereda de ambas clases bases\nclass ClaseDerivada(ClaseBase1, ClaseBase2):\n    def metodo_derivado(self):\n        return \"M√©todo espec√≠fico de ClaseDerivada\"\n\n# Uso de la clase derivada\ninstancia_derivada = ClaseDerivada()\n\n# Intentamos llamar al m√©todo com√∫n, pero hay ambig√ºedad\nprint(instancia_derivada.metodo_comun())"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#abstracci√≥n",
    "href": "clases2025/clase05_herencia-abstraccion.html#abstracci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.8 Abstracci√≥n",
    "text": "1.8 Abstracci√≥n"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#qu√©-es-la-abstracci√≥n",
    "href": "clases2025/clase05_herencia-abstraccion.html#qu√©-es-la-abstracci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.9 ¬øQu√© es la abstracci√≥n?",
    "text": "1.9 ¬øQu√© es la abstracci√≥n?\n\nSe refiere a la capacidad de representar objetos del mundo real en el c√≥digo de manera simplificada, centr√°ndose en los aspectos relevantes y omitiendo los detalles innecesarios.\nEn Python, podemos crear clases para representar objetos y definir atributos y m√©todos que tengan las propiedades y comportamientos esenciales de esos objetos.\nEjemplo:\n\n\nclass Vehiculo:\n    def __init__(self, marca, modelo):\n        self.marca = marca\n        self.modelo = modelo\n\n    def obtener_info(self):\n        return f\"{self.modelo} de la marca {self.marca}\"\n\n# Crear un objeto de la clase Vehiculo\nmi_auto = Vehiculo(\"Toyota\", \"Camry\")\n\n# Utilizar el m√©todo para obtener informaci√≥n\nprint(mi_auto.obtener_info())\n\nCamry de la marca Toyota"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#clases-abstractas",
    "href": "clases2025/clase05_herencia-abstraccion.html#clases-abstractas",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.10 Clases Abstractas",
    "text": "1.10 Clases Abstractas\n\nUna clase abstracta es una clase que no puede ser instanciada directamente y generalmente sirve como una plantilla para clases derivadas.\nUna clase abstracta puede contener m√©todos abstractos, que son m√©todos sin implementaci√≥n, dejando que las clases derivadas proporcionen sus implementaciones.\nEn Python, la abstracci√≥n se logra mediante el uso del m√≥dulo abc (Abstract Base Classes):\n\n\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    @abstractmethod\n    def hacer_sonido(self):\n        pass\n\nclass Perro(Animal):\n    pass\n    def hacer_sonido(self):\n        return \"¬°Guau, guau!\"\n\nclass Gato(Animal):\n    def hacer_sonido(self):\n        return \"¬°Miau, miau!\"\n\nclass Pajaro(Animal):\n    def hacer_sonido(self):\n        return \"¬°P√≠o, p√≠o!\"\n\n\nEn este ejemplo, Animal es una clase abstracta que define un m√©todo abstracto hacer_sonido. Las clases derivadas (Perro, Gato y P√°jaro) deben proporcionar implementaciones concretas para este m√©todo.\nLa creaci√≥n de una instancia de la clase abstracta directamente generar√≠a un error.\n\nIntentar instanciar la clase abstracta genera un error:\n\nanimal_generico = Animal(\"Gen√©rico\")  # Genera un error\n\nCrear objetos de las clases derivadas:\n\nperro = Perro(\"Buddy\")\ngato = Gato(\"Whiskers\")\npajaro = Pajaro(\"Tweetie\")\n\nUtilizar los m√©todos de abstracci√≥n para hacer sonidos\n\nprint(f\"{perro.nombre} hace sonido: {perro.hacer_sonido()}\")\nprint(f\"{gato.nombre} hace sonido: {gato.hacer_sonido()}\")\nprint(f\"{pajaro.nombre} hace sonido: {pajaro.hacer_sonido()}\")"
  },
  {
    "objectID": "clases2025/clase05_herencia-abstraccion.html#ejercicio",
    "href": "clases2025/clase05_herencia-abstraccion.html#ejercicio",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.11 Ejercicio",
    "text": "1.11 Ejercicio\n\n1.11.1 Parte 1: Correcci√≥n de C√≥digo\n\nCorrige los errores en los siguientes c√≥digos y explica brevemente las correcciones realizadas.\n\n\nclass Persona:\n    def _init_(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n    def presentarse(self):\n        return f\"Me llamo {self.nombre} y tengo {self.edad} a√±os.\"\n    \nclass Empleado(Persona):\n    def __init__(self, nombre, salario_base):\n        self.nombre = nombre\n        self.__salario_base = salario_base\n\ndef calcular_sueldo(self):\n    return self.__salario_base\n\n\nclass Gerente(Empleado):\n    def __init__(self, nombre, salario_base, bono):\n        self.bono = bono\n\n    def calcular_sueldo(self):\n        return self.__salario_base + self.bono\n\n\n# Crear instancias de las clases\nempleado1 = Empleado(\"Juan\", 50000)\ngerente1 = Gerente(\"Ana\", 70000, 15000)\n\n# Imprimir sueldos\nprint(f\"Sueldo de {empleado1.nombre}: {empleado1.calcular_sueldo()}\")\nprint(f\"Sueldo de {gerente1.nombre}: {gerente1.calcular_sueldo()}\")\n\n# Crear una lista de empleados\nempleados = [empleado1, gerente1]\n\n# Imprimir sueldos de los empleados en la lista\nfor empleado in empleados:\n    print(empleado.presentarse)\n    print(f\"Sueldo de {empleado.nombre}: {empleado.calcular_sueldo()}\")\n\nprint(f\"Departamento de {gerente1.nombre}: {gerente1.departamento}\")\n\n\nclass FiguraGeometrica:\n    def _init_(self, lado):\n        self.lado = lado\n\n    def obtener_area(self):\n        return self.lado ** 2\n\n\nclass Rectangulo(FiguraGeometrica):\n    def __init__(self, base, altura):\n        super().__init__(base)\n        self.altura = altura\n\n    def obtener_area(self):\n        return self.base * self.altura\n\n\nmi_rectangulo = Rectangulo(\"5\", \"10\")\nprint(f\"√Årea del rect√°ngulo: {mi_rectangulo.obtener_area()}\")\n\n\n\n1.11.2 Parte 2: Preguntas Conceptuales\n\nExplica c√≥mo la clase Gerente utiliza la herencia y el polimorfismo.\nExplica c√≥mo la clase Rectangulo utiliza la herencia y el polimorfismo.\n¬øCu√°l es la diferencia clave entre el m√©todo calcular_sueldo en la clase base Empleado y en la clase derivada Gerente?\n¬øCu√°l es la diferencia clave entre el m√©todo obtener_area en la clase base FiguraGeometrica y en la clase derivada Rectangulo?\nProporciona un ejemplo de un atributo que deber√≠a ser privado en los c√≥digos anteriores y c√≥mo se podr√≠a acceder a √©l mediante un m√©todo getter.\n\n\n\n1.11.3 Parte 3: Agregando c√≥digo\n\nModifica la clase FiguraGeometrica para que sea una clase abstracta, donde el m√©todo obtener_area sea un m√©todo abstracto.\nAgrega una nueva clase llamada Circulo que herede de FiguraGeometrica. Implementa un m√©todo obtener_area espec√≠fico para calcular el √°rea de un c√≠rculo.\nCrea una funci√≥n llamada calcular_area_total que acepte una lista de objetos de tipo FiguraGeometrica y devuelva la suma total de las √°reas de todas las figuras.\nPrueba la funci√≥n anterior con una lista de al menos 5 objetos de las clases FiguraGeom√©trica, Rect√°ngulo y C√≠rculo.\n\n\n\n1.11.4 Entregables\nSube los archivos generados en este ejercicio con el prefijo PA2_Grupo_E06NombreApellido. La parte de c√≥digo debe entregarse en un archivo con extensi√≥n .py.\nConsideraciones:\n\nNo se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc.\nEn caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° la tarea con una deducci√≥n de hasta 50pts, dependiendo de la gravedad del error.\nEn caso de que la/el estudiante utilice c√≥digo o funciones no vistas en clase, deber√° ser capaz de respaldar su c√≥digo mediante una explicaci√≥n verbal y/o escrita, en caso de que le sea requerida por la docente de la asignatura. De no cumplir con la explicaci√≥n de forma satisfactoria, se anular√° su trabajo y se pasar√° el reporte a la coordinaci√≥n de la carrera."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html",
    "href": "clases2025/clase07_aserciones-pruebas.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#clase-07-pruebas-de-software-y-debugging",
    "href": "clases2025/clase07_aserciones-pruebas.html#clase-07-pruebas-de-software-y-debugging",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#temario",
    "href": "clases2025/clase07_aserciones-pruebas.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.2 Temario",
    "text": "0.2 Temario"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#contenido",
    "href": "clases2025/clase07_aserciones-pruebas.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.3 Contenido",
    "text": "0.3 Contenido\n\nMotivaci√≥n (Programaci√≥n de calidad)\nAserciones\n\n¬øQu√© son las aserciones?\nSintaxis de las aserciones\n¬øD√≥nde usar aserciones?\n\nPruebas de software\n\nPruebas unitarias\nPruebas de regresi√≥n\nPruebas de integraci√≥n\nEnfoques (caja negra, caja de cristal)\n\nDebugging\n\nDefinici√≥n\nHerramientas de debugging (print, logging, debugger en Spyder)"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#en-la-clase-anterior-vimos",
    "href": "clases2025/clase07_aserciones-pruebas.html#en-la-clase-anterior-vimos",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.4 En la clase anterior vimos ‚Ä¶",
    "text": "0.4 En la clase anterior vimos ‚Ä¶\n\nLas excepciones son situaciones de error o eventos inesperados que interrumpen el flujo normal de un programa. Las excepciones son objetos y tienen clases con constructores.\nEl manejo de excepciones, a trav√©s de los bloques de los bloques try y except, permite que el programa contin√∫e ejecut√°ndose sin interrupciones, incluso si ocurre un error.\nEl bloque else se ejecuta cuando no se produce ninguna excepci√≥n en el bloque try, mientras que el bloque finally se utiliza para definir c√≥digo que siempre se ejecutar√°, independientemente de si se produce una excepci√≥n o no.\nSe explic√≥ c√≥mo definir una nueva clase que herede de la clase base Exception o sus subclases para crear excepciones personalizadas."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#motivaci√≥n",
    "href": "clases2025/clase07_aserciones-pruebas.html#motivaci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.5 Motivaci√≥n",
    "text": "0.5 Motivaci√≥n\n\n0.5.1 Buenas pr√°cticas de programaci√≥n\n\nLa programaci√≥n de calidad se refiere a la pr√°ctica de escribir c√≥digo que sea fiable, eficiente, mantenible y legible.\nSe trata de desarrollar c√≥digo que sea robusto, f√°cil de entender y modificar, y que cumpla con los requisitos de los usuarios.\n\n\n\n0.5.2 ¬øPor qu√© tomarse el tiempo de escribir buen c√≥digo?\n\n\n\n&lt;ul&gt;\n  &lt;li&gt;Reduce el n√∫mero de errores en el software.&lt;/li&gt;\n  &lt;li&gt;Aumenta la eficiencia del desarrollo y mantenimiento del software.&lt;/li&gt;\n  &lt;li&gt;Mejora la satisfacci√≥n de los usuarios con el software.&lt;/li&gt;\n  &lt;li&gt;Reduce los costos de desarrollo y mantenimiento del software.&lt;/li&gt;\n&lt;/ul&gt;\n\n\n&lt;img src=\"imgs/bad_coding.jpg\" alt=\"Buen c√≥digo\" style=\"width:100%;\"&gt;\n\n\nImagen de x.com\n\n\n0.5.3 ¬øC√≥mo escribir c√≥digo de calidad?\n\nSupongamos que un cocinero quiere asegurarse de que su comida sigue todas las normas de sanidad (que no tenga ning√∫n bicho)\n¬øQue acciones deber√≠a realizar?\n\n\nImagen de render.fineartamerica.com\n\nMantener las ollas tapadas. (Programaci√≥n defensiva)\nRevisar constantemente la cocina. (Validaci√≥n/Pruebas)\nLimpiar la cocina. (Depuraci√≥n de errores)\n\n\n\n0.5.4 ¬øC√≥mo escribir c√≥digo de calidad?:\n\nProgramaci√≥n defensiva\n\nEscribir c√≥digo modular y reutilizable.\nDocumentar el c√≥digo de manera clara y concisa.\nSeguir las buenas pr√°cticas de codificaci√≥n, como las gu√≠as de estilo PEP8 para Python.\n\nValidaci√≥n/Pruebas exhaustivas\n\nValidar los datos de entrada/salida en el c√≥digo.\nRealizar pruebas exhaustivas del c√≥digo.\n\nDepuraci√≥n de errores (Debugging)\n\nUtilizar herramientas de revisi√≥n de c√≥digo para detectar errores y mejorar la calidad del c√≥digo."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#validaci√≥n-y-pruebas-exhaustivas",
    "href": "clases2025/clase07_aserciones-pruebas.html#validaci√≥n-y-pruebas-exhaustivas",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.6 Validaci√≥n y pruebas exhaustivas",
    "text": "0.6 Validaci√≥n y pruebas exhaustivas"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#aserciones",
    "href": "clases2025/clase07_aserciones-pruebas.html#aserciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.7 Aserciones",
    "text": "0.7 Aserciones"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#aserciones-1",
    "href": "clases2025/clase07_aserciones-pruebas.html#aserciones-1",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.8 Aserciones",
    "text": "0.8 Aserciones\n\nLas aserciones son instrucciones que verifican si una condici√≥n espec√≠fica es verdadera o falsa durante la ejecuci√≥n de un programa.\nSi la condici√≥n es falsa, se genera una excepci√≥n de tipo AssertionError (Se debe hacer manejo de excepciones con try-except o el programa se interrumpir√° si ocurre la excepci√≥n).\nSon un atajo a escribir una estructura condicional if para verificar una condici√≥n que se debe cumplir para ejecutar un bloque de c√≥digo."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#sintaxis",
    "href": "clases2025/clase07_aserciones-pruebas.html#sintaxis",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.9 Sintaxis",
    "text": "0.9 Sintaxis\nassert condici√≥n, \"mensaje de error\""
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#ejemplo-1",
    "href": "clases2025/clase07_aserciones-pruebas.html#ejemplo-1",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.10 Ejemplo 1",
    "text": "0.10 Ejemplo 1\n\ndef dividir(a, b):\n    assert b != 0, \"La divisi√≥n por cero no est√° permitida\"\n    return a / b\n\n# Programa principal\ntry:\n    resultado = dividir(10, 0)\nexcept AssertionError as error:\n    print(error)\nelse:\n    print(\"El resultado de la divisi√≥n es:\", resultado)"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#ejemplo-2",
    "href": "clases2025/clase07_aserciones-pruebas.html#ejemplo-2",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.11 Ejemplo 2",
    "text": "0.11 Ejemplo 2\n\ndef suma(a, b):\n    assert isinstance(a, int), \"El primer argumento debe ser un n√∫mero entero\"\n    assert isinstance(b, int), \"El segundo argumento debe ser un n√∫mero entero\"\n    return a + b\n\nresultado = suma(1, 2)\nprint(resultado)  # Salida: 3\n\nresultado = suma(\"a\", 2)\n# Se genera una excepci√≥n AssertionError: \"El primer argumento debe ser un n√∫mero entero\""
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#d√≥nde-usar-aserciones",
    "href": "clases2025/clase07_aserciones-pruebas.html#d√≥nde-usar-aserciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.12 ¬øD√≥nde usar aserciones?",
    "text": "0.12 ¬øD√≥nde usar aserciones?\n\nLas aserciones son √∫tiles para validar condiciones que deben ser siempre verdaderas en el c√≥digo.\nSe utilizan com√∫nmente para:\n\nValidar la entrada del usuario: Asegurarse de que los datos introducidos por el usuario sean v√°lidos.\nPruebas de software: Verificar que las variables y objetos del programa tengan los valores esperados.\nDocumentar el comportamiento esperado de un programa: Ayudar a otros programadores a comprender c√≥mo funciona el c√≥digo."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#pruebas-de-software",
    "href": "clases2025/clase07_aserciones-pruebas.html#pruebas-de-software",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.13 Pruebas de software",
    "text": "0.13 Pruebas de software"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#pruebas-de-software-1",
    "href": "clases2025/clase07_aserciones-pruebas.html#pruebas-de-software-1",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.14 Pruebas de software",
    "text": "0.14 Pruebas de software\n\nPruebas unitarias: Pruebas que verifican el comportamiento de cada unidad individual de c√≥digo, como funciones o clases.\nPruebas de regresi√≥n: Pruebas que se ejecutan despu√©s de realizar cambios en el c√≥digo para asegurar que no se han introducido errores en funcionalidades ya existentes.\nPruebas de integraci√≥n: Pruebas que verifican c√≥mo interact√∫an diferentes unidades de c√≥digo entre s√≠.\n\n\nImagen de programmerhumor.io"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#enfoques-para-dise√±ar-pruebas",
    "href": "clases2025/clase07_aserciones-pruebas.html#enfoques-para-dise√±ar-pruebas",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.15 Enfoques para dise√±ar pruebas",
    "text": "0.15 Enfoques para dise√±ar pruebas\n\nEnfoque caja negra: Las pruebas se dise√±an sin conocer el c√≥digo interno de la unidad que se est√° probando.\nEnfoque caja de cristal: Las pruebas se dise√±an con conocimiento del c√≥digo interno de la unidad que se est√° probando."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#ejemplo-3",
    "href": "clases2025/clase07_aserciones-pruebas.html#ejemplo-3",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.16 Ejemplo 3",
    "text": "0.16 Ejemplo 3\n\n\nimport unittest # Importa el m√≥dulo 'unittest' para escribir y ejecutar pruebas unitarias.\n\ndef suma(a, b): # Define una funci√≥n 'suma' que toma dos argumentos y devuelve la suma de ambos.\n    return a + b\n\n# Crea una clase 'TestSuma' que hereda de 'unittest.TestCase', \n# que es una clase base para escribir pruebas.\nclass TestSuma(unittest.TestCase):\n\n    def test_suma_positiva(self): # Define un m√©todo de prueba dentro de la clase 'TestSuma'.\n        # Utiliza la aserci√≥n 'self.assertEqual' para verificar que la suma de 2 y 3 sea igual a 5.\n        self.assertEqual(suma(2, 3), 5)\n\n# Ejecuta el conjunto de pruebas utilizando 'unittest.main()'.\nif __name__ == \"__main__\":\n    unittest.main()\n\n\nAn exception has occurred, use %tb to see the full traceback.\n\nSystemExit: 1"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#ejemplo-4",
    "href": "clases2025/clase07_aserciones-pruebas.html#ejemplo-4",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.17 Ejemplo 4",
    "text": "0.17 Ejemplo 4\n\n# archivo: validar_entrada.py\n\ndef validar_entrada(edad):\n    \"\"\"\n    Valida la edad ingresada por el usuario.\n    Args:\n      edad: La edad ingresada por el usuario (puede ser int o float).\n    Raises:\n      AssertionError: Si la edad es menor que 0 o no es un n√∫mero v√°lido.\n    \"\"\"\n    \n    # Verificamos que la edad sea un n√∫mero positivo\n    assert isinstance(edad, int) or isinstance(edad, float), \"La entrada no es un n√∫mero v√°lido\"\n    assert edad &gt;= 0, \"La edad debe ser mayor o igual a 0\"\n    \n    print(f\"Edad ingresada: {edad}\")\n\n\n\n# archivo: test_validar_entrada.py\n\nimport unittest\n\nfrom validar_entrada import validar_entrada\n\nclass TestValidarEntrada(unittest.TestCase):\n\n    def test_edad_valida(self):\n        edad_valida = 25\n        validar_entrada(edad_valida)  # No deber√≠a lanzar excepciones\n\n    def test_edad_negativa(self):\n        edad_negativa = -10\n        with self.assertRaises(AssertionError):\n            validar_entrada(edad_negativa)  # Deber√≠a lanzar una excepci√≥n ValueError\n\n    def test_edad_no_numerica(self):\n        edad_no_numerica = \"abc\"\n        with self.assertRaises(AssertionError):\n            validar_entrada(edad_no_numerica)  # Deber√≠a lanzar una excepci√≥n ValueError\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#depuraci√≥n-de-errores",
    "href": "clases2025/clase07_aserciones-pruebas.html#depuraci√≥n-de-errores",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.18 Depuraci√≥n de errores",
    "text": "0.18 Depuraci√≥n de errores"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#introducci√≥n",
    "href": "clases2025/clase07_aserciones-pruebas.html#introducci√≥n",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.19 Introducci√≥n",
    "text": "0.19 Introducci√≥n\n\n\n\nLa palabra debugging (depuraci√≥n) tiene sus or√≠genes en la d√©cada de 1940 durante el desarrollo de la computadora Mark II, utilizada en la Universidad de Harvard.\nEn ese tiempo, la programaci√≥n se realizaba mediante tarjetas perforadas.\n\n\n Imagen de techcrunch.com\n\n\n\n\n\n\nEn 1947, Mark II tuvo un mal funcionamiento.\nDespu√©s de una cuidadosa inspecci√≥n, se encontr√≥ un bicho (bug): una polilla atrapada en uno de los rel√©s electromec√°nicos, lo que causaba el problema.\nLa Dra. Grace Hopper extrajo la polilla, registr√≥ el incidente en su cuaderno y us√≥ la expresi√≥n debugging para describir la acci√≥n de solucionar problemas en un programa.\n\n\n\n\n\nImagen de education.nationalgeographic.org"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#debugging-con-print",
    "href": "clases2025/clase07_aserciones-pruebas.html#debugging-con-print",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.1 Debugging con print",
    "text": "1.1 Debugging con print\n\nUna forma simple pero efectiva de depurar es mediante la inserci√≥n de sentencias de impresi√≥n en nuestro c√≥digo.\nSe pueden utilizar para mostrar el valor de variables en diferentes puntos del programa, lo que te permite verificar si los c√°lculos se est√°n realizando correctamente y si los datos fluyen como se espera.\nPor ejemplo:\n\n\n# Ejemplo de declaraci√≥n de impresi√≥n para depurar un ciclo for\nfor i in range(5):\n    print(\"Valor de i:\", i)\n    resultado = i * 2\n    print(\"Resultado:\", resultado)"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#debugging-con-logging",
    "href": "clases2025/clase07_aserciones-pruebas.html#debugging-con-logging",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.2 Debugging con logging",
    "text": "1.2 Debugging con logging\n\nLa biblioteca logging proporciona una forma m√°s estructurada y flexible para registrar mensajes durante la ejecuci√≥n del programa.\nEs m√°s flexible y escalable: permite especificar diferentes niveles de registro, como debug, info, warning, error, etc., y redirigir la salida a diferentes destinos, como archivos de registro, consola, correo electr√≥nico, etc.\nPor ejemplo:\n\n\nimport logging\n\n# Configuraci√≥n b√°sica del registro\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(filename='app.log', level=logging.DEBUG)\n\ndef dividir(a, b):\n    try:\n        resultado = a / b\n        logger.info(f\"La divisi√≥n de {a} entre {b} es {resultado}\")\n        return resultado\n    except ZeroDivisionError:\n        logger.error(\"Intento de dividir por cero\")\n        return None\n\ndividir(10, 2)\ndividir(5, 0)\n\nlogging.basicConfig es una funci√≥n que se utiliza al comienzo de un c√≥digo para establecer la forma en que se registrar√°n los mensajes durante la ejecuci√≥n del programa. Los argumentos que se pueden pasar incluyen:\n\nfilename: Especifica el nombre del archivo de registro donde se escribir√°n los mensajes de registro. Si se proporciona este argumento, los mensajes se escribir√°n en ese archivo. Si no se proporciona, los mensajes se enviar√°n a la salida est√°ndar (por defecto, la consola).\nfilemode: Si se proporciona filename, este argumento especifica el modo de apertura del archivo de registro (por ejemplo, ‚Äòa‚Äô para agregar, ‚Äòw‚Äô para sobrescribir, etc.).\nformat: Define el formato del mensaje de registro. Puedes especificar c√≥mo se ver√° el mensaje de registro. Por ejemplo, ‚Äò%(asctime)s - %(levelname)s - %(message)s‚Äô muestra la fecha y hora, el nivel de registro y el mensaje.\nlevel: Define el nivel de registro m√≠nimo para los mensajes que se van a registrar. Por defecto, se establece en WARNING, lo que significa que solo se registrar√°n mensajes de nivel WARNING o superior.\nstream: Especifica el flujo de salida donde se enviar√°n los mensajes de registro si no se proporciona filename. Por defecto, se establece en sys.stderr.\n\nLos niveles son utilizados para indicar la gravedad de un mensaje de registro. Estos niveles permiten a los desarrolladores categorizar y filtrar los mensajes de registro seg√∫n su importancia.\n\nDEBUG: para mensajes de depuraci√≥n que son √∫tiles para rastrear el flujo de ejecuci√≥n del programa.\nINFO: para mensajes informativos que describen eventos significativos en el flujo de ejecuci√≥n del programa.\nWARNING: indica que se ha producido una situaci√≥n inesperada o potencialmente problem√°tica, pero que el programa puede continuar ejecut√°ndose sin interrupciones.\nERROR: indica que se ha producido un error durante la ejecuci√≥n del programa, pero que no ha causado la terminaci√≥n del programa.\nCRITICAL: El nivel m√°s alto de gravedad, utilizado para indicar errores cr√≠ticos que probablemente causen la terminaci√≥n del programa.\n\n\nimport logging\n\n# Configuraci√≥n b√°sica del registro\nlogger = logging.getLogger(__name__)\nlogging.basicConfig(filename='registro.log', level=logging.DEBUG)\n\n# Ejemplo de registro\nlogger.debug('Este es un mensaje de depuraci√≥n')\nlogger.info('Este es un mensaje informativo')\nlogger.warning('Este es un mensaje de advertencia')\nlogger.error('Este es un mensaje de error')\nlogger.critical('Este es un mensaje cr√≠tico')"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#debugging-con-el-depurador-de-spyder",
    "href": "clases2025/clase07_aserciones-pruebas.html#debugging-con-el-depurador-de-spyder",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.3 Debugging con el depurador de Spyder",
    "text": "1.3 Debugging con el depurador de Spyder\n\nSpyder incluye un depurador que nos permite ejecutar nuestro c√≥digo paso a paso, inspeccionar variables y ver el flujo de ejecuci√≥n de manera visual.\nPodemos hacer clic en la l√≠nea de c√≥digo en la que queremos establecer un punto de interrupci√≥n y luego ejecutar nuestro programa en modo de depuraci√≥n.\nEl depurador se activa haciendo clic en el bot√≥n ‚ÄúDebug‚Äù o usando el atajo de teclado F5.\nUna vez que el programa se detiene en un punto de interrupci√≥n, puedes inspeccionar variables y avanzar paso a paso a trav√©s del c√≥digo utilizando los controles disponibles en la barra de herramientas de depuraci√≥n."
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#ejemplo",
    "href": "clases2025/clase07_aserciones-pruebas.html#ejemplo",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.4 Ejemplo",
    "text": "1.4 Ejemplo\n\nImplementa el siguiente c√≥digo en Spyder:\n\n\ndef suma_pares(lista):\n    suma = 0\n    for numero in lista:\n    if numero % 2 == 0:\n        suma += numero\n    return suma\n\nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(suma_pares(numeros))\n\n\nEstablece un breakpoint:\n\nHaz clic en el margen izquierdo de la l√≠nea donde se realiza la comparaci√≥n numero % 2 == 0.\n\n\nInicia el debugger:\n\nClic en la opci√≥n ‚ÄúDebug‚Äù en el men√∫ (bot√≥n azul con un s√≠mbolo de pause/play) o presiona Ctrl+F5.\n\n\n\n\nEjecuta el c√≥digo paso a paso:\n\nEn Spyder, presiona el bot√≥n Ejecutar linea actual (flecha azul curveada) o Ctrl + F10 para avanzar l√≠nea a l√≠nea.\n\n\n\n\nEjecuta el c√≥digo hasta el siguiente breakpoint:\n\nPresiona el bot√≥n Continuar ejecuci√≥n hasta el siguiente breakpoint o Ctrl + F12 para avanzar l√≠nea a l√≠nea.\n\n\nObserva el valor de las variables:\n\nPuedes ver o modificar el valor de las variables en la secci√≥n ‚ÄúVariables‚Äù.\n\n\n\n\nFinaliza la ejecuci√≥n del debugger:\n\nSelecciona la opci√≥n Stop en el men√∫ ‚ÄúDebug‚Äù o presiona Ctrl+Shift+12"
  },
  {
    "objectID": "clases2025/clase07_aserciones-pruebas.html#ejercicio",
    "href": "clases2025/clase07_aserciones-pruebas.html#ejercicio",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.5 Ejercicio",
    "text": "1.5 Ejercicio\n\nIntenta ejecutar este c√≥digo y observa el error que se produce.\nLuego, utiliza las tres t√©cnicas de depuraci√≥n vistas en clase para encontrar y corregir el problema.\nDocumenta todo el proceso en un reporte de pr√°ctica que incluya capturas de pantalla y explicaciones de tus hallazgos.\n\n\ndef calcular_promedio(numeros):\n    suma = 0\n    contador = 1\n    while (contador&lt;len(numeros)):\n        suma += numeros[contador]\n        contador+=1\n    promedio = suma / contador\n    return promedio\n\n# El programa deber√≠a calcular el promedio de una lista de n√∫meros. \n# Si la lista no tiene elementos, el valor de retorno deber√≠a ser None\n# Hay errores en el c√≥digo. ¬°Encu√©ntralos y corr√≠gelos!\n\nlista_numeros1 = [10, 15, 20, 25, 30]\nresultado1 = calcular_promedio(lista_numeros1)\n\nlista_numeros2 = []\nresultado2 = calcular_promedio(lista_numeros2)\n\n# Deber√≠a imprimir el resultado, pero algo no est√° bien.\nprint(\"El promedio de la lista 1 es: \", resultado1)\nprint(\"El promedio de la lista 2 es: \", resultado2)"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#sympy-matplotlib-pandas",
    "href": "clases2025/clase09_sympy.html#sympy-matplotlib-pandas",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.2 Sympy | Matplotlib | Pandas",
    "text": "0.2 Sympy | Matplotlib | Pandas\n\n0.2.1 Primavera 2024\n\n0.2.1.1 Dra. Dora Alvarado\n\n27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#temario",
    "href": "clases2025/clase09_sympy.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.3 Temario",
    "text": "0.3 Temario"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#contenido",
    "href": "clases2025/clase09_sympy.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "0.4 Contenido",
    "text": "0.4 Contenido\n\nSympy\n\n¬øPara que sirve Sympy?\nVariables simb√≥licas y expresiones\nManipulaci√≥n de expresiones algebr√°icas (expansi√≥n, simplificaci√≥n)\nC√°lculo (l√≠mites, diferenciaci√≥n, integraci√≥n, expansi√≥n de series)\n√Ålgebra lineal (soluci√≥n de sistemas de ecuaciones, matrices, ecuaciones diferenciales)"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#para-que-sirve-sympy",
    "href": "clases2025/clase09_sympy.html#para-que-sirve-sympy",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.1 ¬øPara que sirve Sympy?",
    "text": "1.1 ¬øPara que sirve Sympy?\n\nSymPy es una biblioteca para realizar c√°lculos matem√°ticos de forma simb√≥lica.\nNormalmente se importa con:\n\nimport sympy as sy\n\n1.1.1 De forma simb√≥lica..\nA diferencia de las calculadoras tradicionales que solo trabajan con valores num√©ricos, SymPy permite trabajar con expresiones que contienen variables simb√≥licas (como en √°lgebra), permiti√©ndonos realizar operaciones matem√°ticas abstractas y obtener resultados generales.\n\nEs una alternativa a herramientas como Mathematica o Maple, pero escrita completamente en Python.\n\n\n\n1.1.2 Ejemplos:\n\nResolver ecuaciones: encontrar las soluciones de ecuaciones polinomiales, diferenciales o en derivadas parciales.\nDemostrar identidades matem√°ticas: verificar si dos expresiones son equivalentes.\nSimplificar expresiones: obtener una forma m√°s simple de una expresi√≥n matem√°tica compleja.\nCalcular l√≠mites: determinar el valor al que tiende una funci√≥n cuando su variable se acerca a un punto determinado.\nEncontrar derivadas e integrales: calcular la tasa de cambio y el √°rea bajo la curva de una funci√≥n.\nResolver sistemas de ecuaciones lineales: encontrar los valores de las variables que satisfacen un conjunto de ecuaciones simult√°neas.\nManipular matrices: realizar operaciones con matrices como multiplicaci√≥n, inversi√≥n y transposici√≥n.\nResolver ecuaciones diferenciales: encontrar las funciones que satisfacen una ecuaci√≥n diferencial dada."
  },
  {
    "objectID": "clases2025/clase09_sympy.html#variables-simb√≥licas-y-expresiones",
    "href": "clases2025/clase09_sympy.html#variables-simb√≥licas-y-expresiones",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.2 Variables simb√≥licas y expresiones",
    "text": "1.2 Variables simb√≥licas y expresiones\n\nLa mayor√≠a de las variables en Python se refieren a un n√∫mero, una cadena de texto u otro tipo de dato. Hacer c√°lculos sobre tales variables da como resultado m√°s n√∫meros, cadenas o estructuras de datos.\nUna variable simb√≥lica es una variable que representa un s√≠mbolo matem√°tico, como \\(x\\) o \\(\\theta\\), no un n√∫mero u otro tipo de dato. Hacer operaciones sobre variables simb√≥licas da como resultado una expresi√≥n representativa de una expresi√≥n matem√°tica real.\n\n\n1.2.0.1 Ejemplo\n\nSi una variable simb√≥lica \\(y\\) se refiere a una variable matem√°tica \\(y\\), la multiplicaci√≥n \\(3*y\\) da como resultado la expresi√≥n \\(3y\\).\nTodo esto se hace sin asignar un valor num√©rico real a \\(y\\).\n\nEn SymPy, se definen las variables simb√≥licas utilizando la funci√≥n Symbol(). Por ejemplo:\n\nimport sympy as sy\n\nx = sy.Symbol('x')  # define la variable simb√≥lica x\ny = sy.Symbol('y')  # define la variable simb√≥lica y\n\nTambien podemos definir varias variables simb√≥licas al mismo tiempo:\n\n# Define multiples variables simb√≥licas simult√°neamente.\nx2, x3 = sy.symbols('x2, x3') # Separar los s√≠mbolos por comas\nx, y, z = sy.symbols('x:z')   # Separar una secuencia de letras con dos puntos\nx4, x5, x6 = sy.symbols('x4:7') # Separar una secuencia de letras+numero con dos puntos\n\n\nLas expresiones matem√°ticas se construyen utilizando operadores y operandos.\nLos operadores pueden ser aritm√©ticos (+, -, *, /), l√≥gicos (and, or, not) o relacionales (==, !=, &lt;, &gt;, &lt;=, &gt;=).\nLos operandos pueden ser n√∫meros, variables simb√≥licas o expresiones.\nPor ejemplo:\n\n\n# Combina variables simb√≥licas para crear expresiones.\nexpr = x**2 + x*y + 3*x*y + 4*y**3\nprint(expr)\n\nx**2 + 4*x*y + 4*y**3\n\n\n\n\n1.2.1 Nota importante:\n\nSymPy define sus propios tipos de datos num√©ricos para enteros, flotantes y n√∫meros racionales:\na = sy.Integer(5)  # N√∫mero entero\nb = sy.Real(3.14)  # N√∫mero real\nc = sy.Rational(1, 2)  # N√∫mero racional\nSIEMPRE revisa qu√© tipo de dato num√©rico te conviene usar en una expresi√≥n de SymPy.\nUsa sys.Rational y sys.Integer siempre que sea posible para que SymPy pueda simplificar las expresiones.\n\n\nx = sy.symbols('x')\nexpr_float = (2/3) * sy.sin(x) # 2/3 es de tipo float, pero con sys.Rational podriamos mantenerlo como fracci√≥n\nprint(\"Expresi√≥n con flotante:\\n\", expr_float)\nexpr_frac = sy.Rational(2, 3) * sy.sin(x) # Mantiene 2/3 simb√≥lico.\nprint(\"Expresi√≥n con sys.Rational:\\n\", expr_frac)\n\nExpresi√≥n con flotante:\n 0.666666666666667*sin(x)\nExpresi√≥n con sys.Rational:\n 2*sin(x)/3\n\n\n\n\n1.2.2 Nota importante (continuaci√≥n)\nSymPy tambi√©n tiene sus propias funciones matem√°ticas (como sin(x), log(x), ra√≠z cuadrada, etc.) y sus propias constantes como \\(\\pi\\):\n\nFunciones trigonom√©tricas:\n\nsy.sin(x): seno de x\nsy.cos(x): coseno de x\nsy.tan(x): tangente de x\nsy.asin(x): arcoseno de x\nsy.acos(x): arcocoseno de x\nsy.atan(x): arcotangente de x\n\nFunciones exponenciales y logar√≠tmicas:\n\nsy.exp(x): exponencial de x\nsy.log(x): logaritmo natural de x\nsy.log10(x): logaritmo en base 10 de x\n\nFunciones hiperb√≥licas:\n\nsy.sinh(x): seno hiperb√≥lico de x\nsy.cosh(x): coseno hiperb√≥lico de x\nsy.tanh(x): tangente hiperb√≥lica de x\n\nFunciones especiales:\n\nsy.gamma(x): funci√≥n gamma\nsy.beta(x, y): funci√≥n beta\nsy.erf(x): funci√≥n error\n\nConstantes matem√°ticas:\n\nsy.pi: œÄ (pi)\nsy.e: e (constante de Euler)\nsy.oo: ‚àû (infinito)\nsy.nan: NaN (valor no num√©rico)\n\n\nSIEMPRE usa las funciones y constantes de SymPy para crear expresiones simb√≥licas"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#ejercicio-parte-1",
    "href": "clases2025/clase09_sympy.html#ejercicio-parte-1",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.3 Ejercicio (Parte 1)",
    "text": "1.3 Ejercicio (Parte 1)\nEscribe la siguiente expresi√≥n de forma simb√≥lica:\n\\[\n\\frac{2}{5}e^{x^2-y}\\cdot \\cos{(x+ y)} + \\frac{3}{7}\\log{(xy+1)}\n\\]"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#manipulaci√≥n-de-expresiones-algebr√°icas",
    "href": "clases2025/clase09_sympy.html#manipulaci√≥n-de-expresiones-algebr√°icas",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.4 Manipulaci√≥n de expresiones algebr√°icas",
    "text": "1.4 Manipulaci√≥n de expresiones algebr√°icas\nSymPy ofrece funciones para realizar diversas operaciones con expresiones algebr√°icas:\n\nsy.summation(): escribir una sumatoria\nsy.product(): escribir un producto\nsy.expand(): expandir una expresi√≥n\nsy.simplify(): simplificar una expresi√≥n\nsy.factor(): factorizar una expresi√≥n\nsy.collect(): agrupar t√©rminos similares en una expresi√≥n\n\nPor ejemplo:\n\n1.4.0.1 Sumatoria\n\\[\n\\sum_{i=1}^{4} x^{i} = x + x^2 + x^3 + x^4\n\\]\n\\[\n\\sum_{i=0}^{\\infty} \\frac{1}{2^{i}} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + ...\n\\]\n\nx, i = sy.symbols('x, i')\n# Sumatoria de i=1 a i=4 de x^i\nsuma1 = sy.summation(x**i, (i, 1, 4))\nprint(suma1)\n\n# Sumatoria infinita de 1/(2^i)\nsuma2 = sy.summation(1/(2**i), (i, 0, sy.oo))\nprint(suma2)\n\nx**4 + x**3 + x**2 + x\n2\n\n\n\n\n1.4.0.2 Producto\n\\[\nn! = \\prod_{i=1}^{n} i = 1 \\cdot 2 \\cdot ... \\cdot n\n\\]\n\\[\n\\prod_{i=1}^{\\infty} 1 + \\frac{1}{i} = (1 + 1 ) \\cdot (1 + \\frac{1}{2}) \\cdot (1 + \\frac{1}{3}) \\cdot ...\n\\]\n\nn, i = sy.symbols('n, i')\n\n# Producto de 1 a n de i\nprod1 = sy.product(i, (i, 1, n))\nprint(prod1)\n\n# Producto infinito de (1 + 1/i)\nprod2= sy.product(1 + 1/i, (i, 1, sy.oo))\nprint(prod2)\n\nfactorial(n)\nProduct(1 + 1/i, (i, 1, oo))\n\n\n\n\n1.4.0.3 Expandir\n\nx = sy.Symbol('x')\n\nexpandir1 = sy.expand((x + 1)**2)\nprint(expandir1)\n# Salida: x**2 + 2*x + 1\n\nexpandir2 = sy.expand((x + 1)**3)\nprint(expandir2)\n# Salida: x**3 + 3*x**2 + 3*x + 1\n\nx**2 + 2*x + 1\nx**3 + 3*x**2 + 3*x + 1\n\n\n\n\n1.4.0.4 Simplificar\n\nsimplificar1 = sy.simplify((x**2 + 4*x + 4)/(x + 2))\nprint(simplificar1)\n# Salida: x + 2\n\nsimplificar2 = sy.simplify(sy.sin(x)**2 + sy.cos(x)**2)\nprint(simplificar2)\n# Salida: 1\n\nx + 2\n1\n\n\n\n\n1.4.0.5 Factorizar\n\nfactorizar1 = sy.factor(x**2 + 4*x + 4)\nprint(factorizar1)\n# Salida: (x + 2)**2\n\nfactorizar2 = sy.factor(x**3 - 8)\nprint(factorizar2)\n# Salida: (x - 2)*(x**2 + 2*x + 4)\n\n(x + 2)**2\n(x - 2)*(x**2 + 2*x + 4)\n\n\n\n\n1.4.0.6 Agrupar t√©rminos semejantes\n\nexpr = x**2 + 3*x + 2 + 2*x**2 + x + 1\n\nagrupar = sy.collect(expr, x)\nprint(agrupar)\n# Salida: 3*x**2 + 4*x + 3\n\n3*x**2 + 4*x + 3"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#ejercicio-parte-2",
    "href": "clases2025/clase09_sympy.html#ejercicio-parte-2",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.5 Ejercicio (Parte 2)",
    "text": "1.5 Ejercicio (Parte 2)\n\nEscribe y simplifica la siguiente expresi√≥n:\n\n\\[\n\\prod_{i=1}^{5} \\sum_{j=1}^{5} j \\cdot (\\sin(x)^2 + \\cos(x)^2)\n\\]"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#de-lo-simb√≥lico-a-lo-num√©rico-sy.lambdify",
    "href": "clases2025/clase09_sympy.html#de-lo-simb√≥lico-a-lo-num√©rico-sy.lambdify",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.6 De lo Simb√≥lico a lo Num√©rico: sy.lambdify()",
    "text": "1.6 De lo Simb√≥lico a lo Num√©rico: sy.lambdify()\n\nsy.lambdify() es una funci√≥n en Sympy que permite convertir expresiones simb√≥licas en funciones lambda de Python. Esto es √∫til cuando se necesita evaluar la expresi√≥n en valores num√©ricos.\nla sintaxis de sy.lambdify() es la siguiente:\n\nsy.lambdify(variables, expresion, modulo='numpy')\n\nvariables: Especifica las variables simb√≥licas utilizadas en la expresi√≥n.\nexpression: Es la expresi√≥n simb√≥lica que se desea convertir en una funci√≥n lambda.\nmodules: (Opcional) Define el m√≥dulo en el que se basar√° la funci√≥n lambda. Por defecto, es ‚Äòmath‚Äô, pero tambi√©n puede ser ‚Äònumpy‚Äô u otro m√≥dulo compatible con las operaciones matem√°ticas.\n\nPor ejemplo:\n\nx = sy.Symbol('x')\nexpr = x**2 + 3*x + 2 \n\n# Creamos una funci√≥n lambda para evaluar la expresi√≥n\nf = sy.lambdify(x, expr)\n\n# Evaluamos la funci√≥n en un valor espec√≠fico de x\nresultado = f(2)\nprint(resultado)  # Salida: 12\n\n12"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#c√°lculo",
    "href": "clases2025/clase09_sympy.html#c√°lculo",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.7 C√°lculo",
    "text": "1.7 C√°lculo\nSymPy permite realizar operaciones de c√°lculo como:\n\nlimit(): calcular el l√≠mite de una funci√≥n\ndiff(): calcular la derivada de una funci√≥n\nintegrate(): calcular la integral de una funci√≥n\nseries(): obtener la expansi√≥n en serie de una funci√≥n\n\nPor ejemplo:\n\n# Definimos la variable simb√≥lica\nx = sy.Symbol('x')\n\n# Definimos la funci√≥n\nf = (x**2-1) / (x - 1)\n\n# Calculamos el l√≠mite de la funci√≥n cuando x tiende a 1\nlimite = sy.limit(f, x, 1)\nprint(\"L√≠mite:\", limite)\n\n# Calculamos la derivada de la funci√≥n\nderivada = sy.diff(f, x)\nprint(\"Derivada:\", derivada)\n\n# Calculamos la integral de la funci√≥n\nintegral = sy.integrate(f, x)\nprint(\"Integral:\", integral)\n\n# Obtenemos la expansi√≥n en serie de la funci√≥n alrededor de x = 0 hasta el t√©rmino de orden 3\nserie = sy.series(f, x, 0, 3)\nprint(\"Serie:\", serie)\n\nL√≠mite: 2\nDerivada: 2*x/(x - 1) - (x**2 - 1)/(x - 1)**2\nIntegral: x**2/2 + x\nSerie: 1 + x + O(x**3)"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#resoluci√≥n-de-ecuaciones",
    "href": "clases2025/clase09_sympy.html#resoluci√≥n-de-ecuaciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.8 Resoluci√≥n de ecuaciones",
    "text": "1.8 Resoluci√≥n de ecuaciones\n\nSymPy es capaz de resolver ecuaciones algebraicas, ya sea en una variable o en varias, utilizando la funci√≥n solveset().\nsolveset() toma como primer argumento una expresi√≥n que se supone igualada a 0, y como segundo argumento la(s) variable(s) desconocida.\n\nPor ejemplo:\n\n# Definimos la variable simb√≥lica\nx = sy.Symbol('x')\n\n# Resolver la ecuaci√≥n x^4 - 1 = 0\nsolucion = sy.solveset(x**4 - 1, x)\nprint(solucion)\n\n{-1, 1, -I, I}"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#sistemas-de-ecuaciones-lineales",
    "href": "clases2025/clase09_sympy.html#sistemas-de-ecuaciones-lineales",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.9 Sistemas de ecuaciones lineales",
    "text": "1.9 Sistemas de ecuaciones lineales\n\nSymPy tambi√©n puede resolver sistemas de ecuaciones lineales.\nPara hacer esto, utilizamos la funci√≥n solve() y proporcionamos las ecuaciones (igualadas a cero) y las variables desconocidas como una tupla.\n\nPor ejemplo:\n\n# Resolver el sistema de ecuaciones:\n# x + 5y = 2\n# -3x + 6y = 15\n\n# Definimos las variables simb√≥licas\nx, y = sy.symbols('x, y')\n\n# Resolvemos\nsolucion_sistema = sy.solve((x + 5 * y - 2, \n                             -3 * x + 6 * y - 15), \n                            (x, y))\nprint(\"Soluci√≥n para x:\", solucion_sistema[x])\nprint(\"Soluci√≥n para y:\", solucion_sistema[y])\n\nSoluci√≥n para x: -3\nSoluci√≥n para y: 1"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#√°lgebra-lineal",
    "href": "clases2025/clase09_sympy.html#√°lgebra-lineal",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.10 √Ålgebra Lineal",
    "text": "1.10 √Ålgebra Lineal\n\nSymPy tambi√©n puede resolver sistemas de ecuaciones en su forma matricial \\(\\mathbf{Ax} = \\mathbf{b}\\).\nPara ello, se define la matriz aumentada \\(\\mathbf{M} = [\\mathbf{A} | \\mathbf{b}]\\) y se llama a sy.solve_linear_system() en \\(\\mathbf{M}\\).\nLas matrices en SymPy se definen con sy.Matrix(), con la misma sintaxis que los arrays bidimensionales de NumPy.\nNota: Las matrices de SymPy admiten las operaciones est√°ndar de matrices como la adici√≥n +, la sustracci√≥n - y la multiplicaci√≥n @.\n\nPor ejemplo:\n\\[\n\\begin{align*}\nx + y + z &= 5 \\\\\n2x + 4y + 3z &= 2 \\\\\n5x + 10y + 2z &= 4 \\\\\n\\end{align*}\n\\]\n\n# Definir los s√≠mbolos x, y, z\nx, y, z = sy.symbols('x y z')\n\n# Definir la matriz aumentada M = [A|b]\nM = sy.Matrix([\n    [1, 1, 1, 5],\n    [2, 4, 3, 2],\n    [5, 10, 2, 4]\n])\n\n# Resolver el sistema, proporcionando las variables simb√≥licas para resolver\nsolucion = sy.solve_linear_system(M, x, y, z)\nprint(solucion)\n\n{x: 98/11, y: -45/11, z: 2/11}\n\n\n\nAdem√°s, las matrices de SymPy tienen muchos m√©todos √∫tiles, algunos de los cuales se enumeran a continuaci√≥n.\n\n\n\n\n\n\n\n\nM√©todo\nRetorna\n\n\n\n\ndet()\nEl determinante.\n\n\neigenvals()\nLos valores propios y sus multiplicidades.\n\n\neigenvects()\nLos vectores propios y sus correspondientes valores propios.\n\n\ninv()\nLa inversa de la matriz.\n\n\nis_nilpotent()\nVerdadero si la matriz es nilpotente.\n\n\nnorm()\nLa norma de Frobenius, ‚àû, 1 o 2.\n\n\nnullspace()\nEl espacio nulo como una lista de vectores.\n\n\nrref()\nLa forma escalonada reducida.\n\n\nsingular_values()\nLos valores singulares."
  },
  {
    "objectID": "clases2025/clase09_sympy.html#ejercicio-parte-3",
    "href": "clases2025/clase09_sympy.html#ejercicio-parte-3",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.11 Ejercicio (Parte 3)",
    "text": "1.11 Ejercicio (Parte 3)\n\nResuelve el siguiente sistema de ecuaciones: \\[\n\\begin{eqnarray}\nx+y &=& 2\\\\\n2x + y &=& 0\n\\end{eqnarray}\n\\]"
  },
  {
    "objectID": "clases2025/clase09_sympy.html#referencias-bibliogr√°ficas",
    "href": "clases2025/clase09_sympy.html#referencias-bibliogr√°ficas",
    "title": "Programaci√≥n Aplicada II",
    "section": "1.12 Referencias bibliogr√°ficas",
    "text": "1.12 Referencias bibliogr√°ficas\n\nSymPy Development Team. (2023). SymPy Documentation. https://acme.byu.edu/00000179-d4cb-d26e-a37b-fffb577c0001/sympy-pdf\nJones, E., Oliphant, T., & Peterson, P. (2023). Scipy Lectures: A Gentle Introduction to Scientific Computing with Python. https://scipy-lectures.org/_downloads/ScipyLectures-simple.pdf"
  },
  {
    "objectID": "clases2025/clase10_pandas.html",
    "href": "clases2025/clase10_pandas.html",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\nImagen de medium.com"
  },
  {
    "objectID": "clases2025/clase10_pandas.html#clase-10-pandas",
    "href": "clases2025/clase10_pandas.html#clase-10-pandas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase10_pandas.html#pandas",
    "href": "clases2025/clase10_pandas.html#pandas",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.2 Pandas",
    "text": "1.2 Pandas\n\n\n\nPandas (‚ÄúPanel Data‚Äù) es una herramienta de manipulaci√≥n de datos de alto nivel que se utiliza para analizar datos.\nEs muy f√°cil importar y exportar datos usando Pandas, ya que tiene una rica colecci√≥n de funciones.\nEst√° construida sobre paquetes como NumPy y Matplotlib, y nos proporciona un entorno conveniente para realizar la mayor parte del an√°lisis y visualizaci√≥n de datos.\n\n\n\n\n\n\n\n\nImagen de wesmckinney.com"
  },
  {
    "objectID": "clases2025/clase10_pandas.html#instalaci√≥n",
    "href": "clases2025/clase10_pandas.html#instalaci√≥n",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.3 üëâ Instalaci√≥n",
    "text": "1.3 üëâ Instalaci√≥n\nSi no tienes instalada la biblioteca, puedes hacerlo con:\npip install pandas\nO bien,\nconda install pandas\n\n1.3.1 Diferencias entre Pandas y NumPy:\n\nNumPy requiere que los datos sean homog√©neos, mientras que Pandas permite distintos tipos de datos (float, int, string, datetime, etc.).\nPandas tiene una interfaz m√°s simple para cargar archivos, graficar, seleccionar, unir, agrupar, etc.\nLos DataFrames de Pandas, con nombres de columnas, hacen m√°s f√°cil el seguimiento de los datos.\nPandas es ideal para datos tabulares; NumPy para arreglos num√©ricos."
  },
  {
    "objectID": "clases2025/clase10_pandas.html#estructuras-de-datos",
    "href": "clases2025/clase10_pandas.html#estructuras-de-datos",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.4 Estructuras de Datos",
    "text": "1.4 Estructuras de Datos\n\nUna estructura de datos es una colecci√≥n de valores y operaciones que se pueden aplicar sobre esos datos.\nPermite almacenamiento, recuperaci√≥n y modificaci√≥n eficiente.\nEn Pandas, trabajamos principalmente con:\n\nSeries\nDataFrames"
  },
  {
    "objectID": "clases2025/clase10_pandas.html#series",
    "href": "clases2025/clase10_pandas.html#series",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.5 Series",
    "text": "1.5 Series\n\nUna Serie es un arreglo unidimensional que contiene una secuencia de valores de cualquier tipo de dato (int, float, lista, string, etc.), que por defecto tienen etiquetas num√©ricas comenzando desde cero.\nLa etiqueta asociada a cada valor se llama √≠ndice.\n\n\nimport pandas as pd\nserie1 = pd.Series([10, 20, 30])\nprint(serie1)\n# segundo elemento en la serie\nprint(\"Elemento en serie1:\")\nprint(serie1[1]) # acceso por √≠ndice num√©rico\n\n0    10\n1    20\n2    30\ndtype: int64\nElemento en serie1:\n20\n\n\nTambi√©n podemos asignar etiquetas personalizadas como √≠ndices. Por ejemplo:\n\n# √≠ndices con n√∫meros arbitrarios\nserie2 = pd.Series([\"Kavi\", \"Shyam\", \"Ravi\"], index=[3, 5, 1])\nprint(serie2)\nprint(\"Elemento en serie2:\")\n# print(serie2[2]) # Esta linea es correcta?\n\n# √≠ndices tipo texto\nserie3 = pd.Series([2, 3, 4], index=[\"Feb\", \"Mar\", \"Abr\"])\nprint(serie3)\nprint(\"Elemento en serie3:\")\n#print(serie3[2]) # Esta linea es correcta? \n\n3     Kavi\n5    Shyam\n1     Ravi\ndtype: object\nElemento en serie2:\nFeb    2\nMar    3\nAbr    4\ndtype: int64\nElemento en serie3:\n\n\n\nAdem√°s de crear series a partir de listas, tambi√©n podemos usar arrays de numpy o diccionarios:\n\n\nimport numpy as np\n\n# Serie a partir de numpy array\narray1 = np.array([1, 2, 3, 4])\nserie4 = pd.Series(array1)\nprint(serie4)\n# ¬øcu√°les ser√≠an los √≠ndices asociados a esta Serie?\n\n# Serie a partir de diccionario\ndict1 = {'India': 'NewDelhi', 'UK': 'London', 'Jap√≥n': 'Tokio'}\nserie5 = pd.Series(dict1)\nprint(serie5)\n# ¬øcu√°les ser√≠an los √≠ndices asociados a esta Serie?\n\n0    1\n1    2\n2    3\n3    4\ndtype: int32\nIndia    NewDelhi\nUK         London\nJap√≥n       Tokio\ndtype: object\n\n\n\n1.5.1 Acceso a elementos\n\nComo vimos en los ejemplos anteriores, podemos obtener un elemento de la Serie utilizando su √≠ndice asociado.\nTambi√©n podemos hacer slicing de Series, de forma similar a como lo hacemos con listas y arrays de numpy.\n\n\nserieCapitales = pd.Series(['NewDelhi', 'WashingtonDC', 'London', 'Paris'],\n                          index=['India', 'USA', 'UK', 'Francia'])\nprint(serieCapitales)\nprint(\"Obtenemos un elemento:\")\nprint(serieCapitales[\"India\"]) # Obtenemos un elemento de la serie\nprint(\"Obtenemos una rebanada de elementos:\")\nprint(serieCapitales[1:3]) # Obtenemos un subconjunto usando √≠ndices num√©ricos\nprint(\"Obtenemos una rebanada de elementos:\")\nprint(serieCapitales['USA':'Francia']) # Obtenemos un subconjunto usando √≠ndices de texto\n\nIndia          NewDelhi\nUSA        WashingtonDC\nUK               London\nFrancia           Paris\ndtype: object\nObtenemos un elemento:\nNewDelhi\nObtenemos una rebanada de elementos:\nUSA    WashingtonDC\nUK           London\ndtype: object\nObtenemos una rebanada de elementos:\nUSA        WashingtonDC\nUK               London\nFrancia           Paris\ndtype: object\n\n\n\n\n1.5.2 Modificaci√≥n de elementos\n\nDe igual manera, tambi√©n podemos cambiar los valores de los elementos:\n\n\nserieAlfabeto = pd.Series(np.arange(0, 26), index=list('abcdefghijklmnopqrstuvwxyz'))\nserieAlfabeto[1:3] = 50\nserieAlfabeto['c':'e'] = 500\nprint(serieAlfabeto)\n\na      0\nb     50\nc    500\nd    500\ne    500\nf      5\ng      6\nh      7\ni      8\nj      9\nk     10\nl     11\nm     12\nn     13\no     14\np     15\nq     16\nr     17\ns     18\nt     19\nu     20\nv     21\nw     22\nx     23\ny     24\nz     25\ndtype: int32\n\n\n\n\n1.5.3 Atributos de una Serie\n\n\n\n\n\n\n\n\nAtributo\nDescripci√≥n\nEjemplo\n\n\n\n\n.name\nNombre de la Serie\nserie.name = 'Valores'\n\n\n.index.name\nNombre del √≠ndice\nserie.index.name = '√çndices'\n\n\n.values\nDevuelve los valores como array de NumPy\nserie.values\n\n\n.size\nN√∫mero total de elementos\nserie.size\n\n\n.empty\nTrue si est√° vac√≠a, False si tiene datos\nserie.empty\n\n\n\n\nprint(serieCapitales.name)\nprint(serieCapitales.index.name)\nprint(serieCapitales.values)\nprint(serieCapitales.size)\nprint(serieCapitales.empty)\n\n# Cambia el nombre de seriesCapitales y su nombre de √≠ndice a Capitales y Pa√≠ses, respectivamente\n\nNone\nNone\n['NewDelhi' 'WashingtonDC' 'London' 'Paris']\n4\nFalse\n\n\n\n\n1.5.4 M√©todos comunes\n\n.head(n): primeros n elementos.\n.tail(n): √∫ltimos n elementos.\n.count(): n√∫mero de elementos no nulos.\n\n\n# Imprime los √∫ltimos 3 elementos de la serie del alfabeto\n\n# Cuenta cuantos paises hay en la serie de capitales\n\n\n\n1.5.5 Operaciones matem√°ticas entre Series\n\nCuando hacemos operaciones con dos Series en Pandas, los valores se suman solo cuando los √≠ndices coinciden.\nSi un √≠ndice existe en una Serie pero no en la otra, el resultado para ese √≠ndice ser√° NaN, indicando un valor faltante.\n\nserieA + serieB\n\nSi un √≠ndice no est√° en ambas Series, el resultado es NaN.\nOpcionalmente, podemos usar m√©todos para reemplazar NaN:\n\nserieA.add(serieB, fill_value=0)   # Suma rellenando valores faltantes\nserieA.sub(serieB, fill_value=1000) # Resta usando 1000 como valor de relleno\nserieA.mul(serieB, fill_value=0)    # Multiplica rellenando 0\nserieA.div(serieB, fill_value=1)    # Divide rellenando 1\n\nPor ejemplo, ¬øc√≥mo har√≠amos para sumar estas dos series?\n\n\n\n\n\n\n\n\n\n\n√≠ndice\nserieA\nserieB\nserieA + serieB\n\n\n\n\na\n1\n-10\n-9.0\n\n\nb\n2\nNaN\nNaN\n\n\nc\n3\n-50\n-47.0\n\n\nd\n4\nNaN\nNaN\n\n\ne\n5\n100\n105.0\n\n\ny\nNaN\n20\nNaN\n\n\nz\nNaN\n10\nNaN\n\n\n\n\nserieA = pd.Series([1, 2, 3, 4, 5], index=list('abcde'))\nserieB = pd.Series([-10, -50, 100, 20, 10], index=list('aceyz'))\nprint(serieA+serieB)\nprint(serieA.add(serieB, fill_value=0))\n\na     -9.0\nb      NaN\nc    -47.0\nd      NaN\ne    105.0\ny      NaN\nz      NaN\ndtype: float64\na     -9.0\nb      2.0\nc    -47.0\nd      4.0\ne    105.0\ny     20.0\nz     10.0\ndtype: float64"
  },
  {
    "objectID": "clases2025/clase10_pandas.html#dataframe",
    "href": "clases2025/clase10_pandas.html#dataframe",
    "title": "1 Programaci√≥n Aplicada II",
    "section": "1.6 DataFrame",
    "text": "1.6 DataFrame\n\nA veces necesitamos trabajar con m√∫ltiples Series a la vez, es decir, procesar datos tabulares. Pandas almacena este tipo de datos usando una estructura llamada DataFrame.\nUn DataFrame es una estructura de datos bidimensional etiquetada (filas y columnas), similar a una hoja de c√°lculo o una tabla en una base de datos.\nContiene √≠ndices tanto para filas como para columnas. Cada columna puede tener un tipo de dato diferente (n√∫mero, cadena, booleano, etc.), igual que una tabla en una base de datos.\n\n\n1.6.1 Creaci√≥n de DataFrame\n\n1.6.1.1 Creaci√≥n de un DataFrame vac√≠o:\nEsto crea un DataFrame sin filas ni columnas.\n\nimport pandas as pd\ndf_vacio = pd.DataFrame()\n\n\n\n1.6.1.2 Creaci√≥n de DataFrame desde arreglos de NumPy\nPodemos crear un DataFrame simple sin etiquetas de columna usando un solo arreglo o m√∫ltiples arreglos:\n\nimport numpy as np\n\narray1 = np.array([10, 20, 30])\ndf_array = pd.DataFrame(array1)\nprint(df_array)\n\narray2 = np.array([100, 200, 300])\narray3 = np.array([-10, -20, -30, -40])\ndf_multi = pd.DataFrame([array1, array3, array2], columns=['A', 'B', 'C', 'D'])\nprint(df_multi)\n# Si hay un n√∫mero desigual de elementos, se insertar√° `NaN` en las celdas faltantes.\n\n    0\n0  10\n1  20\n2  30\n     A    B    C     D\n0   10   20   30   NaN\n1  -10  -20  -30 -40.0\n2  100  200  300   NaN\n\n\n\n\n1.6.1.3 Creaci√≥n desde un diccionario de listas\nLas claves se convierten en etiquetas de columnas y las listas en filas. Todas las listas deben tener la misma longitud.\n\ndict_datos = {\n    'Estado': ['Assam', 'Delhi', 'Kerala'],\n    'AreaGeo': [78438, 1483, 38852],\n    'BosqueDenso': [2797, 6.72, 1663]\n}\n\ndf_dict_list = pd.DataFrame(dict_datos)\nprint(df_dict_list)\n\n   Estado  AreaGeo  BosqueDenso\n0   Assam    78438      2797.00\n1   Delhi     1483         6.72\n2  Kerala    38852      1663.00\n\n\n\n\n1.6.1.4 Creaci√≥n desde Series\n\nPodemos crear un DataFrame usando una o m√°s Series.\nCada Series se convierte en una fila. Los √≠ndices de las Series se convierten en etiquetas de columna.\nSi los √≠ndices no coinciden, se incluyen todas las etiquetas posibles y se rellena con NaN donde falten datos:\n\n\nserie_a = pd.Series([1, 2, 3, 4, 5], index=['a', 'b', 'c', 'd', 'e'])\nserie_b = pd.Series([1000, 2000, -1000, -5000, 1000], index=['a', 'b', 'c', 'd', 'e'])\ndf_series = pd.DataFrame([serie_a, serie_b])\nprint(df_series)\n\n      a     b     c     d     e\n0     1     2     3     4     5\n1  1000  2000 -1000 -5000  1000\n\n\n\n\n\n1.6.2 Operaciones sobre filas y columnas en un DataFrame\n\nPandas permite realizar operaciones comunes sobre filas y columnas de un DataFrame como selecci√≥n, eliminaci√≥n, adici√≥n y renombramiento.\n\n\n1.6.2.1 Agregar una nueva columna\n\nPodemos agregar f√°cilmente una nueva columna asignando una lista de valores al nombre de la columna.\nSi la columna ya existe, se actualizar√°n los valores.\n\n\nboleta_df = pd.DataFrame({\n    'Ana': [90, 91, 97],\n    'Luis': [92, 81, 96],\n    'Pedro': [89, 91, 88]\n}, index=['Matem√°ticas', 'Ciencias', 'Historia'])\n\n\nboleta_df['Pedro'] = [89, 78, 76]\nboleta_df['Edgar'] = 90  # Asigna 90 a toda la columna de Edgar\n\n\n\n1.6.2.2 Agregar una nueva fila\nPara agregar una fila, usamos DataFrame.loc[nuevo_indice]:\n\nboleta_df.loc['Ingl√©s'] = [95, 86, 95, 80]\n\nSi el √≠ndice ya existe, los datos ser√°n actualizados. Por ejemplo:\n\nboleta_df.loc['Ingl√©s'] = [85, 86, 83, 80]  # actualiza la fila existente\n\nTambi√©n podemos asignar un mismo valor a toda la fila:\n\nboleta_df.loc['Matem√°ticas'] = 0\n\n\n\n1.6.2.3 Eliminar filas o columnas\n\nUsamos DataFrame.drop() con axis=0 para filas o axis=1 para columnas:\nSi hay filas duplicadas con la misma etiqueta, todas las instancias ser√°n eliminadas.\n\n\n# Eliminar fila\nboleta_df2 = boleta_df.drop('Ciencias', axis=0)\n\n# Eliminar m√∫ltiples columnas\nboleta_df3 = boleta_df2.drop(['Luis', 'Ana'], axis=1)\n\n\n\n1.6.2.4 Acceso a columnas y filas en DataFrames\n\n\n\n\n\n\n\n\nM√©todo\nTipo de acceso\nEjemplo\n\n\n\n\ndf[col]\nColumna por etiqueta\ndf['edad']\n\n\ndf.loc[]\nPor etiqueta\ndf.loc[0, 'edad']\n\n\ndf.iloc[]\nPor posici√≥n\ndf.iloc[0, 1]\n\n\nSlicing\nRango de filas/columnas\ndf.iloc[1:4]\n\n\nCondicional\nFiltro l√≥gico\ndf[df['edad'] &gt; 25]\n\n\nserie[indice]\nSerie por etiqueta o posici√≥n\nserie['a'], serie[0]\n\n\n\n\n\n\n1.6.3 Slicing (rebanado de datos)\n\nboleta_df.head()\n\n\n\n\n\n\n\n\nAna\nLuis\nPedro\nEdgar\n\n\n\n\nMatem√°ticas\n0\n0\n0\n0\n\n\nCiencias\n91\n81\n78\n90\n\n\nHistoria\n97\n96\n76\n90\n\n\nIngl√©s\n85\n86\n83\n80\n\n\n\n\n\n\n\n\nprint(boleta_df.iloc[0:3])       # Primeras tres filas\nprint(boleta_df.loc[:, 'Pedro'])  # Todas las calificaciones de Pedro\nprint(boleta_df.loc[['Historia', 'Ingl√©s'], ['Ana', 'Edgar']])  # Subconjunto de filas y columnas\n\n             Ana  Luis  Pedro  Edgar\nMatem√°ticas    0     0      0      0\nCiencias      91    81     78     90\nHistoria      97    96     76     90\nMatem√°ticas     0\nCiencias       78\nHistoria       76\nIngl√©s         83\nName: Pedro, dtype: int64\n          Ana  Edgar\nHistoria   97     90\nIngl√©s     85     80\n\n\n\n\n1.6.4 Filtro condicional\n\nprint(boleta_df[boleta_df['Luis'] &gt; 90])\nprint(boleta_df[boleta_df['Ana'] == 0])\n\n          Ana  Luis  Pedro  Edgar\nHistoria   97    96     76     90\n             Ana  Luis  Pedro  Edgar\nMatem√°ticas    0     0      0      0\n\n\n\n\n1.6.5 Ejercicio\n\nCrea un DataFrame con 5 canciones o pel√≠culas.\n\nColumnas: ‚Äòt√≠tulo‚Äô, ‚Äòa√±o‚Äô, ‚Äòcalificaci√≥n‚Äô\n\nRealiza:\n\nAcceso al segundo elemento (por √≠ndice y por etiqueta si personalizas el √≠ndice).\nFiltro de elementos con calificaci√≥n mayor a 4.\nExtracci√≥n de solo columnas de t√≠tulo y calificaci√≥n.\nAcceso a la √∫ltima fila.\n\n\n\n\n1.6.6 Transposici√≥n\n\nPodemos reorganizar filas y columnas de varias formas.\nLa transposici√≥n intercambia filas y columnas: las filas se convierten en columnas y las columnas en filas.\n\n\ndf = pd.DataFrame({\n    'Ana': pd.Series([90, 91, 97], index=['Matem√°ticas', 'Ciencias', 'Historia']),\n    'Luis': pd.Series([92, 81, 96], index=['Matem√°ticas', 'Ciencias', 'Historia']),\n})\n\nprint('antes (df)')\nprint(df.head())\ndf_transpuesto = df.T\nprint('\\ndespues (df)')\nprint(df_transpuesto.head())\n\nantes (df)\n             Ana  Luis\nMatem√°ticas   90    92\nCiencias      91    81\nHistoria      97    96\n\ndespues (df)\n      Matem√°ticas  Ciencias  Historia\nAna            90        91        97\nLuis           92        81        96\n\n\n\n\n1.6.7 Pivotear\n\nCuando los datos est√°n en formato ‚Äúlargo‚Äù (long format) y queremos reorganizarlos, podemos usar .pivot().\n\nindex: valores que ir√°n como filas.\ncolumns: valores que ir√°n como nombres de columnas.\nvalues: valores que se mostrar√°n en las celdas.\n\n\n\ndf = pd.DataFrame({\n    'Alumno': ['Ana', 'Ana', 'Luis', 'Luis'],\n    'Materia': ['Matem√°ticas', 'Ciencias', 'Matem√°ticas', 'Ciencias'],\n    'Calificaci√≥n': [90, 91, 92, 81]\n})\n\n\nprint('antes (df)')\nprint(df.head())\npivote = df.pivot(index='Alumno', columns='Materia', values='Calificaci√≥n')\n\nprint('\\ndespues (df)')\nprint(pivote.head())\n\nantes (df)\n  Alumno      Materia  Calificaci√≥n\n0    Ana  Matem√°ticas            90\n1    Ana     Ciencias            91\n2   Luis  Matem√°ticas            92\n3   Luis     Ciencias            81\n\ndespues (df)\nMateria  Ciencias  Matem√°ticas\nAlumno                        \nAna            91           90\nLuis           81           92"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html",
    "href": "clases2025/clase12_algoritmos-en-grafos.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#clase-12-algoritmos-en-grafos",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#clase-12-algoritmos-en-grafos",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#temario",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#temario",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 Temario",
    "text": "2 Temario"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#contenido",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#contenido",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Contenido",
    "text": "3 Contenido\n\n¬øQu√© es un grafo?\nComponentes de un grafo\nTipos de grafos\nRepresentaci√≥n de grafos\nAlgoritmos en grafos\nAplicaciones de los algoritmos en grafos\nEjercicio\n\n\n3.1 ¬øQu√© es un grafo?\n\nUn grafo es una estructura matem√°tica que consiste en un conjunto de nodos (tambi√©n llamados v√©rtices) y un conjunto de aristas (tambi√©n llamadas bordes) que conectan pares de nodos.\nLos grafos se utilizan para representar relaciones entre entidades. Por ejemplo, podr√≠amos tener un grafo donde los nodos son ciudades y las aristas representan las carreteras que conectan las ciudades.\n\n\nImagen de towardsdatascience.com\n\n\n3.2 Componentes de un grafo:\n\nNodos (V√©rtices): Son los elementos fundamentales de un grafo. Cada nodo puede representar una entidad o un objeto.\nAristas (Bordes): Son conexiones entre nodos. Pueden ser dirigidas (con una direcci√≥n espec√≠fica) o no dirigidas (bidireccionales).\nPeso de las aristas: Algunas aristas pueden tener un peso asociado, que representa alg√∫n tipo de medida entre los nodos que conecta. Por ejemplo, el costo de viajar de una ciudad a otra.\n\n\nImagen de adacomputerscience.org\n\n\n3.3 Tipos de grafos:\n\nGrafos dirigidos: En estos grafos, las aristas tienen una direcci√≥n espec√≠fica. Si hay una arista que va del nodo A al nodo B, no necesariamente hay una arista en la direcci√≥n opuesta.\nGrafos no dirigidos: En estos grafos, las aristas no tienen direcci√≥n. Si hay una arista que conecta el nodo A con el nodo B, tambi√©n hay una arista que conecta el nodo B con el nodo A.\nGrafos ponderados: En estos grafos, las aristas tienen un peso asociado.\n\n\nImagen de medium.com\n\n\n3.4 Representaci√≥n de grafos:\nHay dos formas comunes de representar grafos: matrices de adyacencia y listas de adyacencia.\n\nMatriz de adyacencia:\n\nEs una matriz booleana donde el elemento en la fila i y la columna j indica si hay una arista que conecta el nodo i con el nodo j.\nSi el grafo es no dirigido y ponderado, los elementos de la matriz pueden contener el peso de la arista en lugar de solo indicar su presencia.\nEs eficiente para determinar si hay una arista entre dos nodos.\nRequiere un espacio de memoria proporcional a V^2, donde V es el n√∫mero de nodos en el grafo.\n\nLista de adyacencia:\n\nEs una lista de listas donde cada lista representa los nodos vecinos de un nodo dado.\nEs m√°s eficiente en t√©rminos de espacio para grafos dispersos.\nEs m√°s eficiente para recorrer todos los vecinos de un nodo.\nRequiere un espacio de memoria proporcional a V + E, donde V es el n√∫mero de nodos y E es el n√∫mero de aristas en el grafo.\n\n\n\nImagen de bournetocode.com\n\n\n3.5 Ejemplo: Grafo representado con matrices de adyacencia\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nclass Grafo:\n    def __init__(self, num_nodos):\n        self.num_nodos = num_nodos\n        self.matriz_adyacencia = np.zeros((num_nodos, num_nodos), dtype=int)\n\n    def agregar_arista(self, nodo_origen, nodo_destino, peso=1):\n        self.matriz_adyacencia[nodo_origen, nodo_destino] = peso\n        # si el grafo es no dirigido, tambi√©n agregamos la arista de destino a origen \n        self.matriz_adyacencia[nodo_destino, nodo_origen] = peso \n        \n\n    def eliminar_arista(self, nodo_origen, nodo_destino):\n        self.matriz_adyacencia[nodo_origen, nodo_destino] = 0\n\n    def obtener_adyacentes(self, nodo):\n        adyacentes = []\n        for i in range(self.num_nodos):\n            if self.matriz_adyacencia[nodo, i] != 0:\n                adyacentes.append(i)\n        return adyacentes\n\n    def imprimir_matriz_adyacencia(self):\n        print(\"Matriz de Adyacencia:\")\n        for fila in self.matriz_adyacencia:\n            for elemento in fila:\n                print(elemento, \"\\t\", end=\"\")\n            print()\n    \n    def visualizar_grafo(self):\n        plt.figure(figsize=(8, 6))\n        ax = plt.gca()\n        ax.set_title(\"Grafo\")\n\n        # Dibujar nodos\n        pos = {i: (np.cos(2 * np.pi * i / self.num_nodos), np.sin(2 * np.pi * i / self.num_nodos)) for i in range(self.num_nodos)}\n        for nodo in range(self.num_nodos):\n            ax.plot(pos[nodo][0], pos[nodo][1], 'o', markersize=20, label=f\"Nodo {nodo}\")\n\n        # Dibujar aristas\n        for i in range(self.num_nodos):\n            for j in range(self.num_nodos):\n                if self.matriz_adyacencia[i, j] != np.inf:\n                    ax.plot([pos[i][0], pos[j][0]], [pos[i][1], pos[j][1]], 'k-', lw=self.matriz_adyacencia[i, j]/5)\n\n        ax.axis(\"equal\")\n        ax.axis(\"off\")\n        ax.legend()\n        plt.show()    \n\n# Programa principal\ngrafo = Grafo(5) # Creamos un grafo con 5 v√©rtices/nodos\ngrafo.agregar_arista(0, 1, 5) # agregamos una conexi√≥n del nodo 0 al 1 con un valor de 5\ngrafo.agregar_arista(0, 2, 3) # agregamos una conexi√≥n del nodo 0 al 2 con un valor de 3\ngrafo.agregar_arista(1, 3, 7) # agregamos una conexi√≥n del nodo 1 al 3 con un valor de 7\ngrafo.agregar_arista(2, 4, 2) # agregamos una conexi√≥n del nodo 2 al 4 con un valor de 2\ngrafo.agregar_arista(3, 4, 4) # agregamos una conexi√≥n del nodo 3 al 4 con un valor de 4\n\ngrafo.imprimir_matriz_adyacencia()\ngrafo.visualizar_grafo()\n\nMatriz de Adyacencia:\n0   5   3   0   0   \n5   0   0   7   0   \n3   0   0   0   2   \n0   7   0   0   4   \n0   0   2   4   0"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#ejercicio-parte-1",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#ejercicio-parte-1",
    "title": "Programaci√≥n Aplicada II",
    "section": "4 Ejercicio (Parte 1)",
    "text": "4 Ejercicio (Parte 1)\n\nUtilizando la clase anterior crea y visualiza el siguiente grafo (puedes asumir que el grafo es no dirigido):\n\n\n\n\nhttps://www.educative.io/api/edpresso/shot/6738347923865600/image/4587527119831040\n\n\nImagen de www.educative.io\n\n4.1 Algoritmos en grafos:\nLos algoritmos en grafos son procedimientos que operan en un grafo para realizar ciertas tareas, como encontrar rutas, determinar la conectividad, encontrar ciclos, entre otros. Algunos de los algoritmos m√°s comunes son:\n\nB√∫squeda en profundidad (DFS): Es un algoritmo que recorre un grafo de manera recursiva o utilizando una pila, visitando todos los nodos vecinos de un nodo antes de pasar al siguiente nodo no visitado. Se utiliza para encontrar componentes conectados, ciclos, entre otros.\nB√∫squeda en amplitud (BFS): Es un algoritmo que recorre un grafo de manera iterativa, visitando todos los nodos vecinos de un nodo antes de pasar a los nodos vecinos del siguiente nivel. Se utiliza para encontrar el camino m√°s corto entre dos nodos, o para encontrar el camino m√°s corto desde un nodo hasta todos los dem√°s nodos en un grafo no ponderado.\nAlgoritmo de Dijkstra: Es un algoritmo que encuentra el camino m√°s corto entre un nodo origen y todos los dem√°s nodos en un grafo ponderado con pesos no negativos.\nAlgoritmo de Bellman-Ford: Similar al algoritmo de Dijkstra, pero funciona en grafos con pesos negativos, aunque no puede contener ciclos de peso negativo.\nAlgoritmo de Kruskal: Es un algoritmo para encontrar el √°rbol de expansi√≥n m√≠nima de un grafo, es decir, el conjunto de aristas que conecta todos los nodos del grafo y cuya suma de pesos es m√≠nima.\nAlgoritmo de Prim: Similar al algoritmo de Kruskal, pero comienza construyendo el √°rbol de expansi√≥n m√≠nima desde un nodo espec√≠fico, agregando progresivamente la arista de menor peso que conecta un nodo ya incluido en el √°rbol con un nodo no incluido.\n\n\n\n4.2 Aplicaciones de los algoritmos con grafos:\n\nRedes sociales: Los algoritmos de b√∫squeda en profundidad y b√∫squeda en amplitud pueden utilizarse para encontrar comunidades o amigos en com√∫n, en este caso los nodos son personas y las aristas representan conexiones entre ellas.\nRutas de navegaci√≥n: Los algoritmos de b√∫squeda de caminos m√°s cortos, como Dijkstra y Bellman-Ford, se utilizan para encontrar la ruta m√°s corta entre dos ubicaciones en un mapa, o para calcular la ruta √≥ptima para la entrega de paquetes.\nRedes de transporte: Los grafos se utilizan para modelar redes de transporte, como sistemas de metro o carreteras. Los algoritmos de √°rbol de expansi√≥n m√≠nima, como Kruskal y Prim, pueden utilizarse para encontrar la ruta m√°s eficiente para conectar todas las ubicaciones.\nGesti√≥n de proyectos: Los grafos se utilizan para modelar dependencias entre tareas en un proyecto. Los algoritmos de b√∫squeda en profundidad y b√∫squeda en amplitud pueden utilizarse para determinar el orden en el que deben realizarse las tareas."
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#ejemplo-algoritmo-b√∫squeda-en-amplitud-bfs",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#ejemplo-algoritmo-b√∫squeda-en-amplitud-bfs",
    "title": "Programaci√≥n Aplicada II",
    "section": "5 Ejemplo: Algoritmo B√∫squeda en Amplitud (BFS)",
    "text": "5 Ejemplo: Algoritmo B√∫squeda en Amplitud (BFS)\n\nEl prop√≥sito principal del algoritmo BFS es encontrar el camino m√°s corto entre dos nodos en un grafo no ponderado o encontrar la distancia m√≠nima entre el nodo inicial y todos los dem√°s nodos en un grafo no ponderado.\nBFS explora todos los nodos vecinos de un nodo antes de pasar a explorar los nodos vecinos de sus vecinos.\n\n\n\n\nhttps://miro.medium.com/v2/resize:fit:1400/1*-1fTrxNSviViBj8EJLMzhA.gif\n\n\nImagen de medium.com\n\n5.1 Algoritmo BFS (grafo, nodo origen, nodo destino):\n\nCreamos una lista (queue) para almacenar los nodos que vamos a explorar.\nInicialmente, agregamos una tupla con el nodo inicial y una lista que contiene solo el nodo inicial a la lista.\nCreamos un conjunto (visited) para almacenar los nodos que ya hemos visitado.\nMarcamos el nodo origen como visitado.\nMientras la queue no est√© vac√≠a:\n\nSacamos el primer elemento de la lista.\nSi este nodo es el nodo destino, hemos encontrado la ruta y terminamos. Devolvemos la lista de la ruta hasta este nodo.\nSi no, exploramos los nodos vecinos de este nodo:\n\nPara cada nodo vecino que no haya sido visitado:\n\nAgregamos una tupla con el nodo vecino y la lista que contiene la ruta hasta este nodo al final de la lista.\nMarcamos el nodo vecino como visitado.\n\n\n\nSi terminamos el bucle sin encontrar el nodo destino, significa que no hay una ruta desde el nodo inicial al nodo destino.\n\n\n# NOTA: Agregar este m√©todo a la clase Grafo que ya tenemos\n\ndef bfs(self, inicio, destino):\n    lista = [(inicio, [inicio])]  # Inicializar la lista con el nodo inicial y su ruta\n    visitado = [False] * self.num_nodos # Inicializar una lista de nodos visitados\n    visitado[inicio] = True\n\n    while lista:\n        nodo_actual, ruta_actual = lista.pop(0) # Extraer el primer nodo de la lista\n\n        if nodo_actual == destino:\n            return ruta_actual\n\n        for vecino in self.obtener_adyacentes(nodo_actual): # Encuentra todos los vecinos no visitados\n            if not visitado[vecino]:\n                visitado[vecino] = True # Marcar cada vecino como visitado y \n                lista.append((vecino, ruta_actual + [vecino])) # agregarlo a la lista\n\n    return None  # No se encontr√≥ una ruta\n\ndef visualizar_ruta(self, ruta):\n    self.visualizar_grafo(agregar=True)\n    x_coords = [self.pos[i][0] for i in ruta]\n    y_coords = [self.pos[i][1] for i in ruta]\n    ax = self.fig.gca()\n    ax.plot(x_coords, y_coords, color=\"lightgreen\")\n    plt.show()"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#ejercicio-parte-2",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#ejercicio-parte-2",
    "title": "Programaci√≥n Aplicada II",
    "section": "6 Ejercicio (Parte 2)",
    "text": "6 Ejercicio (Parte 2)\n\nPara el grafo que creaste en la parte 2, usa el algoritmo BFS para encontrar la ruta del nodo 2 al nodo 4.\nAgrega un m√©todo para visualizar la ruta con matplotlib.\n\n\n6.1 Aplicaci√≥n al problema del laberinto:\n(Ver www.dcode.fr/maze-generator para generar laberintos)\n\nDado un laberinto representado como una matriz booleana donde:\n\n0 representa un camino transitable y\n1 representa un obst√°culo,\n\nencuentra el camino m√°s corto desde la posici√≥n inicial hasta la posici√≥n de destino.\n\nSoluci√≥n:\n\nRepresentamos el laberinto como una matriz booleana en la que cada celda indica si es transitable o un obst√°culo.\nIdentificamos los nodos del grafo: cada nodo es una celda del laberinto y las aristas representan los movimientos posibles entre celdas\nUtilizamos el algoritmo de BFS para encontrar el camino m√°s corto desde la posici√≥n inicial hasta la posici√≥n de destino.\nConstrucci√≥n del camino m√°s corto: Una vez que hemos encontrado la posici√≥n de destino, reconstruimos el camino m√°s corto recorriendo los nodos padres desde la posici√≥n de destino hasta la posici√≥n inicial.\n\n\nclass Laberinto:\n    def __init__(self, matriz_laberinto):\n        \n        self.matriz_laberinto = matriz_laberinto\n        self.num_filas = len(matriz_laberinto)\n        self.num_columnas = len(matriz_laberinto[0])\n        self.num_nodos = self.num_filas * self.num_columnas\n        self.grafo = self.laberinto_a_grafo()\n\n    def laberinto_a_grafo(self):\n        grafo = Grafo(self.num_nodos)\n\n        for i in range(self.num_filas):\n            for j in range(self.num_columnas):\n                if self.matriz_laberinto[i, j]==0:\n                    nodo_actual = i * self.num_columnas + j\n                    # Checar arriba, abajo, izquierda, derecha\n                    for df, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nueva_fila, nueva_columna = i + df, j + dc\n                        if 0 &lt;= nueva_fila &lt; self.num_filas and \\\n                           0 &lt;= nueva_columna &lt; self.num_columnas and\\\n                           self.matriz_laberinto[nueva_fila, nueva_columna]== 0:\n                            vecino = nueva_fila * self.num_columnas + nueva_columna\n                            grafo.agregar_arista(nodo_actual, vecino)\n        return grafo\n\n    def bfs_camino_mas_corto(self, inicio, destino):\n        inicio_nodo = inicio[0] * self.num_columnas + inicio[1]\n        destino_nodo = destino[0] * self.num_columnas + destino[1]\n\n        camino = self.grafo.bfs(inicio_nodo, destino_nodo)\n\n        if camino:\n            # Convertir el camino de nodos a coordenadas (filas, columnas)\n            camino_coordenadas = [(n // self.num_columnas, n % self.num_columnas) for n in camino]\n            return camino_coordenadas\n        else:\n            return None\n        \n    def visualizar_laberinto(self, camino=None):\n        laberinto_imagen = np.copy(self.matriz_laberinto)\n        if camino:\n            for fila, columna in camino:\n                laberinto_imagen[fila, columna] = 2\n        \n        cmap = plt.get_cmap('viridis', 3)\n        plt.imshow(laberinto_imagen, cmap=cmap)\n        \n        plt.title(\"Laberinto\")\n        plt.axis(\"off\")\n        \n        cbar = plt.colorbar(ticks=[0, 1, 2], orientation='horizontal')\n        cbar.ax.set_xticklabels(['Pasillo', 'Pared', 'Soluci√≥n'])\n        plt.show()\n        \n    @classmethod\n    def leer_laberinto_desde_archivo(cls, archivo, pared_char=\"1\", pasillo_char=\" \"):\n        with open(archivo, \"r\") as f:\n            laberinto = []\n            for linea in f:\n                fila = []\n                for char in linea:  # Eliminar el car√°cter de salto de l√≠nea\n                    if char == pared_char:\n                        fila.append(1)  # Representaci√≥n num√©rica de la pared\n                    elif char == pasillo_char:\n                        fila.append(0)  # Representaci√≥n num√©rica del pasillo\n                laberinto.append(fila)\n        return cls(np.array(laberinto))\n\n\n# Ejemplo laberinto\ninicio = (0, 0)\ndestino = (20, 30)\nlab = Laberinto.leer_laberinto_desde_archivo(\"maze1.txt\")\ncamino_mas_corto = lab.bfs_camino_mas_corto(inicio, destino)\nlab.visualizar_laberinto(camino_mas_corto)"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#m√°s-conceptos-sobre-teor√≠a-de-grafos",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#m√°s-conceptos-sobre-teor√≠a-de-grafos",
    "title": "Programaci√≥n Aplicada II",
    "section": "7 M√°s conceptos sobre teor√≠a de grafos:",
    "text": "7 M√°s conceptos sobre teor√≠a de grafos:\n\n7.1 √Årbol\n\nUn √°rbol en teor√≠a de grafos es un tipo especial de grafo ac√≠clico conectado, es decir, un conjunto de v√©rtices conectados por aristas sin formar ciclos y donde hay exactamente un camino entre cualquier par de v√©rtices.\n\n\n\n7.2 √Årbol de expansi√≥n m√≠nima\n\nEs un subconjunto de aristas que forman un √°rbol que conecta todos los v√©rtices del grafo y tiene el menor peso total posible."
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#ejemplo-2-algoritmo-de-prim",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#ejemplo-2-algoritmo-de-prim",
    "title": "Programaci√≥n Aplicada II",
    "section": "8 Ejemplo 2: Algoritmo de Prim",
    "text": "8 Ejemplo 2: Algoritmo de Prim\n\nEl algoritmo de Prim es un algoritmo de tipo voraz (greedy) utilizado para encontrar un √°rbol de expansi√≥n m√≠nima en un grafo ponderado y conexo.\n\n\n8.1 Aplicaci√≥n del algoritmo de Prim\n\nSupongamos que eres un/a ingeniero/a encargado/a de dise√±ar una red de transporte para conectar varias comunidades rurales en una regi√≥n monta√±osa.\nLas comunidades est√°n dispersas y algunas est√°n ubicadas en terrenos dif√≠ciles de alcanzar.\nEl objetivo es dise√±ar una red de carreteras que conecte todas las comunidades de manera eficiente en t√©rminos de costos de combustible (proporcionales a la distancia entre comunidades), maximizando al mismo tiempo los beneficios econ√≥micos obtenidos de los pasajeros que utilizan la red.\n\n\n\n8.2 Algoritmo de Prim\nEl algoritmo va agregando nodos al √°rbol uno por uno, de acuerdo con los pesos de las aristas que los conectan al √°rbol, iniciando desde un nodo ra√≠z \\(r\\).\n\nSelecciona un nodo inicial arbitrario como ra√≠z del √°rbol de expansi√≥n m√≠nima.\nInicializa tres conjuntos (deben ser del tama√±o de n√∫mero de nodos en el grafo):\n\nincluidos: Lista para almacenar nodos incluidos en el √°rbol de expansi√≥n m√≠nima. Inicializar cada elemento en la lista en False.\nclaves: Lista para almacenar las claves (pesos m√≠nimos) de los nodos, cada elemento en infinito.\npadres: Lista para almacenar el padre de cada nodo en el √°rbol de expansi√≥n m√≠nima, cada elemento en Nulo\n\nInicializa la clave del nodo inicial en 0.\nMientras haya nodos no incluidos en el √°rbol de expansi√≥n m√≠nima:\n\nEncuentra el nodo con la clave m√≠nima que a√∫n no est√° incluido en el √°rbol (min_clave).\nAgrega este nodo al √°rbol de expansi√≥n m√≠nima (marca el nodo como incluido).\nActualiza las claves de los nodos NO INCLUIDOS adyacentes al nodo seleccionado si son menores que las claves actuales almacenadas en claves.\nActualiza los padres de los nodos adyacentes si se ha modificado la clave del nodo adyacente.\n\n\n\n\n\nhttps://miro.medium.com/v2/resize:fit:828/format:webp/0*sRJQy9-CU_5H7wS3.png\n\n\nImagen de https://medium.com/analytics-vidhya/minimum-spanning-tree-prim-3f32445ce854\n\n# NOTA: Agregar este m√©todo a la clase Grafo que ya tenemos\n\ndef prim(self, raiz):\n    # 1. elegimos el nodo raiz\n    # 2. inicializamos tres conjuntos\n    incluido = np.full(self.num_nodos, False)\n    clave = np.full(self.num_nodos, np.inf)\n    padre = np.full(self.num_nodos, None)\n    # 3. inicializamos la clave de raiz en cero\n    clave[raiz]=0\n\n    # 4. mientras haya nodos no incluidos\n    while np.any(incluido==False):\n        # 4A. encuentra el nodo con la clave min que aun no esta incluido\n        nodo_min = -1\n        min_clave = np.inf\n        for i in range(self.num_nodos):\n            if clave[i]&lt;min_clave and not incluido[i]:\n                nodo_min = i\n                min_clave=clave[i]\n        # 4B. agrega el nodo al arbol\n        incluido[nodo_min] = True\n        # 4C. actualiza las claves de los nodos adyacentes\n        #    si son menores a las claves actuales\n        adyacentes = self.obtener_adyacentes(nodo_min)\n        for vecino in adyacentes:\n            if not incluido[vecino]:\n                peso = self.matriz_adyacencia[nodo_min, vecino]\n                if peso &lt; clave[vecino]:\n                    clave[vecino] = peso\n                    padre[vecino] = nodo_min\n    return padre\n\ndef visualizar_arbol(self, arbol):\n    self.visualizar_grafo(agregar=True)\n    ax = self.fig.gca()\n    for i in range(self.num_nodos):\n        if arbol[i] is not None:\n            padre =int(arbol[i])\n            x_coords = [self.pos[padre][0], self.pos[i][0]]\n            y_coords = [self.pos[padre][1], self.pos[i][1]]\n            ax.plot(x_coords, y_coords, color=\"red\")\n    plt.show()"
  },
  {
    "objectID": "clases2025/clase12_algoritmos-en-grafos.html#referencias-bibliogr√°ficas",
    "href": "clases2025/clase12_algoritmos-en-grafos.html#referencias-bibliogr√°ficas",
    "title": "Programaci√≥n Aplicada II",
    "section": "9 Referencias bibliogr√°ficas",
    "text": "9 Referencias bibliogr√°ficas\n\nBurkardt, J. Graph Theory. https://people.sc.fsu.edu/~jburkardt/classes/mpp_2023/graph_theory/graph_theory.pdf\nJeff, E. Algorithms. https://jeffe.cs.illinois.edu/teaching/algorithms/book/05-graphs.pdf\nBedford Computing. Python Algorithms. https://bedford-computing.co.uk/learning/wp-content/uploads/2015/10/Python-Algorithms.pdf"
  },
  {
    "objectID": "clases2025/Ejercicio de Repaso 3.html",
    "href": "clases2025/Ejercicio de Repaso 3.html",
    "title": "Ejercicio de Repaso",
    "section": "",
    "text": "Programaci√≥n Aplicada II, Primavera 2024, Dra. Dora Alvarado\n\n0.1 PARTE 1 (2pts)\n\nSimplifica la expresi√≥n $ $.\nCalcula la integral definida de $ _0^{} ^2(x) , dx $.\nEncuentra la segunda derivada de $ e{-x2} $ con respecto a $ x $.\nResuelve el sistema de ecuaciones \\(2x + y = 5\\) y \\(x - y = 1\\).\n\n\n\n0.2 PARTE 2 (2pts)\n\nCrea un diagrama de dispersi√≥n con 500 puntos generados aleatoriamente en el dominio [-1, 1) y rango [-1, 1).\nRepresenta las funciones en los puntos 1, 2 y 3 en la misma gr√°fica en el intervalo de [-2,2], con etiquetas para cada una. Personaliza el color, el grosor y estilo de cada l√≠nea.\n\n\n\n0.3 PARTE 3 (3pts)\n\nInvestiga e implementa el algoritmo bubble-sort para ordenar los n√∫meros de un arreglo, ¬øcu√°l es su complejidad computacional en t√©rminos de tiempo de ejecuci√≥n? fundamenta tu respuesta explicando cuantas veces se ejecutan las instrucciones en el algoritmo.\nInvestiga e implementa otro algoritmo m√°s eficiente. Muestra su comparativa en tiempos de manera emp√≠rica: ordenar una lista de n√∫meros aleatorios de 10, 50, 100, 500, 1000, 5000, y 10000 de elementos y tomar el tiempo, luego realizar una gr√°fica para comparar resultados.\n\n(No olvidar agregar referencias de su investigaci√≥n, de lo contrario no se tomar√° en cuenta su ejercicio)\n\n\n0.4 PARTE 4 (3pts)\nUsando el c√≥digo que desarrollamos en las clases sobre grafos:\n\nRepresentar a las siguientes comunidades y sus conexiones entre s√≠ a trav√©s de un grafo. Imprimir matriz de adyacencia y representaci√≥n visual del grafo.\n\n\n\n\nCiudad\nConexiones\n\n\n\n\nA\nB (10 km), C (15 km), D (20 km)\n\n\nB\nA (10 km), C (25 km), E (30 km)\n\n\nC\nA (15 km), B (25 km), D (35 km), E (40 km)\n\n\nD\nA (20 km), C (35 km), E (45 km)\n\n\nE\nB (30 km), C (40 km), D (45 km)\n\n\n\n\nUtiliza el algoritmo adecuado seg√∫n lo visto en clase para obtener la mejor ruta para construir una red de transporte que conecte a todas las comunidades minimizando los costos de construcci√≥n."
  },
  {
    "objectID": "clases2025/ejercicio08.html",
    "href": "clases2025/ejercicio08.html",
    "title": "Ejercicio 08: Excepciones, aserciones y pruebas",
    "section": "",
    "text": "0.1 Descripci√≥n:\n\nEn este ejercicio practicaremos el manejo de excepciones, implementaremos aserciones para verificar situaciones y escribiremos pruebas unitarias para validar el comportamiento de una funci√≥n de multiplicaci√≥n de matrices.\n\n\n\n0.2 Archivos:\nUtilizaremos los siguientes archivos:\n\nmatrices.py\ntest_matrices.py\n\n\n\n0.3 Instrucciones:\n\nAn√°lisis del c√≥digo inicial:\n\nRevisa el c√≥digo inicial en matrices.py.\n\nObserva que la funci√≥n multiplicar est√° implementada pero no realiza validaciones de ning√∫n tipo.\n¬øCu√°l el comportamiento de la funci√≥n con matrices con dimensiones incompatibles? Agrega un caso de prueba en el apartado ejemplo de uso y explica el comportamiento del programa.\n\nRevisa el c√≥digo inicial test_matrices.py.\n\nObserva que hay una √∫nica prueba unitaria implementada.\n\n\nCompletar la funci√≥n multiplicar:\n\nAserciones:\n\nVerifica que las matrices sean de tipo list. En caso de no serlo, lanza una excepci√≥n TypeError.\nPara dos matrices, verifica que la cantidad de columnas de la primera matriz coincida con la cantidad de filas de la segunda matriz. En caso de no serlo, lanza una excepci√≥n personalizada llamada DimensionError.\n\nManejo de excepciones:\n\nAgrega un bloque try-except para manejar la excepci√≥n TypeError que se lanza si las matrices no son de tipo list. Dentro del bloque except, imprime un mensaje de error informativo.\nAgrega un bloque except para manejar la excepci√≥n DimensionError que se lanza si las matrices tienen dimensiones incompatibles e imprime un mensaje de error informativo.\n\n\nCompletar las pruebas unitarias:\n\nEn test_matrices.py, agrega nuevas pruebas para:\n\nVerificar que la funci√≥n funciona correctamente con dos matrices v√°lidas (tipo y dimensiones correctas).\nVerificar que la funci√≥n lanza una excepci√≥n TypeError con una matriz de tipo diferente a list.\nVerificar que la funci√≥n lanza una excepci√≥n DimensionError con matrices de dimensiones incompatibles.\n¬øQu√© otro caso de prueba se podr√≠a considerar?\n\n\nEjecutar el c√≥digo:\n\nEjecuta ambos programas matrices.py y test_matrices.py.\nObserva la salida para verificar que todas las pruebas se ejecuten correctamente.\n\n\n\n\n0.4 Entregables\nSube los archivos generados en este ejercicio con el prefijo PA2_Grupo_E08NombreApellido. La parte de c√≥digo debe entregarse en un archivo con extensi√≥n .py.\nConsideraciones:\n\nNo se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc.\nEn caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° la tarea con una deducci√≥n de hasta 50%, dependiendo de la gravedad del error.\nEl uso de bibliotecas externas no est√° permitido en este ejercicio. El ejercicio se anular√° si esta condici√≥n no se cumple.\nEn caso de que la/el estudiante utilice c√≥digo o funciones no vistas en clase, deber√° ser capaz de respaldar su c√≥digo mediante una explicaci√≥n verbal y/o escrita, en caso de que le sea requerida por la docente de la asignatura. De no cumplir con la explicaci√≥n de forma satisfactoria, se anular√° su trabajo y se pasar√° el reporte a la coordinaci√≥n de la carrera.\n\n\n\n0.5 Material de apoyo\n\nDocumentaci√≥n de Python sobre excepciones: https://docs.python.org/3/tutorial/errors.html\nDocumentaci√≥n de unittest: https://docs.python.org/3/library/unittest.html"
  },
  {
    "objectID": "clases2025/Examen2doParcial_D.html",
    "href": "clases2025/Examen2doParcial_D.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\n\n\n\n\n\n\nEste examen tiene una duraci√≥n de 60 minutos.\nCompleta los siguientes ejercicios utilizando los conceptos de Programaci√≥n Orientada a Objetos, vistos en clase.\nDeber√°s usar un entorno de desarrollo como Spyder, VSCode o PyCharm para escribir tu c√≥digo.\nNo se permite el uso de librer√≠as externas distintas a las abordadas en clase.\nEl uso de herramientas externas en Internet est√° estrictamente prohibido.\nLee cuidadosamente las instrucciones de cada tarea antes de comenzar a escribir c√≥digo. Si tienes alguna duda, no dudes en preguntar a la profesora.\nRevisa tu c√≥digo cuidadosamente antes de entregarlo.En caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° dependiendo de la gravedad del error.\nGuarda tu c√≥digo en un archivo con el nombre PA2_D_Examen1_NombreApellido.py. No se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc."
  },
  {
    "objectID": "clases2025/Examen2doParcial_D.html#segundo-examen-parcial",
    "href": "clases2025/Examen2doParcial_D.html#segundo-examen-parcial",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\n\n\n\n\n\n\nEste examen tiene una duraci√≥n de 60 minutos.\nCompleta los siguientes ejercicios utilizando los conceptos de Programaci√≥n Orientada a Objetos, vistos en clase.\nDeber√°s usar un entorno de desarrollo como Spyder, VSCode o PyCharm para escribir tu c√≥digo.\nNo se permite el uso de librer√≠as externas distintas a las abordadas en clase.\nEl uso de herramientas externas en Internet est√° estrictamente prohibido.\nLee cuidadosamente las instrucciones de cada tarea antes de comenzar a escribir c√≥digo. Si tienes alguna duda, no dudes en preguntar a la profesora.\nRevisa tu c√≥digo cuidadosamente antes de entregarlo.En caso de que el c√≥digo presente errores de ejecuci√≥n, se penalizar√° dependiendo de la gravedad del error.\nGuarda tu c√≥digo en un archivo con el nombre PA2_D_Examen1_NombreApellido.py. No se revisar√° c√≥digo que sea entregado en otros formatos que no correspondan con c√≥digo de python, por ejemplo .docx, .pdf, .png, etc."
  },
  {
    "objectID": "clases2025/Examen2doParcial_D.html#mediciones",
    "href": "clases2025/Examen2doParcial_D.html#mediciones",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 1. Mediciones",
    "text": "2 1. Mediciones\nEn una estaci√≥n meteorol√≥gica, se registran mediciones de un sensor a lo largo del tiempo. El sensor realiza 120 mediciones continuas durante 4 horas (es decir, 30 mediciones por hora) y las guarda en el archivo mediciones.txt (una medici√≥n por rengl√≥n). Sin embargo, se ha identificado que las primeras 3 mediciones y las √∫ltimas 5 mediciones en cada intervalo de una hora no son confiables debido a la inicializaci√≥n y apagado de los sistemas de calibraci√≥n.\nImplementa una funci√≥n llamada filtrar_mediciones que tome como par√°metro el nombre del archivo de mediciones y haga lo siguiente:\n\nLeer los datos desde el archivo y almacenarlos en un arreglo (1pt).\nRedimensionar el arreglo para que tenga la forma de una matriz con 4 columnas (1pt).\nConservar a partir de la tercera y antes de las √∫ltimas cinco 5 filas de la matriz (1pt).\nConservar solo cada cuatro mediciones (muestreo de la se√±al) (1pt).\nGuardar el resultado en un archivo de texto con el nombre mediciones_filtro.txt (1pt).\n\nEl resultado esperado es:\n[[1.9, 2.6, 3. , 3.9],\n [1.4, 2.9, 3.3, 2.3],\n [3.4, 4.1, 1.7, 2.4],\n [3.5, 2.2, 3.6, 4.2],\n [3.4, 2. , 2.2, 3.8],\n [4.1, 1.9, 2.3, 3.4]]"
  },
  {
    "objectID": "clases2025/Examen2doParcial_D.html#ecuaciones-cuadr√°ticas",
    "href": "clases2025/Examen2doParcial_D.html#ecuaciones-cuadr√°ticas",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 2. Ecuaciones Cuadr√°ticas",
    "text": "3 2. Ecuaciones Cuadr√°ticas\nEn la empresa en la que trabajas saben que tienes excelentes habilidades de desarrollo de software. Acaban de entrevistar a alguien para el puesto de programador y te han pedido que revises el c√≥digo que el candidato al puesto escribi√≥ para resolver una ecuaci√≥n cuadr√°tica.\nLas ra√≠ces de una ecuaci√≥n cuadr√°tica se pueden encontrar utilizando la f√≥rmula cuadr√°tica:\n\\[ x = \\frac{{-b \\pm \\sqrt{{b^2 - 4ac}}}}{{2a}} \\]\nEl c√≥digo se encuentra en el archivo encontrar_raices.py.\nEn el mismo archivo, verifica el funcionamiento del c√≥digo para las siguientes ecuaciones:\n\n\\(x^2 - 6x + 9 = 0\\)\n\\(2x^2 + 3x + 1 = 0\\)\n\\(5x^2 + 2x + 3 = 0\\)\n\n\n¬øEn cual de los casos el c√≥digo falla y por qu√©? Justifica tu respuesta en un documento donde pongas el paso a paso de la t√©cnica de depuraci√≥n que hayas decidido seguir (1pt).\nCrea una excepci√≥n personalizada para el caso en que no se puede resolver la ecuaci√≥n cuadr√°tica (1pt).\nCorrige el c√≥digo de tal modo que el c√°lculo de raices se encuentre dentro de una funci√≥n y lance la excepci√≥n personalizada en el caso de que la ecuaci√≥n cuadr√°tica no se pueda resolver (1pt).\nVuelve a probar el c√≥digo con el caso en el falla pero agrega un bloque try-except seg√∫n sea necesario para que no se interrumpa la ejecuci√≥n del programa de forma abrupta (1pt).\nDado que se espera que la empresa entreviste a m√°s candidatos y no deseas estar revisando el c√≥digo de manera manual, crea un archivo de pruebas unitarias para verificar el c√≥digo para los casos siguientes (1pt):\n\nCuando las ra√≠ces de la ecuaci√≥n son reales y distintas.\nCuando las ra√≠ces de la ecuaci√≥n son reales e id√©nticas.\nCuando las ra√≠ces de la ecuaci√≥n son imaginarias."
  },
  {
    "objectID": "clases2025/Examen3F.html",
    "href": "clases2025/Examen3F.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "doraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/Examen3F.html#examen-parcial-3",
    "href": "clases2025/Examen3F.html#examen-parcial-3",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "doraelisa.alvaradocarrillo@iberoleon.edu.mx"
  },
  {
    "objectID": "clases2025/Examen3F.html#examen-te√≥rico",
    "href": "clases2025/Examen3F.html#examen-te√≥rico",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 Examen Te√≥rico",
    "text": "2 Examen Te√≥rico\nInstrucciones Generales:\n\nAseg√∫rate de comprender completamente lo que se est√° preguntando antes de seleccionar una respuesta. Algunas preguntas pueden tener m√∫ltiples partes o ser m√°s complicadas de lo que parecen a simple vista.\nAdministra tu tiempo sabiamente. Si alguna pregunta te est√° tomando demasiado tiempo, pasa a la siguiente y vuelve a ella m√°s tarde si tienes tiempo sobrante.\nEn las preguntas de opci√≥n m√∫ltiple, selecciona la opci√≥n que consideres la mejor respuesta. Si no est√°s seguro, elige la opci√≥n que te parezca m√°s plausible.\nEn las preguntas de Verdadero/Falso, aseg√∫rate de entender correctamente la declaraci√≥n antes de decidir si es verdadera o falsa.\n\nResponde:\n1. ¬øQu√© es la notaci√≥n Big O en complejidad algor√≠tmica?\na) Una medida de la complejidad de un algoritmo en t√©rminos de su tiempo de ejecuci√≥n.\nb) Una medida de la complejidad de un algoritmo en t√©rminos de su espacio de memoria requerido.\nc) Una forma de clasificar los algoritmos en t√©rminos de su eficiencia en el peor de los casos.\nd) Una forma de clasificar los algoritmos en t√©rminos de su eficiencia en el mejor de los casos.\n2. Verdadero o Falso: En matplotlib, plt.bar() se utiliza para graficar un histograma. ________________\n3. ¬øQu√© es una variable simb√≥lica en SymPy?\na) Una variable que puede tomar cualquier valor num√©rico.   \nb) Una variable que representa n√∫meros complejos.   \nc) Una variable que representa valores simb√≥licos, como s√≠mbolos matem√°ticos.   \nd) Una variable que se utiliza exclusivamente para gr√°ficos en matplotlib.\n4. Verdadero o Falso: En un grafo ponderado, todas las aristas tienen el mismo peso.________________\n5. ¬øQu√© hace la funci√≥n simplify() en SymPy?\na) Simplifica una expresi√≥n simb√≥lica a su forma m√°s simple.   \nb) Deriva una expresi√≥n simb√≥lica.   \nc) Expande una expresi√≥n simb√≥lica.   \nd) Integra una expresi√≥n simb√≥lica.\n6. Verdadero o Falso: En Python, random.randint(a, b) genera un n√∫mero aleatorio en el rango [a, b], es decir incluyendo a b. ________________\n7. ¬øQu√© tipo de gr√°fico se puede crear con la funci√≥n plt.scatter() en matplotlib?\na) Histograma.   \nb) Gr√°fico de l√≠neas.   \nc) Gr√°fico de barras.   \nd) Gr√°fico de dispersi√≥n.\n8. Verdadero o Falso: Un algoritmo las vegas siempre produce el resultado correcto, pero con una complejidad de tiempo variable. ________________\n9. ¬øQu√© es un grafo dirigido?\na) Un grafo donde las aristas tienen una direcci√≥n definida.   \nb) Un grafo donde todas las aristas tienen el mismo peso.   \nc) Un grafo donde los nodos est√°n ordenados alfab√©ticamente.   \nd) Un grafo donde las aristas son bidireccionales.\n10. Verdadero o Falso: La complejidad algor√≠tmica se refiere a la cantidad de recursos computacionales, como el tiempo y el espacio, que un algoritmo necesita para ejecutarse. ________________\n11. ¬øCu√°l es la diferencia entre un algoritmo probabil√≠stico y un algoritmo determinista?\na) Los algoritmos probabil√≠sticos siempre producen el mismo resultado.   \nb) Los algoritmos deterministas utilizan n√∫meros aleatorios.   \nc) Los algoritmos probabil√≠sticos tienen un elemento de incertidumbre en su ejecuci√≥n.   \nd) Los algoritmos deterministas nunca se ejecutan en tiempo polinomial.\n12. Si un algoritmo tiene complejidad O(n^2) y otro tiene complejidad O(n log n), el algoritmo con complejidad O(n log n) es m√°s lento. ________________"
  },
  {
    "objectID": "clases2025/Examen3F.html#examen-pr√°ctico",
    "href": "clases2025/Examen3F.html#examen-pr√°ctico",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Examen Pr√°ctico",
    "text": "3 Examen Pr√°ctico\nInstrucciones Generales:\n\nEste examen consta de tres partes, cada una con varios ejercicios relacionados con la programaci√≥n aplicada.\nLee detenidamente y resuelve los ejercicios. Si es necesario, incluye explicaciones adicionales para demostrar tu comprensi√≥n del problema.\nPresta atenci√≥n a los detalles de formato y presentaci√≥n al graficar.\nSe asignar√°n los puntos dependiendo de la precisi√≥n de tus respuestas y calidad de tu trabajo.\n\n\n3.1 Parte I: Expresiones simb√≥licas y gr√°ficas (2pts)\n\n\n\nUtiliza SymPy para definir dos expresiones simb√≥licas en funci√≥n de un par√°metro $ t $ (0.5pts).\n\n$ (4t + 4) (2t) $\n$ (4t + 4) (2t) $.\n\nConvierte estas expresiones en funciones f_1 y f_2 para evaluar num√©ricamente (0.5pts).\nCrea un conjunto de 100 valores para $ t $ en el rango de $ 0 $ a $ 2$ y eval√∫a las funciones f_1 y f_2 en ese rango (0.5pts).\nGrafica las funciones f_1 y f_2 en el mismo sistema de coordenadas utilizando matplotlib (las valores de f_1 en el eje de las x, y los valores de f_2 en el eje de las y) (0.5pts).\n\n(Aseg√∫rate de etiquetar adecuadamente los ejes y las funciones en tu gr√°fica, como se muestra en el ejemplo.)\n\n&lt;div style=\"width: 5%;\"&gt;\n&lt;/div&gt;\n\n&lt;img src=\"imgs/examen3.png\" alt=\"Grafica\" style=\"width:100%; margin-left:auto; margin-right:auto;\"&gt;\n  \n\n\n\n\n3.2 Parte II: Lanzamiento de dados (2pts)\n\nEscribe una funci√≥n lanzamiento_dados() que simule el lanzamiento de dos dados y devuelva la suma de los resultados (+0.5pts).\nImplementa una funci√≥n simulacion_suma_7() que simule el proceso de lanzamiento de dos dados hasta obtener una suma de 7. La funci√≥n debe devolver el n√∫mero de lanzamientos necesarios (+0.5pts).\nEjecuta la simulaci√≥n 1000 veces y guarda en una lista el n√∫mero de lanzamientos necesarios para obtener una suma de 7. (+0.5pt).\nGrafica un histograma que muestre la distribuci√≥n del n√∫mero de lanzamientos necesarios para obtener una suma de 7 en las 1000 simulaciones (+0.5pt).\n\n\n\n3.3 Parte III: Gesti√≥n de Redes Sociales (2pts)\nSupongamos que est√°s dise√±ando un sistema de recomendaci√≥n de amigos para una red social. Para ello, deseas utilizar un grafo donde los nodos representan a los usuarios y las aristas representan la amistad entre ellos. Usa el c√≥digo de grafos desarrollado en clases para lo siguiente.\n\nConstruye un grafo que represente la red social de un grupo de 5 usuarios (1pt):\n\nA -- B\n|    | \\\nC -- D  E\n\nUsa el algoritmo bfs para imprimir el n√∫mero m√≠nimo de pasos necesarios para ir de un usuario a otro, para cada par de usuarios en la red social. (+1pt)."
  },
  {
    "objectID": "clases2025/ExamenPractico3D.html",
    "href": "clases2025/ExamenPractico3D.html",
    "title": "Examen Pr√°ctico 3",
    "section": "",
    "text": "Instrucciones Generales:\n\nEste examen consta de tres partes, cada una con varios ejercicios relacionados con el an√°lisis y la visualizaci√≥n de funciones matem√°ticas y datos.\nLee detenidamente y resuelve los ejercicios. Si es necesario, incluye explicaciones adicionales para demostrar tu comprensi√≥n del problema.\nPresta atenci√≥n a los detalles de formato y presentaci√≥n al graficar.\nSe asignar√°n los puntos dependiendo de la precisi√≥n de tus respuestas y calidad de tu trabajo.\n\n\n0.1 Parte I: Funciones y C√°lculo Diferencial e Integral (3pts)\n\nGrafica la funci√≥n $ f(x) = 4x^2 $ en el intervalo $ [0, 3] $ (+0.5pts).\nEncuentra la primera derivada de la funci√≥n con respecto a $ x $ (de manera simb√≥lica) (+0.5pts).\nEncuentra la integral de la funci√≥n:\n\nde manera simb√≥lica (+0.5pts), y\nde manera aproximada en el intervalo [0, 3] usando el m√©todo Monte Carlo que vimos en clase (+0.5pts).\n\nAgrega las funciones integral y derivada en la misma gr√°fica, con etiquetas para cada una. Personaliza la gr√°fica seg√∫n la figura ejemplo (+0.5pts).\n¬øCu√°l es la complejidad del algoritmo que usaste para aproximar el valor de la integral? Justifica tu respuesta analizando cada instrucci√≥n y el n√∫mero de veces que se ejecuta (+0.5pts).\n\n\n\n\nexamen3d.png\n\n\n\n\n0.2 Parte II: Teorema del L√≠mite Central (3pts)\nEl teorema del l√≠mite central dice que:\n\"Bajo las condiciones adecuadas, la distribuci√≥n de la media muestral (la media de muchas muestras aleatorias tomadas de una poblaci√≥n) se aproxima a una distribuci√≥n Gaussiana a medida que el tama√±o de la muestra aumenta, independientemente de la forma de la distribuci√≥n original de la poblaci√≥n.\"\nDemuestra emp√≠ricamente que el teorema es cierto, creando una funci√≥n que haga lo siguiente:\n\nGenera una poblaci√≥n, un conjunto de $ N $ datos aleatorios en el intervalo [0, 100] (+0.5pt).\nInicializa una lista vac√≠a lst_mean.\nRepite 1000 veces:\n\nExtrae una muestra (un subconjunto) aleatoria de esta poblaci√≥n de tama√±o $ M $ (+0.5pts).\nCalcula la media de la muestra y agregala a la lista lst_mean (+0.5pts).\n\nRetorna la lista lst_mean.\nLlama a tu funci√≥n con $ N=1‚Äô000,000 $ y $ M=1000$, y grafica el histograma de las medias muestrales guardadas en lst_mean. Deber√≠as observar que la distribuci√≥n de las medias muestrales se aproxima a una distribuci√≥n Gaussiana (+1pt).\n¬øCual es el comportamiento de la distribuci√≥n de medias muestrales cuando \\(M\\) tiende a \\(1\\)?, ¬øy cuando \\(M\\) tiende a \\(10,000\\)? (+0.5pts).\n\nParte III: Planificaci√≥n Urbana (3pts)\nEn una ciudad en crecimiento, un equipo de urbanistas y planificadores de transporte est√° trabajando en mejorar la red vial para facilitar el desplazamiento de los ciudadanos. Se han identificado cinco barrios importantes que necesitan mejorar sus calles principales.\n\n\n\nBarrio\nConexiones\n\n\n\n\nA\nB (3 km), C (5 km)\n\n\nB\nA (3 km), C (2.5 km), D (4 km)\n\n\nC\nA (5 km), B (2.5 km), D (3.5 km), E (6 km)\n\n\nD\nB (4 km), C (3.5 km), E (2 km)\n\n\nE\nC (6 km), D (2 km)\n\n\n\n\nConstruye el grafo que representa a los barrios y las calles que los conectan (+1pt)\nCalcula el √°rbol de expansi√≥n m√≠nima para optimizar la conectividad entre los barrios (+0.5pt).\nImprime la distancia total de las calles principales que se deben mejorar (+0.5pts).\nVisualiza (ya sea con matplotlib o con un dibujo a mano) el √°rbol de calles a mejorar (+1pt)."
  },
  {
    "objectID": "clases2025/guia-de-estudio_2doParcial-2025.html",
    "href": "clases2025/guia-de-estudio_2doParcial-2025.html",
    "title": "Gu√≠a de Estudio",
    "section": "",
    "text": "Programaci√≥n Aplicada II, Primavera 2025, Dra. Dora Alvarado"
  },
  {
    "objectID": "clases2025/guia-de-estudio_2doParcial-2025.html#conceptos-a-repasar",
    "href": "clases2025/guia-de-estudio_2doParcial-2025.html#conceptos-a-repasar",
    "title": "Gu√≠a de Estudio",
    "section": "1 Conceptos a repasar",
    "text": "1 Conceptos a repasar\n\n1.1 Manejo de errores\n\n¬øCu√°les son algunos ejemplos de excepciones t√≠picas en Python?\n¬øQu√© sucede cuando se genera una excepci√≥n en un programa?\nExplica el concepto de excepciones personalizadas y su utilidad.\n¬øC√≥mo se maneja una excepci√≥n utilizando el bloque try-except?\n¬øCu√°l es la diferencia entre una instrucci√≥n except sin excepci√≥n espec√≠fica y con una excepci√≥n espec√≠fica? ¬øPor qu√© es importante manejar excepciones de manera espec√≠fica en lugar de capturar todas las excepciones?\n¬øC√≥mo manejar m√∫ltiples tipos de excepciones?\nExplica el flujo de ejecuci√≥n en un bloque try-except-else-finally.\n¬øC√≥mo se puede crear una excepci√≥n personalizada en Python?\n¬øCu√°l es la funci√≥n de la instrucci√≥n raise en el contexto de excepciones?\n\n\n\n1.2 Aserciones, pruebas y depuraci√≥n\n\n¬øQu√© significa la programaci√≥n de calidad?\n¬øCu√°les son las pr√°cticas recomendadas para escribir c√≥digo de calidad?\nExplica el concepto de aserciones y proporciona un ejemplo. ¬øD√≥nde son √∫tiles las aserciones en el c√≥digo?\nExplica la diferencia entre pruebas unitarias, de integraci√≥n y de regresi√≥n.\nDescribe la biblioteca de registro. ¬øCu√°les son los niveles de registro en la biblioteca de registro?\n¬øC√≥mo se establece un punto de interrupci√≥n en el depurador de Spyder?\n¬øQu√© es un ‚Äúbug‚Äù en el contexto de la programaci√≥n y de donde viene el t√©rmino?\n¬øQu√© es y por qu√© es importante la depuraci√≥n de errores en el desarrollo de software?\n¬øC√≥mo se usa el depurador en el IDE Spyder y cu√°les son algunas de sus caracter√≠sticas?\n\n\n\n1.3 Bibliotecas externas: NumPy\n\n¬øQu√© es una biblioteca externa y cu√°l es su prop√≥sito principal?\n¬øPor qu√© es beneficioso utilizar bibliotecas externas en el desarrollo de programas?\n¬øCu√°l es la funci√≥n principal de la biblioteca NumPy en el √°mbito de la ingenier√≠a?\nExplica qu√© es un ndarray en NumPy y c√≥mo se diferencia de una lista en Python.\n¬øPor qu√© utilizar ndarray en lugar de listas de Python para operaciones num√©ricas?\n¬øC√≥mo se realiza la creaci√≥n de arrays en NumPy a partir de una lista existente?\n¬øC√≥mo se accede a un √∫nico elemento, a una fila y a una columna espec√≠fica en NumPy?"
  },
  {
    "objectID": "clases2025/guia-de-estudio_2doParcial-2025.html#ejercicios-pr√°cticos",
    "href": "clases2025/guia-de-estudio_2doParcial-2025.html#ejercicios-pr√°cticos",
    "title": "Gu√≠a de Estudio",
    "section": "2 Ejercicios Pr√°cticos",
    "text": "2 Ejercicios Pr√°cticos\n\n2.1 1. Suma de logaritmos\n\nDefine una excepci√≥n personalizada llamada ValorNegativoError.\nCrea una funci√≥n que tome dos n√∫meros como par√°metros y devuelva la suma de sus logaritmos base 10 (usando la biblioteca math). 2A. Si alguno de los par√°metros de la funci√≥n es negativo, lanza una excepci√≥n ValorNegativoError.\nCrea una segunda versi√≥n de la funci√≥n anterior, pero esta vez utiliza una aserci√≥n para verificar que los par√°metros sean n√∫meros positivos.\nEn el flujo principal del programa, solicita al usuario ingresar dos n√∫meros positivos para calcular la suma de sus logaritmos base 10 usando las funciones anteriores. Agrega manejo de excepciones tipo ValorNegativoError, ValueError y AsertionError en bloques except separados.\nCrea un archivo de pruebas unitarias donde verifiques el funcionamiento de ambas funciones para los casos ideales y los casos con valor negativo.\n\n\n\n2.2 2. Depuraci√≥n\nLos siguientes programas contienen errores que deben ser corregidos usando herramientas de depuraci√≥n. Documenta el proceso de identificaci√≥n y correcci√≥n del c√≥digo usando alguna de las herramientas de depuraci√≥n vistas en clase.\n\nfactorial: deber√≠a calcular el factorial de un n√∫mero ingresado por el usuario.\nes_primo: deber√≠a determinar si un n√∫mero ingresado por el usuario es un n√∫mero primo.\nfibonacci: deber√≠a imprimir la serie de Fibonacci hasta el t√©rmino especificado por el usuario.\n\n\n\n2.3 3. Uso de bibliotecas externas\nLos siguientes ejercicios deben realizarse utilizando la biblioteca externa apropiada de acuerdo con los temas vistos en clase.\n\nCrea un array de 3x3 con valores enteros.\nCrea la siguiente matriz principal y crea las matrices derivadas indicadas en colores azul, rojo, verde y amarillo.\nInvestiga y da un ejemplo de c√≥mo realizar la multiplicaci√≥n de dos matrices de 2x2, la transpuesta y el determinante de una matriz.\nEscribe un c√≥digo que resuelva un sistema de ecuaciones lineales.\n\nNota adicional: Se otorgar√° un punto adicional en el examen a las/los estudiantes que env√≠en la soluci√≥n completa y correcta de los ejercicios pr√°cticos de esta gu√≠a."
  },
  {
    "objectID": "clases2025/Markdown.html",
    "href": "clases2025/Markdown.html",
    "title": "Ejercicio (Parte 3)",
    "section": "",
    "text": "Utiliza el algoritmo anterior para resolver el problema de conectar varias comunidades a trav√©s de un dise√±o √≥ptimo de una red de transporte. Considera los siguientes datos y construye el gr√°fo y el √°rbol de expansi√≥n m√≠nima.\n\n\nCiudad A conectada con:\n\nB (10 km)\nC (15 km)\nD (20 km).\n\nCiudad B conectada con:\n\nA (10 km)\nC (25 km)\nE (30 km)\n\nCiudad C conectada con:\n\nA (15 km)\nB (25 km)\nD (35 km)\nE (40 km)\n\nCiudad D conectada con:\n\nA (20 km)\nC (35 km)\nE (45 km)\n\nCiudad E conectada con:\n\nB (30 km)\nC (40 km)\nD (45 km)\n\n\n\nModifica el c√≥digo para que el algoritmo tambi√©n te indique cual ser√° el costo total de la red (el total de km)."
  },
  {
    "objectID": "clases2025/proyectos.html",
    "href": "clases2025/proyectos.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\n\nFecha de entrega: 05 de mayo de 2025\n\n\n\n\nEl objetivo de esta actividad es implementar un algoritmo de los propuestos a continuaci√≥n (o bien, proponer uno y que sea aprobado por la docente del curso), aplic√°ndolo a un problema real y utilizando los conceptos revisados durante el curso. Para ello, se deber√°n cumplir los siguientes requisitos de c√≥digo:\n\nSe deber√° hacer uso del paradigma orientado a objetos.\nSe deber√° incluir manejo de excepciones para el funcionamiento del algoritmo implementado.\nSe deber√°n realizar pruebas unitarias para verificar el funcionamiento del algoritmo implementado.\nSe deber√° hacer uso de al menos una biblioteca externa vista en clase.\nSe podr√° hacer uso de bibliotecas externas no vistas en clase, siempre y cuando se tenga autorizaci√≥n de la docente y se incluya una justificaci√≥n en el reporte y presentaci√≥n."
  },
  {
    "objectID": "clases2025/proyectos.html#proyectos-finales---programaci√≥n-aplicada-ii",
    "href": "clases2025/proyectos.html#proyectos-finales---programaci√≥n-aplicada-ii",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "27382@iberoleon.edu.mx\ndoraelisa.alvaradocarrillo@iberoleon.edu.mx\n\nFecha de entrega: 05 de mayo de 2025\n\n\n\n\nEl objetivo de esta actividad es implementar un algoritmo de los propuestos a continuaci√≥n (o bien, proponer uno y que sea aprobado por la docente del curso), aplic√°ndolo a un problema real y utilizando los conceptos revisados durante el curso. Para ello, se deber√°n cumplir los siguientes requisitos de c√≥digo:\n\nSe deber√° hacer uso del paradigma orientado a objetos.\nSe deber√° incluir manejo de excepciones para el funcionamiento del algoritmo implementado.\nSe deber√°n realizar pruebas unitarias para verificar el funcionamiento del algoritmo implementado.\nSe deber√° hacer uso de al menos una biblioteca externa vista en clase.\nSe podr√° hacer uso de bibliotecas externas no vistas en clase, siempre y cuando se tenga autorizaci√≥n de la docente y se incluya una justificaci√≥n en el reporte y presentaci√≥n."
  },
  {
    "objectID": "clases2025/proyectos.html#√≠ndice",
    "href": "clases2025/proyectos.html#√≠ndice",
    "title": "Programaci√≥n Aplicada II",
    "section": "2 √çndice",
    "text": "2 √çndice\n\nSimulaci√≥n de movimiento de robot\nOptimizaci√≥n de ruta tur√≠stica\nContador de gl√≥bulos blancos\nEvaluaci√≥n de proyectos"
  },
  {
    "objectID": "clases2025/proyectos.html#proyecto-1-simulaci√≥n-de-planificaci√≥n-de-movimiento-de-robot",
    "href": "clases2025/proyectos.html#proyecto-1-simulaci√≥n-de-planificaci√≥n-de-movimiento-de-robot",
    "title": "Programaci√≥n Aplicada II",
    "section": "3 Proyecto 1: Simulaci√≥n de planificaci√≥n de movimiento de robot",
    "text": "3 Proyecto 1: Simulaci√≥n de planificaci√≥n de movimiento de robot\n\nDescripci√≥n:\n\n\n\nEl grupo de investigaci√≥n de Rob√≥tica y Mecatr√≥nica de la IberoLe√≥n se prepara para competir en la prestigiosa competencia internacional Robocup 2025.\nLos mejores estudiantes han sido llamados a contribuir al desarrollo de algoritmos para permitir que un robot humanoide navegue de manera inteligente por el campo de juego, evitando obst√°culos y alcanzando su objetivo.\nEn este proyecto, se implementar√° el algoritmo Tangent-bug para simular el movimiento del robot en un entorno virtual, asegurando su capacidad de sortear obst√°culos y alcanzar su destino.\n\n\n\n\n\n \n\n\nIm√°genes de 2024.robocup.org y www.researchgate.net"
  },
  {
    "objectID": "clases2025/proyectos.html#proyecto-2-optimizaci√≥n-de-ruta-tur√≠stica",
    "href": "clases2025/proyectos.html#proyecto-2-optimizaci√≥n-de-ruta-tur√≠stica",
    "title": "Programaci√≥n Aplicada II",
    "section": "4 Proyecto 2: Optimizaci√≥n de Ruta Tur√≠stica",
    "text": "4 Proyecto 2: Optimizaci√≥n de Ruta Tur√≠stica\n\nDescripci√≥n:\n\n\nEl Gobierno del Estado de Guanajuato busca promover el turismo y el intercambio cultural. Para ello, se requiere una ruta que conecte los sitios tur√≠sticos del estado, maximizando la experiencia del viajero. En este proyecto, se implementar√° el algoritmo de Recocido Simulado para resolver el problema del agente viajero (TSP) y encontrar la mejor ruta para recorrer los sitios tur√≠sticos del estado de Guanajuato.\n\n\n&lt;/div&gt;\n\n&lt;img src=\"imgs/tour.png\" alt=\"Guanajuato\" style=\"width:100%; margin-left:auto; margin-right:auto;\"&gt;\nImagen de www.instagram.com/taglelab\n\n\nObjetivos: - Implementar el algoritmo de Recocido simulado en Python. - Aplicar el algoritmo al problema del TSP para Guanajuato. - Minimizar la distancia total recorrida. - Generar visualizaciones de las rutas.\nTareas: 1. Investigar el algoritmo de Recocido simulado y elaborar un mapa conceptual o infograf√≠a. 2. Definir la estructura de datos para representar los sitios tur√≠sticos y las distancias entre ellos. 3. Implementar el algoritmo de Recocido simulado utilizando clases y manejo de excepciones. 4. Desarrollar pruebas unitarias para verificar el funcionamiento del algoritmo. 5. Implementar la generaci√≥n de visualizaciones de las rutas. 6. Redactar un reporte escrito (m√°ximo 3 hojas) y preparar una presentaci√≥n de 5 minutos.\n\n5 Proyecto 3: Contador de gl√≥bulos blancos\n\nDescripci√≥n:\n\n\nUn grupo de estudiantes de la IberoLe√≥n colabora con un laboratorio de diagn√≥stico cl√≠nico para desarrollar herramientas de an√°lisis automatizado de im√°genes de sangre. Una de las tareas m√°s comunes es contar la cantidad de gl√≥bulos blancos presentes en im√°genes microsc√≥picas de frotis sangu√≠neo, lo cual puede ayudar a detectar infecciones o anomal√≠as hematol√≥gicas.\nEn este proyecto, se implementar√° un programa que procese im√°genes reales o simuladas de muestras de sangre, identifique las c√©lulas blancas presentes y entregue un conteo automatizado.\n\n\n\n\n\n&lt;img src=\"imgs/celulas.png\" alt=\"Gl√≥bulos blancos\" style=\"width:100%; margin-left:auto; margin-right:auto;\"&gt;\nImagen de verywellhealth.com\n\n\nObjetivos: - Procesar im√°genes microsc√≥picas de muestras de sangre. - Implementar el algoritmo de Otsu para identificar gl√≥bulos blancos. - Implementar el algoritmo de componentes conectados para contar las c√©lulas detectadas.\nTareas: 1. Investigar la t√©cnica de segmentaci√≥n de im√°genes en escala de grises (umbralizaci√≥n) Otsu y el algoritmo de componentes conectados para identificar las c√©lulas. 2. Implementar el preprocesamiento de la imagen (escala de grises, suavizado, binarizaci√≥n). 3. Implementar los algoritmos de segmentaci√≥n y etiquetado de componentes conectados para contar c√©lulas. 4. Desarrollar visualizaciones: imagen original, m√°scaras segmentadas y conteo final. 5. Desarrollar pruebas unitarias para validar el procesamiento en im√°genes de prueba. 6. Redactar un reporte escrito (m√°ximo 3 hojas) y preparar una presentaci√≥n de 5 minutos.\n\n5.1 Evaluaci√≥n\n\n\n\n\n\n\n\n\n\n\n\n\nCriterio\nDescripci√≥n\nExcelente (100%)\nBueno (85%)\nSatisfactorio (70%)\nInsuficiente (&lt;70%)\n\n\n\n\n1. Implementaci√≥n del Algoritmo (35%)\n- Uso correcto del paradigma orientado a objetos- Eficiencia y organizaci√≥n del c√≥digo- Manejo de excepciones y validaci√≥n de entradas\nC√≥digo completo, modular, limpio, bien comentado; usa OOP correctamente; sin errores\nC√≥digo funcional con estructura clara; OOP bien aplicado, algunos errores menores\nC√≥digo con errores leves, uso parcial de OOP o validaci√≥n b√°sica\nC√≥digo incompleto, mal estructurado o con fallos graves en ejecuci√≥n\n\n\n2. Pruebas y Validaci√≥n (20%)\n- Pruebas unitarias adecuadas- Documentaci√≥n de casos de prueba y resultados- Correcci√≥n de errores detectados\nPruebas variadas, bien documentadas, detectan errores y corrigen fallos\nPruebas adecuadas, detectan algunos errores; documentaci√≥n comprensible\nPruebas limitadas o poco claras; documentaci√≥n b√°sica\nPruebas ausentes o mal hechas; errores no corregidos\n\n\n3. Visualizaci√≥n y Resultados (20%)\n- Claridad de las visualizaciones o simulaciones- Presentaci√≥n de resultados relevantes y comprensibles\nVisualizaci√≥n clara, precisa y bien integrada con los resultados\nVisualizaci√≥n funcional y adecuada, con pocos errores menores\nVisualizaci√≥n limitada o poco clara\nVisualizaci√≥n ausente o inadecuada\n\n\n4. Reporte y Presentaci√≥n (25%)\n- Explicaci√≥n clara del algoritmo y su aplicaci√≥n- Integraci√≥n de investigaci√≥n previa- Redacci√≥n y exposici√≥n oral\nReporte claro, bien estructurado; incluye investigaci√≥n profunda; presentaci√≥n fluida y profesional\nReporte completo con buena redacci√≥n; investigaci√≥n adecuada; presentaci√≥n comprensible\nReporte b√°sico o poco profundo; investigaci√≥n limitada; presentaci√≥n confusa\nReporte incompleto o mal redactado; investigaci√≥n ausente; presentaci√≥n desorganizada"
  },
  {
    "objectID": "clases2025/proyectos.html#proyecto-3-contador-de-gl√≥bulos-blancos",
    "href": "clases2025/proyectos.html#proyecto-3-contador-de-gl√≥bulos-blancos",
    "title": "Programaci√≥n Aplicada II",
    "section": "5 Proyecto 3: Contador de gl√≥bulos blancos",
    "text": "5 Proyecto 3: Contador de gl√≥bulos blancos\n\nDescripci√≥n:\n\n\nUn grupo de estudiantes de la IberoLe√≥n colabora con un laboratorio de diagn√≥stico cl√≠nico para desarrollar herramientas de an√°lisis automatizado de im√°genes de sangre. Una de las tareas m√°s comunes es contar la cantidad de gl√≥bulos blancos presentes en im√°genes microsc√≥picas de frotis sangu√≠neo, lo cual puede ayudar a detectar infecciones o anomal√≠as hematol√≥gicas.\nEn este proyecto, se implementar√° un programa que procese im√°genes reales o simuladas de muestras de sangre, identifique las c√©lulas blancas presentes y entregue un conteo automatizado.\n\n\n\n\n\n&lt;img src=\"imgs/celulas.png\" alt=\"Gl√≥bulos blancos\" style=\"width:100%; margin-left:auto; margin-right:auto;\"&gt;\nImagen de verywellhealth.com\n\n\nObjetivos: - Procesar im√°genes microsc√≥picas de muestras de sangre. - Implementar el algoritmo de Otsu para identificar gl√≥bulos blancos. - Implementar el algoritmo de componentes conectados para contar las c√©lulas detectadas.\nTareas: 1. Investigar la t√©cnica de segmentaci√≥n de im√°genes en escala de grises (umbralizaci√≥n) Otsu y el algoritmo de componentes conectados para identificar las c√©lulas. 2. Implementar el preprocesamiento de la imagen (escala de grises, suavizado, binarizaci√≥n). 3. Implementar los algoritmos de segmentaci√≥n y etiquetado de componentes conectados para contar c√©lulas. 4. Desarrollar visualizaciones: imagen original, m√°scaras segmentadas y conteo final. 5. Desarrollar pruebas unitarias para validar el procesamiento en im√°genes de prueba. 6. Redactar un reporte escrito (m√°ximo 3 hojas) y preparar una presentaci√≥n de 5 minutos.\n\n5.1 Evaluaci√≥n\n\n\n\n\n\n\n\n\n\n\n\n\nCriterio\nDescripci√≥n\nExcelente (100%)\nBueno (85%)\nSatisfactorio (70%)\nInsuficiente (&lt;70%)\n\n\n\n\n1. Implementaci√≥n del Algoritmo (35%)\n- Uso correcto del paradigma orientado a objetos- Eficiencia y organizaci√≥n del c√≥digo- Manejo de excepciones y validaci√≥n de entradas\nC√≥digo completo, modular, limpio, bien comentado; usa OOP correctamente; sin errores\nC√≥digo funcional con estructura clara; OOP bien aplicado, algunos errores menores\nC√≥digo con errores leves, uso parcial de OOP o validaci√≥n b√°sica\nC√≥digo incompleto, mal estructurado o con fallos graves en ejecuci√≥n\n\n\n2. Pruebas y Validaci√≥n (20%)\n- Pruebas unitarias adecuadas- Documentaci√≥n de casos de prueba y resultados- Correcci√≥n de errores detectados\nPruebas variadas, bien documentadas, detectan errores y corrigen fallos\nPruebas adecuadas, detectan algunos errores; documentaci√≥n comprensible\nPruebas limitadas o poco claras; documentaci√≥n b√°sica\nPruebas ausentes o mal hechas; errores no corregidos\n\n\n3. Visualizaci√≥n y Resultados (20%)\n- Claridad de las visualizaciones o simulaciones- Presentaci√≥n de resultados relevantes y comprensibles\nVisualizaci√≥n clara, precisa y bien integrada con los resultados\nVisualizaci√≥n funcional y adecuada, con pocos errores menores\nVisualizaci√≥n limitada o poco clara\nVisualizaci√≥n ausente o inadecuada\n\n\n4. Reporte y Presentaci√≥n (25%)\n- Explicaci√≥n clara del algoritmo y su aplicaci√≥n- Integraci√≥n de investigaci√≥n previa- Redacci√≥n y exposici√≥n oral\nReporte claro, bien estructurado; incluye investigaci√≥n profunda; presentaci√≥n fluida y profesional\nReporte completo con buena redacci√≥n; investigaci√≥n adecuada; presentaci√≥n comprensible\nReporte b√°sico o poco profundo; investigaci√≥n limitada; presentaci√≥n confusa\nReporte incompleto o mal redactado; investigaci√≥n ausente; presentaci√≥n desorganizada"
  },
  {
    "objectID": "clases2025/Tarea03.html",
    "href": "clases2025/Tarea03.html",
    "title": "Tarea 04",
    "section": "",
    "text": "(Manejo de excepciones, aserciones, pruebas unitarias, depuraci√≥n)\nProgramaci√≥n Aplicada II, Primavera 2024, Dra. Dora Alvarado"
  },
  {
    "objectID": "clases2025/Tarea03.html#parte-1",
    "href": "clases2025/Tarea03.html#parte-1",
    "title": "Tarea 04",
    "section": "1 Parte 1",
    "text": "1 Parte 1\nInstrucciones: Para las siguientes preguntas y ejercicios de c√≥digo, utilizaremos como material de apoyo el video del siguiente enlace:\nExceptions in Python || Python Tutorial || Learn Python Programming\n\nDe acuerdo con lo explicado en el video y usando tus propias palabras, responde las siguientes preguntas.\n\nAl principio del video (en el primer minuto) se mencionan dos ejemplos de situaciones bizarras que pueden generar excepciones en nuestro c√≥digo, ¬øque tipo de excepciones son (de acuerdo con la lista de excepciones estandar de python: https://docs.python.org/3/library/exceptions.html#exception-hierarchy)? Muestra en c√≥digo estos dos ejemplos.\n¬øQu√© es y cuando se genera una excepci√≥n?\n¬øQu√© es el Traceback?\n¬øC√≥mo podemos crear excepciones personalizadas?\n¬øCual es el bloque de instrucciones que debemos agregar para manejar excepciones (aprox. en el minuto 4:30)? ¬øPara que sirve cada parte?\n¬øQu√© tipo de t√©cnica de debugging de las vistas en clase aparece en el ejemplo del video y para que se utiliza?\n¬øA que personajes menciona Socratica y cuales son las frases c√©lebres que aparecen en el video?\n\nRealiza el ejemplo proporcionado en el video (aprox. en el minuto 5:15) y guardalo con el nombre rfile.py.\nModifica la funci√≥n read_file_timed agregando una aserci√≥n para verificar que el par√°metro path es de tipo String.\nAutomatiza el proceso de prueba de la funci√≥n read_file_timed: crea un archivo test_rfile.py, en el cual agregaras pruebas unitarias para los dos casos considerados en el video: a) ejecuci√≥n correcta (archivo existente), b) ejecuci√≥n con excepci√≥n (archivo inexistente)\nAgrega una tercera prueba en tu archivo test_rfile.py, que considere el caso en el que el usuario llama a la funci√≥n read_file_timed con un argumento de tipo incorrecto (por ejemplo un n√∫mero)."
  },
  {
    "objectID": "clases2025/Tarea03.html#parte-2",
    "href": "clases2025/Tarea03.html#parte-2",
    "title": "Tarea 04",
    "section": "2 Parte 2",
    "text": "2 Parte 2\nInstrucciones: En esta parte, utilizaras las herramientas de debugging para corregir el archivo baraja.py, que consiste en un archivo de python con las siguientes funciones: - generar_baraja(): crea una bajara est√°ndar de 52 cartas. - sacar_aleatoria(): saca una carta de la baraja de forma aleatoria. - sacar_carta(): saca una carta espec√≠fica de la baraja. - probar_con_reemplazo(): prueba la funci√≥n sacar_aleatorio() sacando varias cartas al azar de la baraja generada. Imprime las cartas sacadas y tambi√©n el n√∫mero total de cartas √∫nicas sacadas.\n\nEjecuta el programa varias veces y observa que en algunas ocasiones se genera una excepci√≥n.\n\n¬øQu√© tipo de excepci√≥n es y en que l√≠nea se genera?\n¬øQu√© funci√≥n de la biblioteca random se est√° utilizando y c√≥mo funciona?\n\nA continuaci√≥n, utilizando alguna de las herramientas de debugging vistas en clase, realiza el proceso para identificar y corregir el bug en el c√≥digo.\nDocumenta todo el proceso en un documento de Word donde expliques los pasos que seguiste y muestres capturas de pantalla de cada resultado."
  },
  {
    "objectID": "clases2025/Tarea05.html",
    "href": "clases2025/Tarea05.html",
    "title": "Tarea 05",
    "section": "",
    "text": "(Manejo de excepciones, aserciones, pruebas unitarias, depuraci√≥n)\nProgramaci√≥n Aplicada II, Primavera 2024, Dra. Dora Alvarado"
  },
  {
    "objectID": "clases2025/Tarea05.html#parte-1-matplotlib",
    "href": "clases2025/Tarea05.html#parte-1-matplotlib",
    "title": "Tarea 05",
    "section": "1 PARTE 1: Matplotlib",
    "text": "1 PARTE 1: Matplotlib\nPara esta parte, construiremos gr√°ficas de los casos confirmados de COVID-19 en la zona del baj√≠o. Para ello, deberemos hacer uso de la biblioteca pandas para leer los datos del archivo Casos_Diarios_Estado_Nacional_Confirmados_20230625.csv. Usa el c√≥digo ej-pd-matplotlib.py como ayuda e investiga las funciones que sean necesarias para extrar los datos de los estados del baj√≠o: - Jalisco - Guanajuato - Quer√©taro - Michoac√°n\nLuego, construye las gr√°ficas siguientes: - Una grafica de lineas comparando los contagios para cada estado del 01-01-2022 al 24-06-2023 \n\nUna gr√°fica de barras apiladas comparando el total de contagios para cada estado para el total de contagios de estos periodos:\n\nDel 26-02-2020 al 31-12-2020\nDel 01-01-2021 al 31-12-2021\nDel 01-01-2022 al 31-12-2022\nDel 01-01-2023 al 24-06-2023 \n\n\nTip: Puedes usar como referencia el siguiente video: PYTHON: PANDAS y MATPLOTLIB para AN√ÅLISIS DE DATOS (Tutorial F√ÅCILüöÄüöÄüöÄ), pero nota que ni los estados ni las fechas corresponden con este ejercicio."
  },
  {
    "objectID": "clases2025/Tarea05.html#parte-2-teor√≠a-de-grafos",
    "href": "clases2025/Tarea05.html#parte-2-teor√≠a-de-grafos",
    "title": "Tarea 05",
    "section": "2 PARTE 2: Teor√≠a de Grafos",
    "text": "2 PARTE 2: Teor√≠a de Grafos\nDe acuerdo con el siguiente video:\n¬øQu√© tienen que ver Andr√©s Iniesta, Tyrion Lannister y tus amigos de Facebook? | Teor√≠a de grafos\n\n¬øQu√© es un grafo?\n¬øQui√©n invent√≥ la teor√≠a de grafos y de que trata el problema que resolvi√≥ con ella?\n¬øC√≥mo se calcula el grado de un nodo?\nModifica el c√≥digo que hicimos en clase:\n\nAgrega un m√©todo para calcular el grado de un nodo.\nAgrega un m√©todo para determinar si un dibujo como los del minuto 1:40 se puede dibujar sin levantar el l√°piz del papel y sin pasar dos veces por el mismo sitio.\n\n\nNota adicional: Las respuestas deben estar en completa concordancia con lo dicho en el video y con el c√≥digo que hemos estado trabajando en clase, de lo contrario no se tomar√°n en cuenta."
  },
  {
    "objectID": "clases2025/temas_2do_parcial.html",
    "href": "clases2025/temas_2do_parcial.html",
    "title": "Tarea 04: Repaso Parcial 2",
    "section": "",
    "text": "Demuestra, usando ejemplos, que la siguiente afirmaci√≥n es verdadera: ‚ÄúCada error de sintaxis es una excepci√≥n, pero no toda excepci√≥n puede ser un error de sintaxis.‚Äù\n¬øCu√°ndo se producen las siguientes excepciones? Proporciona ejemplos para respaldar tus respuestas.\n\nAssertionError\nImportError\nTypeError\nValueError\n\nInvestiga y define con ejemplos los siguientes conceptos (debes usar fuentes de informaci√≥n confiables, como libros, revistas, sitios web acad√©micos). Agrega las citas bibliogr√°ficas correspondientes:\n\nManejo de excepciones\nGenerar una excepci√≥n\nCapturar una excepci√≥n\n¬øPara que sirve la palabra reservada raise?\n\n\n\nBusca en redes sociales (instagram, twitter, tiktok, youtube, facebook, etc.) contenido multimedia que explique correctamente al menos uno de los conceptos anteriores y con el lenguaje de programaci√≥n que estamos usando en clase. Comparte el enlace del material encontrado."
  },
  {
    "objectID": "clases2025/temas_2do_parcial.html#parte-1-manejo-de-excepciones",
    "href": "clases2025/temas_2do_parcial.html#parte-1-manejo-de-excepciones",
    "title": "Tarea 04: Repaso Parcial 2",
    "section": "",
    "text": "Demuestra, usando ejemplos, que la siguiente afirmaci√≥n es verdadera: ‚ÄúCada error de sintaxis es una excepci√≥n, pero no toda excepci√≥n puede ser un error de sintaxis.‚Äù\n¬øCu√°ndo se producen las siguientes excepciones? Proporciona ejemplos para respaldar tus respuestas.\n\nAssertionError\nImportError\nTypeError\nValueError\n\nInvestiga y define con ejemplos los siguientes conceptos (debes usar fuentes de informaci√≥n confiables, como libros, revistas, sitios web acad√©micos). Agrega las citas bibliogr√°ficas correspondientes:\n\nManejo de excepciones\nGenerar una excepci√≥n\nCapturar una excepci√≥n\n¬øPara que sirve la palabra reservada raise?\n\n\n\nBusca en redes sociales (instagram, twitter, tiktok, youtube, facebook, etc.) contenido multimedia que explique correctamente al menos uno de los conceptos anteriores y con el lenguaje de programaci√≥n que estamos usando en clase. Comparte el enlace del material encontrado."
  },
  {
    "objectID": "clases2025/temas_2do_parcial.html#parte-2-aserciones-y-pruebas-de-software",
    "href": "clases2025/temas_2do_parcial.html#parte-2-aserciones-y-pruebas-de-software",
    "title": "Tarea 04: Repaso Parcial 2",
    "section": "2 Parte 2: Aserciones y pruebas de software",
    "text": "2 Parte 2: Aserciones y pruebas de software"
  },
  {
    "objectID": "clases2025/temas_2do_parcial.html#parte-3-depuraci√≥n-de-errores",
    "href": "clases2025/temas_2do_parcial.html#parte-3-depuraci√≥n-de-errores",
    "title": "Tarea 04: Repaso Parcial 2",
    "section": "3 Parte 3: Depuraci√≥n de errores",
    "text": "3 Parte 3: Depuraci√≥n de errores"
  },
  {
    "objectID": "clases2025/temas_2do_parcial.html#parte-4-uso-de-bibliotecas-externas-numpy",
    "href": "clases2025/temas_2do_parcial.html#parte-4-uso-de-bibliotecas-externas-numpy",
    "title": "Tarea 04: Repaso Parcial 2",
    "section": "4 Parte 4: Uso de bibliotecas externas (NumPy)",
    "text": "4 Parte 4: Uso de bibliotecas externas (NumPy)"
  },
  {
    "objectID": "clases2025/Untitled.html",
    "href": "clases2025/Untitled.html",
    "title": "Semana 1: Introducci√≥n a la visualizaci√≥n gr√°fica y gr√°ficos tridimensionales",
    "section": "",
    "text": "Tema principal: Fundamentos de la visualizaci√≥n gr√°fica\n\nHistoria de los gr√°ficos tridimensionales.\nIntroducci√≥n a la triangulaci√≥n y superficies basadas en esquemas.\n\nActividad pr√°ctica: Familiarizaci√≥n con Blender o WebGL. Crear una superficie simple usando triangulaci√≥n.\n\n\n0.1 Semana 2: Superficies basadas en triangulaci√≥n\n\nTema principal: Generaci√≥n de superficies basadas en triangulaci√≥n\n\nTipos de superficies en 3D.\nAplicaciones en modelado y gr√°ficos 3D.\n\nActividad pr√°ctica: Modelar una figura sencilla (como un cubo) usando triangulaci√≥n en Blender o Three.js.\n\n\n\n0.2 Semana 3: Superficies basadas en esqueletos (Wireframes)\n\nTema principal: Estructuras en wireframes\n\n¬øQu√© es un wireframe? Usos y visualizaci√≥n.\nComparaci√≥n entre superficies trianguladas y wireframes.\n\nActividad pr√°ctica: Creaci√≥n de un wireframe de un objeto tridimensional en Blender o WebGL.\n\n\n\n0.3 Semana 4: Gr√°ficas de contornos (Modelos 3D)\n\nTema principal: Visualizaci√≥n de modelos tridimensionales mediante gr√°ficas de contornos\n\nDefinici√≥n y usos de contornos en gr√°ficos 3D.\nEjemplos pr√°cticos de contornos y su representaci√≥n visual.\n\nActividad pr√°ctica: Uso de Matplotlib o Mayavi en Python para crear gr√°ficas de contornos.\n\n\n\n0.4 Semana 5: Puntas y l√≠neas en gr√°ficos 3D\n\nTema principal: Creaci√≥n de gr√°ficos con puntas y l√≠neas\n\nIntroducci√≥n a la visualizaci√≥n de puntos y l√≠neas en modelos 3D.\nDiferencias entre gr√°ficos de malla y l√≠neas.\n\nActividad pr√°ctica: Representaci√≥n de puntos y l√≠neas en Blender o con Three.js.\n\n\n\n0.5 Semana 6: Gr√°ficos especializados (Matriz de confusi√≥n)\n\nTema principal: Uso de gr√°ficos especializados en IA\n\nMatriz de confusi√≥n: definici√≥n y aplicaci√≥n en modelos de clasificaci√≥n.\nInterpretaci√≥n de resultados visualizados mediante matrices de confusi√≥n.\n\nActividad pr√°ctica: Generaci√≥n de una matriz de confusi√≥n en Python con Seaborn o Matplotlib.\n\n\n\n0.6 Semana 7: Visualizaci√≥n avanzada de datos (alta dimensionalidad)\n\nTema principal: T√©cnicas de visualizaci√≥n de datos multidimensionales\n\n¬øQu√© es la alta dimensionalidad?\nM√©todos para reducir dimensionalidad (PCA, t-SNE).\n\nActividad pr√°ctica: Uso de Python y Plotly para visualizar datasets de alta dimensionalidad, aplicando reducci√≥n de dimensionalidad.\n\n\n\n0.7 Semana 8: Visualizaci√≥n de volumen de datos escalares\n\nTema principal: Visualizaci√≥n de datos escalares\n\n¬øQu√© son los datos escalares? T√©cnicas para visualizarlos.\nEjemplos de vol√∫menes escalarmente definidos.\n\nActividad pr√°ctica: Creaci√≥n de visualizaciones de volumen de datos escalares usando Mayavi o Paraview.\n\n\n\n0.8 Semana 9: Visualizaci√≥n de volumen de datos vectoriales\n\nTema principal: Visualizaci√≥n avanzada de datos vectoriales\n\nDiferencias entre datos vectoriales y escalares.\nAplicaciones de la visualizaci√≥n de campos vectoriales.\n\nActividad pr√°ctica: Visualizaci√≥n de vol√∫menes vectoriales en Python usando Mayavi o VTK.\n\n\n\n0.9 Semana 10: Introducci√≥n a la realidad aumentada\n\nTema principal: Fundamentos de la realidad aumentada (AR)\n\nDefinici√≥n y diferencias entre AR, VR y MR (Realidad Virtual y Realidad Mixta).\nAplicaciones actuales de la AR en la industria.\n\nActividad pr√°ctica: Instalaci√≥n de Unity y exploraci√≥n del entorno de desarrollo.\n\n\n\n0.10 Semana 11: Conceptos b√°sicos de Unity\n\nTema principal: Desarrollo de aplicaciones en Unity\n\nIntroducci√≥n al motor gr√°fico Unity.\nNavegaci√≥n y uso del editor de Unity para proyectos en AR.\n\nActividad pr√°ctica: Creaci√≥n de un proyecto b√°sico en Unity para visualizar un objeto 3D en una escena.\n\n\n\n0.11 Semana 12: Importar modelos 3D con materiales y texturas\n\nTema principal: Modelado avanzado e importaci√≥n de objetos en Unity\n\nT√©cnicas para importar modelos 3D con materiales y texturas.\nUso de Blender para crear modelos y exportarlos a Unity.\n\nActividad pr√°ctica: Importaci√≥n de un modelo 3D en Unity y aplicaci√≥n de texturas y materiales.\n\n\n\n0.12 Semana 13: Sistema de animaci√≥n en Unity\n\nTema principal: Introducci√≥n a las animaciones en Unity\n\nCreaci√≥n de animaciones b√°sicas en Unity.\nControl de animaciones en tiempo real.\n\nActividad pr√°ctica: Creaci√≥n de una simple animaci√≥n para un objeto 3D en Unity."
  },
  {
    "objectID": "clases2025/Untitled2.html",
    "href": "clases2025/Untitled2.html",
    "title": "Programaci√≥n Aplicada II",
    "section": "",
    "text": "‚Äì\nA\nB\nC\nD\n\n\n\n\nA\n0\n1\n0\n0\n\n\nB\n1\n0\n1\n1\n\n\nC\n0\n1\n0\n1\n\n\nD\n0\n1\n1\n0\n\n\n\n\n\n\n‚Äì\nA\nB\nC\nD\n\n\n\n\nA\n0\n1\n0\n0\n\n\nB\n1\n0\n1\n0\n\n\nC\n0\n1\n0\n1\n\n\nD\n0\n0\n1\n0\n\n\n\n\n\n\n‚Äì\nA\nB\nC\nD\n\n\n\n\nA\n0\n1\n1\n0\n\n\nB\n1\n0\n0\n1\n\n\nC\n1\n0\n0\n1\n\n\nD\n0\n1\n1\n0\n\n\n\n\n\n\n‚Äì\nA\nB\nC\nD\n\n\n\n\nA\n0\n1\n1\n0\n\n\nB\n1\n0\n0\n0\n\n\nC\n1\n0\n0\n1\n\n\nD\n0\n0\n1\n0"
  },
  {
    "objectID": "labs/index.html",
    "href": "labs/index.html",
    "title": "Ejercicios pr√°cticos de Programaci√≥n Aplicada II",
    "section": "",
    "text": "Bienvenidos a la secci√≥n de ejercicios pr√°cticos. Aqu√≠ encontrar√°n los notebooks y gu√≠as para aplicar los conceptos vistos en clase."
  },
  {
    "objectID": "labs/index.html#listado-de-pr√°cticas",
    "href": "labs/index.html#listado-de-pr√°cticas",
    "title": "Ejercicios pr√°cticos de Programaci√≥n Aplicada II",
    "section": "1 Listado de Pr√°cticas",
    "text": "1 Listado de Pr√°cticas"
  }
]